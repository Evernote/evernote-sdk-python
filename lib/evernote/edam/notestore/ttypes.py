#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import evernote.edam.userstore.ttypes
import evernote.edam.type.ttypes
import evernote.edam.error.ttypes
import evernote.edam.limits.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class UserSetting:
  RECEIVE_REMINDER_EMAIL = 1
  TIMEZONE = 2

  _VALUES_TO_NAMES = {
    1: "RECEIVE_REMINDER_EMAIL",
    2: "TIMEZONE",
  }

  _NAMES_TO_VALUES = {
    "RECEIVE_REMINDER_EMAIL": 1,
    "TIMEZONE": 2,
  }

class ShareRelationshipPrivilegeLevel:
  READ_NOTEBOOK = 0
  READ_NOTEBOOK_PLUS_ACTIVITY = 10
  MODIFY_NOTEBOOK_PLUS_ACTIVITY = 20
  FULL_ACCESS = 30

  _VALUES_TO_NAMES = {
    0: "READ_NOTEBOOK",
    10: "READ_NOTEBOOK_PLUS_ACTIVITY",
    20: "MODIFY_NOTEBOOK_PLUS_ACTIVITY",
    30: "FULL_ACCESS",
  }

  _NAMES_TO_VALUES = {
    "READ_NOTEBOOK": 0,
    "READ_NOTEBOOK_PLUS_ACTIVITY": 10,
    "MODIFY_NOTEBOOK_PLUS_ACTIVITY": 20,
    "FULL_ACCESS": 30,
  }


class SyncChunkFilter:
  """
  Attributes:
   - includeNotes
   - includeNoteResources
   - includeNoteAttributes
   - includeNotebooks
   - includeTags
   - includeSearches
   - includeResources
   - includeLinkedNotebooks
   - includeExpunged
   - includeNoteApplicationDataFullMap
   - includeResourceApplicationDataFullMap
   - includeNoteResourceApplicationDataFullMap
   - includePreferences
   - includedSharedNotes
   - omitSharedNotebooks
   - requireNoteContentClass
   - notebookGuids
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'includeNotes', None, None, ), # 1
    (2, TType.BOOL, 'includeNoteResources', None, None, ), # 2
    (3, TType.BOOL, 'includeNoteAttributes', None, None, ), # 3
    (4, TType.BOOL, 'includeNotebooks', None, None, ), # 4
    (5, TType.BOOL, 'includeTags', None, None, ), # 5
    (6, TType.BOOL, 'includeSearches', None, None, ), # 6
    (7, TType.BOOL, 'includeResources', None, None, ), # 7
    (8, TType.BOOL, 'includeLinkedNotebooks', None, None, ), # 8
    (9, TType.BOOL, 'includeExpunged', None, None, ), # 9
    (10, TType.BOOL, 'includeNoteApplicationDataFullMap', None, None, ), # 10
    (11, TType.STRING, 'requireNoteContentClass', None, None, ), # 11
    (12, TType.BOOL, 'includeResourceApplicationDataFullMap', None, None, ), # 12
    (13, TType.BOOL, 'includeNoteResourceApplicationDataFullMap', None, None, ), # 13
    (14, TType.BOOL, 'includePreferences', None, None, ), # 14
    (15, TType.SET, 'notebookGuids', (TType.STRING,None), None, ), # 15
    (16, TType.BOOL, 'omitSharedNotebooks', None, None, ), # 16
    (17, TType.BOOL, 'includedSharedNotes', None, None, ), # 17
  )

  def __init__(self, includeNotes=None, includeNoteResources=None, includeNoteAttributes=None, includeNotebooks=None, includeTags=None, includeSearches=None, includeResources=None, includeLinkedNotebooks=None, includeExpunged=None, includeNoteApplicationDataFullMap=None, includeResourceApplicationDataFullMap=None, includeNoteResourceApplicationDataFullMap=None, includePreferences=None, includedSharedNotes=None, omitSharedNotebooks=None, requireNoteContentClass=None, notebookGuids=None,):
    self.includeNotes = includeNotes
    self.includeNoteResources = includeNoteResources
    self.includeNoteAttributes = includeNoteAttributes
    self.includeNotebooks = includeNotebooks
    self.includeTags = includeTags
    self.includeSearches = includeSearches
    self.includeResources = includeResources
    self.includeLinkedNotebooks = includeLinkedNotebooks
    self.includeExpunged = includeExpunged
    self.includeNoteApplicationDataFullMap = includeNoteApplicationDataFullMap
    self.includeResourceApplicationDataFullMap = includeResourceApplicationDataFullMap
    self.includeNoteResourceApplicationDataFullMap = includeNoteResourceApplicationDataFullMap
    self.includePreferences = includePreferences
    self.includedSharedNotes = includedSharedNotes
    self.omitSharedNotebooks = omitSharedNotebooks
    self.requireNoteContentClass = requireNoteContentClass
    self.notebookGuids = notebookGuids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.includeNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.includeNoteResources = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.includeNoteAttributes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.includeNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.includeTags = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.includeSearches = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.includeResources = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.includeLinkedNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.includeExpunged = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.includeNoteApplicationDataFullMap = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.includeResourceApplicationDataFullMap = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.includeNoteResourceApplicationDataFullMap = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.includePreferences = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.BOOL:
          self.includedSharedNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BOOL:
          self.omitSharedNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.requireNoteContentClass = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.SET:
          self.notebookGuids = set()
          (_etype3, _size0) = iprot.readSetBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.notebookGuids.add(_elem5)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SyncChunkFilter')
    if self.includeNotes is not None:
      oprot.writeFieldBegin('includeNotes', TType.BOOL, 1)
      oprot.writeBool(self.includeNotes)
      oprot.writeFieldEnd()
    if self.includeNoteResources is not None:
      oprot.writeFieldBegin('includeNoteResources', TType.BOOL, 2)
      oprot.writeBool(self.includeNoteResources)
      oprot.writeFieldEnd()
    if self.includeNoteAttributes is not None:
      oprot.writeFieldBegin('includeNoteAttributes', TType.BOOL, 3)
      oprot.writeBool(self.includeNoteAttributes)
      oprot.writeFieldEnd()
    if self.includeNotebooks is not None:
      oprot.writeFieldBegin('includeNotebooks', TType.BOOL, 4)
      oprot.writeBool(self.includeNotebooks)
      oprot.writeFieldEnd()
    if self.includeTags is not None:
      oprot.writeFieldBegin('includeTags', TType.BOOL, 5)
      oprot.writeBool(self.includeTags)
      oprot.writeFieldEnd()
    if self.includeSearches is not None:
      oprot.writeFieldBegin('includeSearches', TType.BOOL, 6)
      oprot.writeBool(self.includeSearches)
      oprot.writeFieldEnd()
    if self.includeResources is not None:
      oprot.writeFieldBegin('includeResources', TType.BOOL, 7)
      oprot.writeBool(self.includeResources)
      oprot.writeFieldEnd()
    if self.includeLinkedNotebooks is not None:
      oprot.writeFieldBegin('includeLinkedNotebooks', TType.BOOL, 8)
      oprot.writeBool(self.includeLinkedNotebooks)
      oprot.writeFieldEnd()
    if self.includeExpunged is not None:
      oprot.writeFieldBegin('includeExpunged', TType.BOOL, 9)
      oprot.writeBool(self.includeExpunged)
      oprot.writeFieldEnd()
    if self.includeNoteApplicationDataFullMap is not None:
      oprot.writeFieldBegin('includeNoteApplicationDataFullMap', TType.BOOL, 10)
      oprot.writeBool(self.includeNoteApplicationDataFullMap)
      oprot.writeFieldEnd()
    if self.requireNoteContentClass is not None:
      oprot.writeFieldBegin('requireNoteContentClass', TType.STRING, 11)
      oprot.writeString(self.requireNoteContentClass)
      oprot.writeFieldEnd()
    if self.includeResourceApplicationDataFullMap is not None:
      oprot.writeFieldBegin('includeResourceApplicationDataFullMap', TType.BOOL, 12)
      oprot.writeBool(self.includeResourceApplicationDataFullMap)
      oprot.writeFieldEnd()
    if self.includeNoteResourceApplicationDataFullMap is not None:
      oprot.writeFieldBegin('includeNoteResourceApplicationDataFullMap', TType.BOOL, 13)
      oprot.writeBool(self.includeNoteResourceApplicationDataFullMap)
      oprot.writeFieldEnd()
    if self.includePreferences is not None:
      oprot.writeFieldBegin('includePreferences', TType.BOOL, 14)
      oprot.writeBool(self.includePreferences)
      oprot.writeFieldEnd()
    if self.notebookGuids is not None:
      oprot.writeFieldBegin('notebookGuids', TType.SET, 15)
      oprot.writeSetBegin(TType.STRING, len(self.notebookGuids))
      for iter6 in self.notebookGuids:
        oprot.writeString(iter6)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.omitSharedNotebooks is not None:
      oprot.writeFieldBegin('omitSharedNotebooks', TType.BOOL, 16)
      oprot.writeBool(self.omitSharedNotebooks)
      oprot.writeFieldEnd()
    if self.includedSharedNotes is not None:
      oprot.writeFieldBegin('includedSharedNotes', TType.BOOL, 17)
      oprot.writeBool(self.includedSharedNotes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.includeNotes)
    value = (value * 31) ^ hash(self.includeNoteResources)
    value = (value * 31) ^ hash(self.includeNoteAttributes)
    value = (value * 31) ^ hash(self.includeNotebooks)
    value = (value * 31) ^ hash(self.includeTags)
    value = (value * 31) ^ hash(self.includeSearches)
    value = (value * 31) ^ hash(self.includeResources)
    value = (value * 31) ^ hash(self.includeLinkedNotebooks)
    value = (value * 31) ^ hash(self.includeExpunged)
    value = (value * 31) ^ hash(self.includeNoteApplicationDataFullMap)
    value = (value * 31) ^ hash(self.includeResourceApplicationDataFullMap)
    value = (value * 31) ^ hash(self.includeNoteResourceApplicationDataFullMap)
    value = (value * 31) ^ hash(self.includePreferences)
    value = (value * 31) ^ hash(self.includedSharedNotes)
    value = (value * 31) ^ hash(self.omitSharedNotebooks)
    value = (value * 31) ^ hash(self.requireNoteContentClass)
    value = (value * 31) ^ hash(self.notebookGuids)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteFilter:
  """
  Attributes:
   - order
   - ascending
   - words
   - notebookGuid
   - tagGuids
   - timeZone
   - inactive
   - emphasized
   - includeAllReadableNotebooks
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'order', None, None, ), # 1
    (2, TType.BOOL, 'ascending', None, None, ), # 2
    (3, TType.STRING, 'words', None, None, ), # 3
    (4, TType.STRING, 'notebookGuid', None, None, ), # 4
    (5, TType.LIST, 'tagGuids', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'timeZone', None, None, ), # 6
    (7, TType.BOOL, 'inactive', None, None, ), # 7
    (8, TType.STRING, 'emphasized', None, None, ), # 8
    (9, TType.BOOL, 'includeAllReadableNotebooks', None, None, ), # 9
  )

  def __init__(self, order=None, ascending=None, words=None, notebookGuid=None, tagGuids=None, timeZone=None, inactive=None, emphasized=None, includeAllReadableNotebooks=None,):
    self.order = order
    self.ascending = ascending
    self.words = words
    self.notebookGuid = notebookGuid
    self.tagGuids = tagGuids
    self.timeZone = timeZone
    self.inactive = inactive
    self.emphasized = emphasized
    self.includeAllReadableNotebooks = includeAllReadableNotebooks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.order = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.ascending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.words = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.tagGuids = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.tagGuids.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.timeZone = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.inactive = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.emphasized = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.includeAllReadableNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteFilter')
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 1)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    if self.ascending is not None:
      oprot.writeFieldBegin('ascending', TType.BOOL, 2)
      oprot.writeBool(self.ascending)
      oprot.writeFieldEnd()
    if self.words is not None:
      oprot.writeFieldBegin('words', TType.STRING, 3)
      oprot.writeString(self.words)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 4)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.tagGuids is not None:
      oprot.writeFieldBegin('tagGuids', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.tagGuids))
      for iter13 in self.tagGuids:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timeZone is not None:
      oprot.writeFieldBegin('timeZone', TType.STRING, 6)
      oprot.writeString(self.timeZone)
      oprot.writeFieldEnd()
    if self.inactive is not None:
      oprot.writeFieldBegin('inactive', TType.BOOL, 7)
      oprot.writeBool(self.inactive)
      oprot.writeFieldEnd()
    if self.emphasized is not None:
      oprot.writeFieldBegin('emphasized', TType.STRING, 8)
      oprot.writeString(self.emphasized)
      oprot.writeFieldEnd()
    if self.includeAllReadableNotebooks is not None:
      oprot.writeFieldBegin('includeAllReadableNotebooks', TType.BOOL, 9)
      oprot.writeBool(self.includeAllReadableNotebooks)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.order)
    value = (value * 31) ^ hash(self.ascending)
    value = (value * 31) ^ hash(self.words)
    value = (value * 31) ^ hash(self.notebookGuid)
    value = (value * 31) ^ hash(self.tagGuids)
    value = (value * 31) ^ hash(self.timeZone)
    value = (value * 31) ^ hash(self.inactive)
    value = (value * 31) ^ hash(self.emphasized)
    value = (value * 31) ^ hash(self.includeAllReadableNotebooks)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteList:
  """
  Attributes:
   - startIndex
   - totalNotes
   - notes
   - stoppedWords
   - searchedWords
   - updateCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'startIndex', None, None, ), # 1
    (2, TType.I32, 'totalNotes', None, None, ), # 2
    (3, TType.LIST, 'notes', (TType.STRUCT,(evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'stoppedWords', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'searchedWords', (TType.STRING,None), None, ), # 5
    (6, TType.I32, 'updateCount', None, None, ), # 6
  )

  def __init__(self, startIndex=None, totalNotes=None, notes=None, stoppedWords=None, searchedWords=None, updateCount=None,):
    self.startIndex = startIndex
    self.totalNotes = totalNotes
    self.notes = notes
    self.stoppedWords = stoppedWords
    self.searchedWords = searchedWords
    self.updateCount = updateCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.startIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.totalNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.notes = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = evernote.edam.type.ttypes.Note()
            _elem19.read(iprot)
            self.notes.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stoppedWords = []
          (_etype23, _size20) = iprot.readListBegin()
          for _i24 in xrange(_size20):
            _elem25 = iprot.readString();
            self.stoppedWords.append(_elem25)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.searchedWords = []
          (_etype29, _size26) = iprot.readListBegin()
          for _i30 in xrange(_size26):
            _elem31 = iprot.readString();
            self.searchedWords.append(_elem31)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteList')
    if self.startIndex is not None:
      oprot.writeFieldBegin('startIndex', TType.I32, 1)
      oprot.writeI32(self.startIndex)
      oprot.writeFieldEnd()
    if self.totalNotes is not None:
      oprot.writeFieldBegin('totalNotes', TType.I32, 2)
      oprot.writeI32(self.totalNotes)
      oprot.writeFieldEnd()
    if self.notes is not None:
      oprot.writeFieldBegin('notes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter32 in self.notes:
        iter32.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stoppedWords is not None:
      oprot.writeFieldBegin('stoppedWords', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.stoppedWords))
      for iter33 in self.stoppedWords:
        oprot.writeString(iter33)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searchedWords is not None:
      oprot.writeFieldBegin('searchedWords', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.searchedWords))
      for iter34 in self.searchedWords:
        oprot.writeString(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.updateCount is not None:
      oprot.writeFieldBegin('updateCount', TType.I32, 6)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.startIndex is None:
      raise TProtocol.TProtocolException(message='Required field startIndex is unset!')
    if self.totalNotes is None:
      raise TProtocol.TProtocolException(message='Required field totalNotes is unset!')
    if self.notes is None:
      raise TProtocol.TProtocolException(message='Required field notes is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startIndex)
    value = (value * 31) ^ hash(self.totalNotes)
    value = (value * 31) ^ hash(self.notes)
    value = (value * 31) ^ hash(self.stoppedWords)
    value = (value * 31) ^ hash(self.searchedWords)
    value = (value * 31) ^ hash(self.updateCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteMetadata:
  """
  Attributes:
   - guid
   - title
   - contentLength
   - created
   - updated
   - deleted
   - updateSequenceNum
   - notebookGuid
   - tagGuids
   - attributes
   - largestResourceMime
   - largestResourceSize
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'title', None, None, ), # 2
    None, # 3
    None, # 4
    (5, TType.I32, 'contentLength', None, None, ), # 5
    (6, TType.I64, 'created', None, None, ), # 6
    (7, TType.I64, 'updated', None, None, ), # 7
    (8, TType.I64, 'deleted', None, None, ), # 8
    None, # 9
    (10, TType.I32, 'updateSequenceNum', None, None, ), # 10
    (11, TType.STRING, 'notebookGuid', None, None, ), # 11
    (12, TType.LIST, 'tagGuids', (TType.STRING,None), None, ), # 12
    None, # 13
    (14, TType.STRUCT, 'attributes', (evernote.edam.type.ttypes.NoteAttributes, evernote.edam.type.ttypes.NoteAttributes.thrift_spec), None, ), # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.STRING, 'largestResourceMime', None, None, ), # 20
    (21, TType.I32, 'largestResourceSize', None, None, ), # 21
  )

  def __init__(self, guid=None, title=None, contentLength=None, created=None, updated=None, deleted=None, updateSequenceNum=None, notebookGuid=None, tagGuids=None, attributes=None, largestResourceMime=None, largestResourceSize=None,):
    self.guid = guid
    self.title = title
    self.contentLength = contentLength
    self.created = created
    self.updated = updated
    self.deleted = deleted
    self.updateSequenceNum = updateSequenceNum
    self.notebookGuid = notebookGuid
    self.tagGuids = tagGuids
    self.attributes = attributes
    self.largestResourceMime = largestResourceMime
    self.largestResourceSize = largestResourceSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.contentLength = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.created = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.deleted = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.tagGuids = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = iprot.readString();
            self.tagGuids.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.attributes = evernote.edam.type.ttypes.NoteAttributes()
          self.attributes.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.largestResourceMime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.I32:
          self.largestResourceSize = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteMetadata')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 2)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.contentLength is not None:
      oprot.writeFieldBegin('contentLength', TType.I32, 5)
      oprot.writeI32(self.contentLength)
      oprot.writeFieldEnd()
    if self.created is not None:
      oprot.writeFieldBegin('created', TType.I64, 6)
      oprot.writeI64(self.created)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 7)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.deleted is not None:
      oprot.writeFieldBegin('deleted', TType.I64, 8)
      oprot.writeI64(self.deleted)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 10)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 11)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.tagGuids is not None:
      oprot.writeFieldBegin('tagGuids', TType.LIST, 12)
      oprot.writeListBegin(TType.STRING, len(self.tagGuids))
      for iter41 in self.tagGuids:
        oprot.writeString(iter41)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.STRUCT, 14)
      self.attributes.write(oprot)
      oprot.writeFieldEnd()
    if self.largestResourceMime is not None:
      oprot.writeFieldBegin('largestResourceMime', TType.STRING, 20)
      oprot.writeString(self.largestResourceMime)
      oprot.writeFieldEnd()
    if self.largestResourceSize is not None:
      oprot.writeFieldBegin('largestResourceSize', TType.I32, 21)
      oprot.writeI32(self.largestResourceSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.guid is None:
      raise TProtocol.TProtocolException(message='Required field guid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.guid)
    value = (value * 31) ^ hash(self.title)
    value = (value * 31) ^ hash(self.contentLength)
    value = (value * 31) ^ hash(self.created)
    value = (value * 31) ^ hash(self.updated)
    value = (value * 31) ^ hash(self.deleted)
    value = (value * 31) ^ hash(self.updateSequenceNum)
    value = (value * 31) ^ hash(self.notebookGuid)
    value = (value * 31) ^ hash(self.tagGuids)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.largestResourceMime)
    value = (value * 31) ^ hash(self.largestResourceSize)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotesMetadataList:
  """
  Attributes:
   - startIndex
   - totalNotes
   - notes
   - stoppedWords
   - searchedWords
   - updateCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'startIndex', None, None, ), # 1
    (2, TType.I32, 'totalNotes', None, None, ), # 2
    (3, TType.LIST, 'notes', (TType.STRUCT,(NoteMetadata, NoteMetadata.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'stoppedWords', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'searchedWords', (TType.STRING,None), None, ), # 5
    (6, TType.I32, 'updateCount', None, None, ), # 6
  )

  def __init__(self, startIndex=None, totalNotes=None, notes=None, stoppedWords=None, searchedWords=None, updateCount=None,):
    self.startIndex = startIndex
    self.totalNotes = totalNotes
    self.notes = notes
    self.stoppedWords = stoppedWords
    self.searchedWords = searchedWords
    self.updateCount = updateCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.startIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.totalNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.notes = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = NoteMetadata()
            _elem47.read(iprot)
            self.notes.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stoppedWords = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = iprot.readString();
            self.stoppedWords.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.searchedWords = []
          (_etype57, _size54) = iprot.readListBegin()
          for _i58 in xrange(_size54):
            _elem59 = iprot.readString();
            self.searchedWords.append(_elem59)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotesMetadataList')
    if self.startIndex is not None:
      oprot.writeFieldBegin('startIndex', TType.I32, 1)
      oprot.writeI32(self.startIndex)
      oprot.writeFieldEnd()
    if self.totalNotes is not None:
      oprot.writeFieldBegin('totalNotes', TType.I32, 2)
      oprot.writeI32(self.totalNotes)
      oprot.writeFieldEnd()
    if self.notes is not None:
      oprot.writeFieldBegin('notes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter60 in self.notes:
        iter60.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stoppedWords is not None:
      oprot.writeFieldBegin('stoppedWords', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.stoppedWords))
      for iter61 in self.stoppedWords:
        oprot.writeString(iter61)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searchedWords is not None:
      oprot.writeFieldBegin('searchedWords', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.searchedWords))
      for iter62 in self.searchedWords:
        oprot.writeString(iter62)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.updateCount is not None:
      oprot.writeFieldBegin('updateCount', TType.I32, 6)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.startIndex is None:
      raise TProtocol.TProtocolException(message='Required field startIndex is unset!')
    if self.totalNotes is None:
      raise TProtocol.TProtocolException(message='Required field totalNotes is unset!')
    if self.notes is None:
      raise TProtocol.TProtocolException(message='Required field notes is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startIndex)
    value = (value * 31) ^ hash(self.totalNotes)
    value = (value * 31) ^ hash(self.notes)
    value = (value * 31) ^ hash(self.stoppedWords)
    value = (value * 31) ^ hash(self.searchedWords)
    value = (value * 31) ^ hash(self.updateCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotesMetadataResultSpec:
  """
  Attributes:
   - includeTitle
   - includeContentLength
   - includeCreated
   - includeUpdated
   - includeDeleted
   - includeUpdateSequenceNum
   - includeNotebookGuid
   - includeTagGuids
   - includeAttributes
   - includeLargestResourceMime
   - includeLargestResourceSize
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.BOOL, 'includeTitle', None, None, ), # 2
    None, # 3
    None, # 4
    (5, TType.BOOL, 'includeContentLength', None, None, ), # 5
    (6, TType.BOOL, 'includeCreated', None, None, ), # 6
    (7, TType.BOOL, 'includeUpdated', None, None, ), # 7
    (8, TType.BOOL, 'includeDeleted', None, None, ), # 8
    None, # 9
    (10, TType.BOOL, 'includeUpdateSequenceNum', None, None, ), # 10
    (11, TType.BOOL, 'includeNotebookGuid', None, None, ), # 11
    (12, TType.BOOL, 'includeTagGuids', None, None, ), # 12
    None, # 13
    (14, TType.BOOL, 'includeAttributes', None, None, ), # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.BOOL, 'includeLargestResourceMime', None, None, ), # 20
    (21, TType.BOOL, 'includeLargestResourceSize', None, None, ), # 21
  )

  def __init__(self, includeTitle=None, includeContentLength=None, includeCreated=None, includeUpdated=None, includeDeleted=None, includeUpdateSequenceNum=None, includeNotebookGuid=None, includeTagGuids=None, includeAttributes=None, includeLargestResourceMime=None, includeLargestResourceSize=None,):
    self.includeTitle = includeTitle
    self.includeContentLength = includeContentLength
    self.includeCreated = includeCreated
    self.includeUpdated = includeUpdated
    self.includeDeleted = includeDeleted
    self.includeUpdateSequenceNum = includeUpdateSequenceNum
    self.includeNotebookGuid = includeNotebookGuid
    self.includeTagGuids = includeTagGuids
    self.includeAttributes = includeAttributes
    self.includeLargestResourceMime = includeLargestResourceMime
    self.includeLargestResourceSize = includeLargestResourceSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.includeTitle = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.includeContentLength = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.includeCreated = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.includeUpdated = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.includeDeleted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.includeUpdateSequenceNum = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.includeNotebookGuid = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.includeTagGuids = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.includeAttributes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.BOOL:
          self.includeLargestResourceMime = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.BOOL:
          self.includeLargestResourceSize = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotesMetadataResultSpec')
    if self.includeTitle is not None:
      oprot.writeFieldBegin('includeTitle', TType.BOOL, 2)
      oprot.writeBool(self.includeTitle)
      oprot.writeFieldEnd()
    if self.includeContentLength is not None:
      oprot.writeFieldBegin('includeContentLength', TType.BOOL, 5)
      oprot.writeBool(self.includeContentLength)
      oprot.writeFieldEnd()
    if self.includeCreated is not None:
      oprot.writeFieldBegin('includeCreated', TType.BOOL, 6)
      oprot.writeBool(self.includeCreated)
      oprot.writeFieldEnd()
    if self.includeUpdated is not None:
      oprot.writeFieldBegin('includeUpdated', TType.BOOL, 7)
      oprot.writeBool(self.includeUpdated)
      oprot.writeFieldEnd()
    if self.includeDeleted is not None:
      oprot.writeFieldBegin('includeDeleted', TType.BOOL, 8)
      oprot.writeBool(self.includeDeleted)
      oprot.writeFieldEnd()
    if self.includeUpdateSequenceNum is not None:
      oprot.writeFieldBegin('includeUpdateSequenceNum', TType.BOOL, 10)
      oprot.writeBool(self.includeUpdateSequenceNum)
      oprot.writeFieldEnd()
    if self.includeNotebookGuid is not None:
      oprot.writeFieldBegin('includeNotebookGuid', TType.BOOL, 11)
      oprot.writeBool(self.includeNotebookGuid)
      oprot.writeFieldEnd()
    if self.includeTagGuids is not None:
      oprot.writeFieldBegin('includeTagGuids', TType.BOOL, 12)
      oprot.writeBool(self.includeTagGuids)
      oprot.writeFieldEnd()
    if self.includeAttributes is not None:
      oprot.writeFieldBegin('includeAttributes', TType.BOOL, 14)
      oprot.writeBool(self.includeAttributes)
      oprot.writeFieldEnd()
    if self.includeLargestResourceMime is not None:
      oprot.writeFieldBegin('includeLargestResourceMime', TType.BOOL, 20)
      oprot.writeBool(self.includeLargestResourceMime)
      oprot.writeFieldEnd()
    if self.includeLargestResourceSize is not None:
      oprot.writeFieldBegin('includeLargestResourceSize', TType.BOOL, 21)
      oprot.writeBool(self.includeLargestResourceSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.includeTitle)
    value = (value * 31) ^ hash(self.includeContentLength)
    value = (value * 31) ^ hash(self.includeCreated)
    value = (value * 31) ^ hash(self.includeUpdated)
    value = (value * 31) ^ hash(self.includeDeleted)
    value = (value * 31) ^ hash(self.includeUpdateSequenceNum)
    value = (value * 31) ^ hash(self.includeNotebookGuid)
    value = (value * 31) ^ hash(self.includeTagGuids)
    value = (value * 31) ^ hash(self.includeAttributes)
    value = (value * 31) ^ hash(self.includeLargestResourceMime)
    value = (value * 31) ^ hash(self.includeLargestResourceSize)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteCollectionCounts:
  """
  Attributes:
   - notebookCounts
   - tagCounts
   - trashCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'notebookCounts', (TType.STRING,None,TType.I32,None), None, ), # 1
    (2, TType.MAP, 'tagCounts', (TType.STRING,None,TType.I32,None), None, ), # 2
    (3, TType.I32, 'trashCount', None, None, ), # 3
  )

  def __init__(self, notebookCounts=None, tagCounts=None, trashCount=None,):
    self.notebookCounts = notebookCounts
    self.tagCounts = tagCounts
    self.trashCount = trashCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.notebookCounts = {}
          (_ktype64, _vtype65, _size63 ) = iprot.readMapBegin()
          for _i67 in xrange(_size63):
            _key68 = iprot.readString();
            _val69 = iprot.readI32();
            self.notebookCounts[_key68] = _val69
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.tagCounts = {}
          (_ktype71, _vtype72, _size70 ) = iprot.readMapBegin()
          for _i74 in xrange(_size70):
            _key75 = iprot.readString();
            _val76 = iprot.readI32();
            self.tagCounts[_key75] = _val76
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.trashCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteCollectionCounts')
    if self.notebookCounts is not None:
      oprot.writeFieldBegin('notebookCounts', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.notebookCounts))
      for kiter77,viter78 in self.notebookCounts.items():
        oprot.writeString(kiter77)
        oprot.writeI32(viter78)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.tagCounts is not None:
      oprot.writeFieldBegin('tagCounts', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.tagCounts))
      for kiter79,viter80 in self.tagCounts.items():
        oprot.writeString(kiter79)
        oprot.writeI32(viter80)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.trashCount is not None:
      oprot.writeFieldBegin('trashCount', TType.I32, 3)
      oprot.writeI32(self.trashCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.notebookCounts)
    value = (value * 31) ^ hash(self.tagCounts)
    value = (value * 31) ^ hash(self.trashCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteResultSpec:
  """
  Attributes:
   - includeContent
   - includeResourcesData
   - includeResourcesRecognition
   - includeResourcesAlternateData
   - includeSharedNotes
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'includeContent', None, None, ), # 1
    (2, TType.BOOL, 'includeResourcesData', None, None, ), # 2
    (3, TType.BOOL, 'includeResourcesRecognition', None, None, ), # 3
    (4, TType.BOOL, 'includeResourcesAlternateData', None, None, ), # 4
    (5, TType.BOOL, 'includeSharedNotes', None, None, ), # 5
  )

  def __init__(self, includeContent=None, includeResourcesData=None, includeResourcesRecognition=None, includeResourcesAlternateData=None, includeSharedNotes=None,):
    self.includeContent = includeContent
    self.includeResourcesData = includeResourcesData
    self.includeResourcesRecognition = includeResourcesRecognition
    self.includeResourcesAlternateData = includeResourcesAlternateData
    self.includeSharedNotes = includeSharedNotes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.includeContent = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.includeResourcesData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.includeResourcesRecognition = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.includeResourcesAlternateData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.includeSharedNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteResultSpec')
    if self.includeContent is not None:
      oprot.writeFieldBegin('includeContent', TType.BOOL, 1)
      oprot.writeBool(self.includeContent)
      oprot.writeFieldEnd()
    if self.includeResourcesData is not None:
      oprot.writeFieldBegin('includeResourcesData', TType.BOOL, 2)
      oprot.writeBool(self.includeResourcesData)
      oprot.writeFieldEnd()
    if self.includeResourcesRecognition is not None:
      oprot.writeFieldBegin('includeResourcesRecognition', TType.BOOL, 3)
      oprot.writeBool(self.includeResourcesRecognition)
      oprot.writeFieldEnd()
    if self.includeResourcesAlternateData is not None:
      oprot.writeFieldBegin('includeResourcesAlternateData', TType.BOOL, 4)
      oprot.writeBool(self.includeResourcesAlternateData)
      oprot.writeFieldEnd()
    if self.includeSharedNotes is not None:
      oprot.writeFieldBegin('includeSharedNotes', TType.BOOL, 5)
      oprot.writeBool(self.includeSharedNotes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.includeContent)
    value = (value * 31) ^ hash(self.includeResourcesData)
    value = (value * 31) ^ hash(self.includeResourcesRecognition)
    value = (value * 31) ^ hash(self.includeResourcesAlternateData)
    value = (value * 31) ^ hash(self.includeSharedNotes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteEmailParameters:
  """
  Attributes:
   - guid
   - note
   - toAddresses
   - ccAddresses
   - subject
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRUCT, 'note', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 2
    (3, TType.LIST, 'toAddresses', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'ccAddresses', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'subject', None, None, ), # 5
    (6, TType.STRING, 'message', None, None, ), # 6
  )

  def __init__(self, guid=None, note=None, toAddresses=None, ccAddresses=None, subject=None, message=None,):
    self.guid = guid
    self.note = note
    self.toAddresses = toAddresses
    self.ccAddresses = ccAddresses
    self.subject = subject
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.note = evernote.edam.type.ttypes.Note()
          self.note.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.toAddresses = []
          (_etype84, _size81) = iprot.readListBegin()
          for _i85 in xrange(_size81):
            _elem86 = iprot.readString();
            self.toAddresses.append(_elem86)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.ccAddresses = []
          (_etype90, _size87) = iprot.readListBegin()
          for _i91 in xrange(_size87):
            _elem92 = iprot.readString();
            self.ccAddresses.append(_elem92)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.subject = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteEmailParameters')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.note is not None:
      oprot.writeFieldBegin('note', TType.STRUCT, 2)
      self.note.write(oprot)
      oprot.writeFieldEnd()
    if self.toAddresses is not None:
      oprot.writeFieldBegin('toAddresses', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.toAddresses))
      for iter93 in self.toAddresses:
        oprot.writeString(iter93)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccAddresses is not None:
      oprot.writeFieldBegin('ccAddresses', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.ccAddresses))
      for iter94 in self.ccAddresses:
        oprot.writeString(iter94)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.subject is not None:
      oprot.writeFieldBegin('subject', TType.STRING, 5)
      oprot.writeString(self.subject)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 6)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.guid)
    value = (value * 31) ^ hash(self.note)
    value = (value * 31) ^ hash(self.toAddresses)
    value = (value * 31) ^ hash(self.ccAddresses)
    value = (value * 31) ^ hash(self.subject)
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteVersionId:
  """
  Attributes:
   - updateSequenceNum
   - updated
   - saved
   - title
   - lastEditorId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'updateSequenceNum', None, None, ), # 1
    (2, TType.I64, 'updated', None, None, ), # 2
    (3, TType.I64, 'saved', None, None, ), # 3
    (4, TType.STRING, 'title', None, None, ), # 4
    (5, TType.I32, 'lastEditorId', None, None, ), # 5
  )

  def __init__(self, updateSequenceNum=None, updated=None, saved=None, title=None, lastEditorId=None,):
    self.updateSequenceNum = updateSequenceNum
    self.updated = updated
    self.saved = saved
    self.title = title
    self.lastEditorId = lastEditorId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.saved = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lastEditorId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteVersionId')
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 1)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 2)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.saved is not None:
      oprot.writeFieldBegin('saved', TType.I64, 3)
      oprot.writeI64(self.saved)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 4)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.lastEditorId is not None:
      oprot.writeFieldBegin('lastEditorId', TType.I32, 5)
      oprot.writeI32(self.lastEditorId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.updateSequenceNum is None:
      raise TProtocol.TProtocolException(message='Required field updateSequenceNum is unset!')
    if self.updated is None:
      raise TProtocol.TProtocolException(message='Required field updated is unset!')
    if self.saved is None:
      raise TProtocol.TProtocolException(message='Required field saved is unset!')
    if self.title is None:
      raise TProtocol.TProtocolException(message='Required field title is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.updateSequenceNum)
    value = (value * 31) ^ hash(self.updated)
    value = (value * 31) ^ hash(self.saved)
    value = (value * 31) ^ hash(self.title)
    value = (value * 31) ^ hash(self.lastEditorId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RelatedQuery:
  """
  Attributes:
   - noteGuid
   - plainText
   - filter
   - referenceUri
   - context
   - cacheKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'noteGuid', None, None, ), # 1
    (2, TType.STRING, 'plainText', None, None, ), # 2
    (3, TType.STRUCT, 'filter', (NoteFilter, NoteFilter.thrift_spec), None, ), # 3
    (4, TType.STRING, 'referenceUri', None, None, ), # 4
    (5, TType.STRING, 'context', None, None, ), # 5
    (6, TType.STRING, 'cacheKey', None, None, ), # 6
  )

  def __init__(self, noteGuid=None, plainText=None, filter=None, referenceUri=None, context=None, cacheKey=None,):
    self.noteGuid = noteGuid
    self.plainText = plainText
    self.filter = filter
    self.referenceUri = referenceUri
    self.context = context
    self.cacheKey = cacheKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.plainText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.filter = NoteFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.referenceUri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.context = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.cacheKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RelatedQuery')
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 1)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.plainText is not None:
      oprot.writeFieldBegin('plainText', TType.STRING, 2)
      oprot.writeString(self.plainText)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 3)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.referenceUri is not None:
      oprot.writeFieldBegin('referenceUri', TType.STRING, 4)
      oprot.writeString(self.referenceUri)
      oprot.writeFieldEnd()
    if self.context is not None:
      oprot.writeFieldBegin('context', TType.STRING, 5)
      oprot.writeString(self.context)
      oprot.writeFieldEnd()
    if self.cacheKey is not None:
      oprot.writeFieldBegin('cacheKey', TType.STRING, 6)
      oprot.writeString(self.cacheKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.noteGuid)
    value = (value * 31) ^ hash(self.plainText)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.referenceUri)
    value = (value * 31) ^ hash(self.context)
    value = (value * 31) ^ hash(self.cacheKey)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RelatedResult:
  """
  Attributes:
   - notes
   - notebooks
   - tags
   - containingNotebooks
   - debugInfo
   - experts
   - relatedContent
   - cacheKey
   - cacheExpires
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'notes', (TType.STRUCT,(evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'notebooks', (TType.STRUCT,(evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'tags', (TType.STRUCT,(evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'containingNotebooks', (TType.STRUCT,(evernote.edam.type.ttypes.NotebookDescriptor, evernote.edam.type.ttypes.NotebookDescriptor.thrift_spec)), None, ), # 4
    (5, TType.STRING, 'debugInfo', None, None, ), # 5
    (6, TType.LIST, 'experts', (TType.STRUCT,(evernote.edam.type.ttypes.UserProfile, evernote.edam.type.ttypes.UserProfile.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'relatedContent', (TType.STRUCT,(evernote.edam.type.ttypes.RelatedContent, evernote.edam.type.ttypes.RelatedContent.thrift_spec)), None, ), # 7
    (8, TType.STRING, 'cacheKey', None, None, ), # 8
    (9, TType.I32, 'cacheExpires', None, None, ), # 9
  )

  def __init__(self, notes=None, notebooks=None, tags=None, containingNotebooks=None, debugInfo=None, experts=None, relatedContent=None, cacheKey=None, cacheExpires=None,):
    self.notes = notes
    self.notebooks = notebooks
    self.tags = tags
    self.containingNotebooks = containingNotebooks
    self.debugInfo = debugInfo
    self.experts = experts
    self.relatedContent = relatedContent
    self.cacheKey = cacheKey
    self.cacheExpires = cacheExpires

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.notes = []
          (_etype98, _size95) = iprot.readListBegin()
          for _i99 in xrange(_size95):
            _elem100 = evernote.edam.type.ttypes.Note()
            _elem100.read(iprot)
            self.notes.append(_elem100)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.notebooks = []
          (_etype104, _size101) = iprot.readListBegin()
          for _i105 in xrange(_size101):
            _elem106 = evernote.edam.type.ttypes.Notebook()
            _elem106.read(iprot)
            self.notebooks.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tags = []
          (_etype110, _size107) = iprot.readListBegin()
          for _i111 in xrange(_size107):
            _elem112 = evernote.edam.type.ttypes.Tag()
            _elem112.read(iprot)
            self.tags.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.containingNotebooks = []
          (_etype116, _size113) = iprot.readListBegin()
          for _i117 in xrange(_size113):
            _elem118 = evernote.edam.type.ttypes.NotebookDescriptor()
            _elem118.read(iprot)
            self.containingNotebooks.append(_elem118)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.debugInfo = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.experts = []
          (_etype122, _size119) = iprot.readListBegin()
          for _i123 in xrange(_size119):
            _elem124 = evernote.edam.type.ttypes.UserProfile()
            _elem124.read(iprot)
            self.experts.append(_elem124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.relatedContent = []
          (_etype128, _size125) = iprot.readListBegin()
          for _i129 in xrange(_size125):
            _elem130 = evernote.edam.type.ttypes.RelatedContent()
            _elem130.read(iprot)
            self.relatedContent.append(_elem130)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.cacheKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.cacheExpires = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RelatedResult')
    if self.notes is not None:
      oprot.writeFieldBegin('notes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter131 in self.notes:
        iter131.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.notebooks is not None:
      oprot.writeFieldBegin('notebooks', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.notebooks))
      for iter132 in self.notebooks:
        iter132.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.tags is not None:
      oprot.writeFieldBegin('tags', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter133 in self.tags:
        iter133.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.containingNotebooks is not None:
      oprot.writeFieldBegin('containingNotebooks', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.containingNotebooks))
      for iter134 in self.containingNotebooks:
        iter134.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.debugInfo is not None:
      oprot.writeFieldBegin('debugInfo', TType.STRING, 5)
      oprot.writeString(self.debugInfo)
      oprot.writeFieldEnd()
    if self.experts is not None:
      oprot.writeFieldBegin('experts', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.experts))
      for iter135 in self.experts:
        iter135.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.relatedContent is not None:
      oprot.writeFieldBegin('relatedContent', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.relatedContent))
      for iter136 in self.relatedContent:
        iter136.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.cacheKey is not None:
      oprot.writeFieldBegin('cacheKey', TType.STRING, 8)
      oprot.writeString(self.cacheKey)
      oprot.writeFieldEnd()
    if self.cacheExpires is not None:
      oprot.writeFieldBegin('cacheExpires', TType.I32, 9)
      oprot.writeI32(self.cacheExpires)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.notes)
    value = (value * 31) ^ hash(self.notebooks)
    value = (value * 31) ^ hash(self.tags)
    value = (value * 31) ^ hash(self.containingNotebooks)
    value = (value * 31) ^ hash(self.debugInfo)
    value = (value * 31) ^ hash(self.experts)
    value = (value * 31) ^ hash(self.relatedContent)
    value = (value * 31) ^ hash(self.cacheKey)
    value = (value * 31) ^ hash(self.cacheExpires)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RelatedResultSpec:
  """
  Attributes:
   - maxNotes
   - maxNotebooks
   - maxTags
   - writableNotebooksOnly
   - includeContainingNotebooks
   - includeDebugInfo
   - maxExperts
   - maxRelatedContent
   - relatedContentTypes
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'maxNotes', None, None, ), # 1
    (2, TType.I32, 'maxNotebooks', None, None, ), # 2
    (3, TType.I32, 'maxTags', None, None, ), # 3
    (4, TType.BOOL, 'writableNotebooksOnly', None, None, ), # 4
    (5, TType.BOOL, 'includeContainingNotebooks', None, None, ), # 5
    (6, TType.BOOL, 'includeDebugInfo', None, None, ), # 6
    (7, TType.I32, 'maxExperts', None, None, ), # 7
    (8, TType.I32, 'maxRelatedContent', None, None, ), # 8
    (9, TType.SET, 'relatedContentTypes', (TType.I32,None), None, ), # 9
  )

  def __init__(self, maxNotes=None, maxNotebooks=None, maxTags=None, writableNotebooksOnly=None, includeContainingNotebooks=None, includeDebugInfo=None, maxExperts=None, maxRelatedContent=None, relatedContentTypes=None,):
    self.maxNotes = maxNotes
    self.maxNotebooks = maxNotebooks
    self.maxTags = maxTags
    self.writableNotebooksOnly = writableNotebooksOnly
    self.includeContainingNotebooks = includeContainingNotebooks
    self.includeDebugInfo = includeDebugInfo
    self.maxExperts = maxExperts
    self.maxRelatedContent = maxRelatedContent
    self.relatedContentTypes = relatedContentTypes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.maxNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxNotebooks = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxTags = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.writableNotebooksOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.includeContainingNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.includeDebugInfo = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.maxExperts = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.maxRelatedContent = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.SET:
          self.relatedContentTypes = set()
          (_etype140, _size137) = iprot.readSetBegin()
          for _i141 in xrange(_size137):
            _elem142 = iprot.readI32();
            self.relatedContentTypes.add(_elem142)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RelatedResultSpec')
    if self.maxNotes is not None:
      oprot.writeFieldBegin('maxNotes', TType.I32, 1)
      oprot.writeI32(self.maxNotes)
      oprot.writeFieldEnd()
    if self.maxNotebooks is not None:
      oprot.writeFieldBegin('maxNotebooks', TType.I32, 2)
      oprot.writeI32(self.maxNotebooks)
      oprot.writeFieldEnd()
    if self.maxTags is not None:
      oprot.writeFieldBegin('maxTags', TType.I32, 3)
      oprot.writeI32(self.maxTags)
      oprot.writeFieldEnd()
    if self.writableNotebooksOnly is not None:
      oprot.writeFieldBegin('writableNotebooksOnly', TType.BOOL, 4)
      oprot.writeBool(self.writableNotebooksOnly)
      oprot.writeFieldEnd()
    if self.includeContainingNotebooks is not None:
      oprot.writeFieldBegin('includeContainingNotebooks', TType.BOOL, 5)
      oprot.writeBool(self.includeContainingNotebooks)
      oprot.writeFieldEnd()
    if self.includeDebugInfo is not None:
      oprot.writeFieldBegin('includeDebugInfo', TType.BOOL, 6)
      oprot.writeBool(self.includeDebugInfo)
      oprot.writeFieldEnd()
    if self.maxExperts is not None:
      oprot.writeFieldBegin('maxExperts', TType.I32, 7)
      oprot.writeI32(self.maxExperts)
      oprot.writeFieldEnd()
    if self.maxRelatedContent is not None:
      oprot.writeFieldBegin('maxRelatedContent', TType.I32, 8)
      oprot.writeI32(self.maxRelatedContent)
      oprot.writeFieldEnd()
    if self.relatedContentTypes is not None:
      oprot.writeFieldBegin('relatedContentTypes', TType.SET, 9)
      oprot.writeSetBegin(TType.I32, len(self.relatedContentTypes))
      for iter143 in self.relatedContentTypes:
        oprot.writeI32(iter143)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.maxNotes)
    value = (value * 31) ^ hash(self.maxNotebooks)
    value = (value * 31) ^ hash(self.maxTags)
    value = (value * 31) ^ hash(self.writableNotebooksOnly)
    value = (value * 31) ^ hash(self.includeContainingNotebooks)
    value = (value * 31) ^ hash(self.includeDebugInfo)
    value = (value * 31) ^ hash(self.maxExperts)
    value = (value * 31) ^ hash(self.maxRelatedContent)
    value = (value * 31) ^ hash(self.relatedContentTypes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdateNoteIfUsnMatchesResult:
  """
  Attributes:
   - note
   - updated
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'note', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'updated', None, None, ), # 2
  )

  def __init__(self, note=None, updated=None,):
    self.note = note
    self.updated = updated

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.note = evernote.edam.type.ttypes.Note()
          self.note.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.updated = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdateNoteIfUsnMatchesResult')
    if self.note is not None:
      oprot.writeFieldBegin('note', TType.STRUCT, 1)
      self.note.write(oprot)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.BOOL, 2)
      oprot.writeBool(self.updated)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.note)
    value = (value * 31) ^ hash(self.updated)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShareRelationshipRestrictions:
  """
  Attributes:
   - noSetReadOnly
   - noSetReadPlusActivity
   - noSetModify
   - noSetFullAccess
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'noSetReadOnly', None, None, ), # 1
    (2, TType.BOOL, 'noSetReadPlusActivity', None, None, ), # 2
    (3, TType.BOOL, 'noSetModify', None, None, ), # 3
    (4, TType.BOOL, 'noSetFullAccess', None, None, ), # 4
  )

  def __init__(self, noSetReadOnly=None, noSetReadPlusActivity=None, noSetModify=None, noSetFullAccess=None,):
    self.noSetReadOnly = noSetReadOnly
    self.noSetReadPlusActivity = noSetReadPlusActivity
    self.noSetModify = noSetModify
    self.noSetFullAccess = noSetFullAccess

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.noSetReadOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.noSetReadPlusActivity = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.noSetModify = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.noSetFullAccess = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShareRelationshipRestrictions')
    if self.noSetReadOnly is not None:
      oprot.writeFieldBegin('noSetReadOnly', TType.BOOL, 1)
      oprot.writeBool(self.noSetReadOnly)
      oprot.writeFieldEnd()
    if self.noSetReadPlusActivity is not None:
      oprot.writeFieldBegin('noSetReadPlusActivity', TType.BOOL, 2)
      oprot.writeBool(self.noSetReadPlusActivity)
      oprot.writeFieldEnd()
    if self.noSetModify is not None:
      oprot.writeFieldBegin('noSetModify', TType.BOOL, 3)
      oprot.writeBool(self.noSetModify)
      oprot.writeFieldEnd()
    if self.noSetFullAccess is not None:
      oprot.writeFieldBegin('noSetFullAccess', TType.BOOL, 4)
      oprot.writeBool(self.noSetFullAccess)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.noSetReadOnly)
    value = (value * 31) ^ hash(self.noSetReadPlusActivity)
    value = (value * 31) ^ hash(self.noSetModify)
    value = (value * 31) ^ hash(self.noSetFullAccess)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvitationShareRelationship:
  """
  Attributes:
   - displayName
   - recipientUserIdentity
   - privilege
   - allowPreview
   - sharerUserId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'displayName', None, None, ), # 1
    (2, TType.STRUCT, 'recipientUserIdentity', (evernote.edam.type.ttypes.UserIdentity, evernote.edam.type.ttypes.UserIdentity.thrift_spec), None, ), # 2
    (3, TType.I32, 'privilege', None, None, ), # 3
    (4, TType.BOOL, 'allowPreview', None, None, ), # 4
    (5, TType.I32, 'sharerUserId', None, None, ), # 5
  )

  def __init__(self, displayName=None, recipientUserIdentity=None, privilege=None, allowPreview=None, sharerUserId=None,):
    self.displayName = displayName
    self.recipientUserIdentity = recipientUserIdentity
    self.privilege = privilege
    self.allowPreview = allowPreview
    self.sharerUserId = sharerUserId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.displayName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.recipientUserIdentity = evernote.edam.type.ttypes.UserIdentity()
          self.recipientUserIdentity.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.allowPreview = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.sharerUserId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvitationShareRelationship')
    if self.displayName is not None:
      oprot.writeFieldBegin('displayName', TType.STRING, 1)
      oprot.writeString(self.displayName)
      oprot.writeFieldEnd()
    if self.recipientUserIdentity is not None:
      oprot.writeFieldBegin('recipientUserIdentity', TType.STRUCT, 2)
      self.recipientUserIdentity.write(oprot)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 3)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.allowPreview is not None:
      oprot.writeFieldBegin('allowPreview', TType.BOOL, 4)
      oprot.writeBool(self.allowPreview)
      oprot.writeFieldEnd()
    if self.sharerUserId is not None:
      oprot.writeFieldBegin('sharerUserId', TType.I32, 5)
      oprot.writeI32(self.sharerUserId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.displayName)
    value = (value * 31) ^ hash(self.recipientUserIdentity)
    value = (value * 31) ^ hash(self.privilege)
    value = (value * 31) ^ hash(self.allowPreview)
    value = (value * 31) ^ hash(self.sharerUserId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MemberShareRelationship:
  """
  Attributes:
   - displayName
   - recipientUserId
   - bestPrivilege
   - individualPrivilege
   - restrictions
   - sharerUserId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'displayName', None, None, ), # 1
    (2, TType.I32, 'recipientUserId', None, None, ), # 2
    (3, TType.I32, 'bestPrivilege', None, None, ), # 3
    (4, TType.I32, 'individualPrivilege', None, None, ), # 4
    (5, TType.STRUCT, 'restrictions', (ShareRelationshipRestrictions, ShareRelationshipRestrictions.thrift_spec), None, ), # 5
    (6, TType.I32, 'sharerUserId', None, None, ), # 6
  )

  def __init__(self, displayName=None, recipientUserId=None, bestPrivilege=None, individualPrivilege=None, restrictions=None, sharerUserId=None,):
    self.displayName = displayName
    self.recipientUserId = recipientUserId
    self.bestPrivilege = bestPrivilege
    self.individualPrivilege = individualPrivilege
    self.restrictions = restrictions
    self.sharerUserId = sharerUserId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.displayName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.recipientUserId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.bestPrivilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.individualPrivilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.restrictions = ShareRelationshipRestrictions()
          self.restrictions.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.sharerUserId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MemberShareRelationship')
    if self.displayName is not None:
      oprot.writeFieldBegin('displayName', TType.STRING, 1)
      oprot.writeString(self.displayName)
      oprot.writeFieldEnd()
    if self.recipientUserId is not None:
      oprot.writeFieldBegin('recipientUserId', TType.I32, 2)
      oprot.writeI32(self.recipientUserId)
      oprot.writeFieldEnd()
    if self.bestPrivilege is not None:
      oprot.writeFieldBegin('bestPrivilege', TType.I32, 3)
      oprot.writeI32(self.bestPrivilege)
      oprot.writeFieldEnd()
    if self.individualPrivilege is not None:
      oprot.writeFieldBegin('individualPrivilege', TType.I32, 4)
      oprot.writeI32(self.individualPrivilege)
      oprot.writeFieldEnd()
    if self.restrictions is not None:
      oprot.writeFieldBegin('restrictions', TType.STRUCT, 5)
      self.restrictions.write(oprot)
      oprot.writeFieldEnd()
    if self.sharerUserId is not None:
      oprot.writeFieldBegin('sharerUserId', TType.I32, 6)
      oprot.writeI32(self.sharerUserId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.displayName)
    value = (value * 31) ^ hash(self.recipientUserId)
    value = (value * 31) ^ hash(self.bestPrivilege)
    value = (value * 31) ^ hash(self.individualPrivilege)
    value = (value * 31) ^ hash(self.restrictions)
    value = (value * 31) ^ hash(self.sharerUserId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ShareRelationships:
  """
  Attributes:
   - invitations
   - memberships
   - invitationRestrictions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'invitations', (TType.STRUCT,(InvitationShareRelationship, InvitationShareRelationship.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'memberships', (TType.STRUCT,(MemberShareRelationship, MemberShareRelationship.thrift_spec)), None, ), # 2
    (3, TType.STRUCT, 'invitationRestrictions', (ShareRelationshipRestrictions, ShareRelationshipRestrictions.thrift_spec), None, ), # 3
  )

  def __init__(self, invitations=None, memberships=None, invitationRestrictions=None,):
    self.invitations = invitations
    self.memberships = memberships
    self.invitationRestrictions = invitationRestrictions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.invitations = []
          (_etype147, _size144) = iprot.readListBegin()
          for _i148 in xrange(_size144):
            _elem149 = InvitationShareRelationship()
            _elem149.read(iprot)
            self.invitations.append(_elem149)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.memberships = []
          (_etype153, _size150) = iprot.readListBegin()
          for _i154 in xrange(_size150):
            _elem155 = MemberShareRelationship()
            _elem155.read(iprot)
            self.memberships.append(_elem155)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.invitationRestrictions = ShareRelationshipRestrictions()
          self.invitationRestrictions.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShareRelationships')
    if self.invitations is not None:
      oprot.writeFieldBegin('invitations', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.invitations))
      for iter156 in self.invitations:
        iter156.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.memberships is not None:
      oprot.writeFieldBegin('memberships', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.memberships))
      for iter157 in self.memberships:
        iter157.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.invitationRestrictions is not None:
      oprot.writeFieldBegin('invitationRestrictions', TType.STRUCT, 3)
      self.invitationRestrictions.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.invitations)
    value = (value * 31) ^ hash(self.memberships)
    value = (value * 31) ^ hash(self.invitationRestrictions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ManageNotebookSharesParameters:
  """
  Attributes:
   - notebookGuid
   - inviteMessage
   - membershipsToUpdate
   - invitationsToCreateOrUpdate
   - unshares
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'notebookGuid', None, None, ), # 1
    (2, TType.STRING, 'inviteMessage', None, None, ), # 2
    (3, TType.LIST, 'membershipsToUpdate', (TType.STRUCT,(MemberShareRelationship, MemberShareRelationship.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'invitationsToCreateOrUpdate', (TType.STRUCT,(InvitationShareRelationship, InvitationShareRelationship.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'unshares', (TType.STRUCT,(evernote.edam.type.ttypes.UserIdentity, evernote.edam.type.ttypes.UserIdentity.thrift_spec)), None, ), # 5
  )

  def __init__(self, notebookGuid=None, inviteMessage=None, membershipsToUpdate=None, invitationsToCreateOrUpdate=None, unshares=None,):
    self.notebookGuid = notebookGuid
    self.inviteMessage = inviteMessage
    self.membershipsToUpdate = membershipsToUpdate
    self.invitationsToCreateOrUpdate = invitationsToCreateOrUpdate
    self.unshares = unshares

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.inviteMessage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.membershipsToUpdate = []
          (_etype161, _size158) = iprot.readListBegin()
          for _i162 in xrange(_size158):
            _elem163 = MemberShareRelationship()
            _elem163.read(iprot)
            self.membershipsToUpdate.append(_elem163)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.invitationsToCreateOrUpdate = []
          (_etype167, _size164) = iprot.readListBegin()
          for _i168 in xrange(_size164):
            _elem169 = InvitationShareRelationship()
            _elem169.read(iprot)
            self.invitationsToCreateOrUpdate.append(_elem169)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.unshares = []
          (_etype173, _size170) = iprot.readListBegin()
          for _i174 in xrange(_size170):
            _elem175 = evernote.edam.type.ttypes.UserIdentity()
            _elem175.read(iprot)
            self.unshares.append(_elem175)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ManageNotebookSharesParameters')
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 1)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.inviteMessage is not None:
      oprot.writeFieldBegin('inviteMessage', TType.STRING, 2)
      oprot.writeString(self.inviteMessage)
      oprot.writeFieldEnd()
    if self.membershipsToUpdate is not None:
      oprot.writeFieldBegin('membershipsToUpdate', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.membershipsToUpdate))
      for iter176 in self.membershipsToUpdate:
        iter176.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.invitationsToCreateOrUpdate is not None:
      oprot.writeFieldBegin('invitationsToCreateOrUpdate', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.invitationsToCreateOrUpdate))
      for iter177 in self.invitationsToCreateOrUpdate:
        iter177.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unshares is not None:
      oprot.writeFieldBegin('unshares', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.unshares))
      for iter178 in self.unshares:
        iter178.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.notebookGuid)
    value = (value * 31) ^ hash(self.inviteMessage)
    value = (value * 31) ^ hash(self.membershipsToUpdate)
    value = (value * 31) ^ hash(self.invitationsToCreateOrUpdate)
    value = (value * 31) ^ hash(self.unshares)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ManageNotebookSharesError:
  """
  Attributes:
   - userIdentity
   - userException
   - notFoundException
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userIdentity', (evernote.edam.type.ttypes.UserIdentity, evernote.edam.type.ttypes.UserIdentity.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, userIdentity=None, userException=None, notFoundException=None,):
    self.userIdentity = userIdentity
    self.userException = userException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userIdentity = evernote.edam.type.ttypes.UserIdentity()
          self.userIdentity.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ManageNotebookSharesError')
    if self.userIdentity is not None:
      oprot.writeFieldBegin('userIdentity', TType.STRUCT, 1)
      self.userIdentity.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 2)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.userIdentity)
    value = (value * 31) ^ hash(self.userException)
    value = (value * 31) ^ hash(self.notFoundException)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ManageNotebookSharesResult:
  """
  Attributes:
   - errors
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'errors', (TType.STRUCT,(ManageNotebookSharesError, ManageNotebookSharesError.thrift_spec)), None, ), # 1
  )

  def __init__(self, errors=None,):
    self.errors = errors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.errors = []
          (_etype182, _size179) = iprot.readListBegin()
          for _i183 in xrange(_size179):
            _elem184 = ManageNotebookSharesError()
            _elem184.read(iprot)
            self.errors.append(_elem184)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ManageNotebookSharesResult')
    if self.errors is not None:
      oprot.writeFieldBegin('errors', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.errors))
      for iter185 in self.errors:
        iter185.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.errors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SharedNoteTemplate:
  """
  Attributes:
   - noteGuid
   - recipientThreadId
   - recipientContacts
   - privilege
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'noteGuid', None, None, ), # 1
    (2, TType.LIST, 'recipientContacts', (TType.STRUCT,(evernote.edam.type.ttypes.Contact, evernote.edam.type.ttypes.Contact.thrift_spec)), None, ), # 2
    (3, TType.I32, 'privilege', None, None, ), # 3
    (4, TType.I64, 'recipientThreadId', None, None, ), # 4
  )

  def __init__(self, noteGuid=None, recipientThreadId=None, recipientContacts=None, privilege=None,):
    self.noteGuid = noteGuid
    self.recipientThreadId = recipientThreadId
    self.recipientContacts = recipientContacts
    self.privilege = privilege

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.recipientThreadId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.recipientContacts = []
          (_etype189, _size186) = iprot.readListBegin()
          for _i190 in xrange(_size186):
            _elem191 = evernote.edam.type.ttypes.Contact()
            _elem191.read(iprot)
            self.recipientContacts.append(_elem191)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SharedNoteTemplate')
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 1)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.recipientContacts is not None:
      oprot.writeFieldBegin('recipientContacts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.recipientContacts))
      for iter192 in self.recipientContacts:
        iter192.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 3)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.recipientThreadId is not None:
      oprot.writeFieldBegin('recipientThreadId', TType.I64, 4)
      oprot.writeI64(self.recipientThreadId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.noteGuid)
    value = (value * 31) ^ hash(self.recipientThreadId)
    value = (value * 31) ^ hash(self.recipientContacts)
    value = (value * 31) ^ hash(self.privilege)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotebookShareTemplate:
  """
  Attributes:
   - notebookGuid
   - recipientThreadId
   - recipientContacts
   - privilege
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'notebookGuid', None, None, ), # 1
    (2, TType.LIST, 'recipientContacts', (TType.STRUCT,(evernote.edam.type.ttypes.Contact, evernote.edam.type.ttypes.Contact.thrift_spec)), None, ), # 2
    (3, TType.I32, 'privilege', None, None, ), # 3
    (4, TType.I64, 'recipientThreadId', None, None, ), # 4
  )

  def __init__(self, notebookGuid=None, recipientThreadId=None, recipientContacts=None, privilege=None,):
    self.notebookGuid = notebookGuid
    self.recipientThreadId = recipientThreadId
    self.recipientContacts = recipientContacts
    self.privilege = privilege

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.recipientThreadId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.recipientContacts = []
          (_etype196, _size193) = iprot.readListBegin()
          for _i197 in xrange(_size193):
            _elem198 = evernote.edam.type.ttypes.Contact()
            _elem198.read(iprot)
            self.recipientContacts.append(_elem198)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotebookShareTemplate')
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 1)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.recipientContacts is not None:
      oprot.writeFieldBegin('recipientContacts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.recipientContacts))
      for iter199 in self.recipientContacts:
        iter199.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 3)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.recipientThreadId is not None:
      oprot.writeFieldBegin('recipientThreadId', TType.I64, 4)
      oprot.writeI64(self.recipientThreadId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.notebookGuid)
    value = (value * 31) ^ hash(self.recipientThreadId)
    value = (value * 31) ^ hash(self.recipientContacts)
    value = (value * 31) ^ hash(self.privilege)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateOrUpdateNotebookSharesResult:
  """
  Attributes:
   - updateSequenceNum
   - matchingShares
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'updateSequenceNum', None, None, ), # 1
    (2, TType.LIST, 'matchingShares', (TType.STRUCT,(evernote.edam.type.ttypes.SharedNotebook, evernote.edam.type.ttypes.SharedNotebook.thrift_spec)), None, ), # 2
  )

  def __init__(self, updateSequenceNum=None, matchingShares=None,):
    self.updateSequenceNum = updateSequenceNum
    self.matchingShares = matchingShares

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.matchingShares = []
          (_etype203, _size200) = iprot.readListBegin()
          for _i204 in xrange(_size200):
            _elem205 = evernote.edam.type.ttypes.SharedNotebook()
            _elem205.read(iprot)
            self.matchingShares.append(_elem205)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateOrUpdateNotebookSharesResult')
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 1)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.matchingShares is not None:
      oprot.writeFieldBegin('matchingShares', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.matchingShares))
      for iter206 in self.matchingShares:
        iter206.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.updateSequenceNum)
    value = (value * 31) ^ hash(self.matchingShares)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteShareRelationshipRestrictions:
  """
  Attributes:
   - noSetReadNote
   - noSetModifyNote
   - noSetFullAccess
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'noSetReadNote', None, None, ), # 1
    (2, TType.BOOL, 'noSetModifyNote', None, None, ), # 2
    (3, TType.BOOL, 'noSetFullAccess', None, None, ), # 3
  )

  def __init__(self, noSetReadNote=None, noSetModifyNote=None, noSetFullAccess=None,):
    self.noSetReadNote = noSetReadNote
    self.noSetModifyNote = noSetModifyNote
    self.noSetFullAccess = noSetFullAccess

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.noSetReadNote = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.noSetModifyNote = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.noSetFullAccess = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteShareRelationshipRestrictions')
    if self.noSetReadNote is not None:
      oprot.writeFieldBegin('noSetReadNote', TType.BOOL, 1)
      oprot.writeBool(self.noSetReadNote)
      oprot.writeFieldEnd()
    if self.noSetModifyNote is not None:
      oprot.writeFieldBegin('noSetModifyNote', TType.BOOL, 2)
      oprot.writeBool(self.noSetModifyNote)
      oprot.writeFieldEnd()
    if self.noSetFullAccess is not None:
      oprot.writeFieldBegin('noSetFullAccess', TType.BOOL, 3)
      oprot.writeBool(self.noSetFullAccess)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.noSetReadNote)
    value = (value * 31) ^ hash(self.noSetModifyNote)
    value = (value * 31) ^ hash(self.noSetFullAccess)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteMemberShareRelationship:
  """
  Attributes:
   - displayName
   - recipientUserId
   - privilege
   - restrictions
   - sharerUserId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'displayName', None, None, ), # 1
    (2, TType.I32, 'recipientUserId', None, None, ), # 2
    (3, TType.I32, 'privilege', None, None, ), # 3
    (4, TType.STRUCT, 'restrictions', (NoteShareRelationshipRestrictions, NoteShareRelationshipRestrictions.thrift_spec), None, ), # 4
    (5, TType.I32, 'sharerUserId', None, None, ), # 5
  )

  def __init__(self, displayName=None, recipientUserId=None, privilege=None, restrictions=None, sharerUserId=None,):
    self.displayName = displayName
    self.recipientUserId = recipientUserId
    self.privilege = privilege
    self.restrictions = restrictions
    self.sharerUserId = sharerUserId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.displayName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.recipientUserId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.restrictions = NoteShareRelationshipRestrictions()
          self.restrictions.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.sharerUserId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteMemberShareRelationship')
    if self.displayName is not None:
      oprot.writeFieldBegin('displayName', TType.STRING, 1)
      oprot.writeString(self.displayName)
      oprot.writeFieldEnd()
    if self.recipientUserId is not None:
      oprot.writeFieldBegin('recipientUserId', TType.I32, 2)
      oprot.writeI32(self.recipientUserId)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 3)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.restrictions is not None:
      oprot.writeFieldBegin('restrictions', TType.STRUCT, 4)
      self.restrictions.write(oprot)
      oprot.writeFieldEnd()
    if self.sharerUserId is not None:
      oprot.writeFieldBegin('sharerUserId', TType.I32, 5)
      oprot.writeI32(self.sharerUserId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.displayName)
    value = (value * 31) ^ hash(self.recipientUserId)
    value = (value * 31) ^ hash(self.privilege)
    value = (value * 31) ^ hash(self.restrictions)
    value = (value * 31) ^ hash(self.sharerUserId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteInvitationShareRelationship:
  """
  Attributes:
   - displayName
   - recipientIdentityId
   - privilege
   - sharerUserId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'displayName', None, None, ), # 1
    (2, TType.I64, 'recipientIdentityId', None, None, ), # 2
    (3, TType.I32, 'privilege', None, None, ), # 3
    None, # 4
    (5, TType.I32, 'sharerUserId', None, None, ), # 5
  )

  def __init__(self, displayName=None, recipientIdentityId=None, privilege=None, sharerUserId=None,):
    self.displayName = displayName
    self.recipientIdentityId = recipientIdentityId
    self.privilege = privilege
    self.sharerUserId = sharerUserId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.displayName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.recipientIdentityId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.sharerUserId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteInvitationShareRelationship')
    if self.displayName is not None:
      oprot.writeFieldBegin('displayName', TType.STRING, 1)
      oprot.writeString(self.displayName)
      oprot.writeFieldEnd()
    if self.recipientIdentityId is not None:
      oprot.writeFieldBegin('recipientIdentityId', TType.I64, 2)
      oprot.writeI64(self.recipientIdentityId)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 3)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.sharerUserId is not None:
      oprot.writeFieldBegin('sharerUserId', TType.I32, 5)
      oprot.writeI32(self.sharerUserId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.displayName)
    value = (value * 31) ^ hash(self.recipientIdentityId)
    value = (value * 31) ^ hash(self.privilege)
    value = (value * 31) ^ hash(self.sharerUserId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteShareRelationships:
  """
  Attributes:
   - invitations
   - memberships
   - invitationRestrictions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'invitations', (TType.STRUCT,(NoteInvitationShareRelationship, NoteInvitationShareRelationship.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'memberships', (TType.STRUCT,(NoteMemberShareRelationship, NoteMemberShareRelationship.thrift_spec)), None, ), # 2
    (3, TType.STRUCT, 'invitationRestrictions', (NoteShareRelationshipRestrictions, NoteShareRelationshipRestrictions.thrift_spec), None, ), # 3
  )

  def __init__(self, invitations=None, memberships=None, invitationRestrictions=None,):
    self.invitations = invitations
    self.memberships = memberships
    self.invitationRestrictions = invitationRestrictions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.invitations = []
          (_etype210, _size207) = iprot.readListBegin()
          for _i211 in xrange(_size207):
            _elem212 = NoteInvitationShareRelationship()
            _elem212.read(iprot)
            self.invitations.append(_elem212)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.memberships = []
          (_etype216, _size213) = iprot.readListBegin()
          for _i217 in xrange(_size213):
            _elem218 = NoteMemberShareRelationship()
            _elem218.read(iprot)
            self.memberships.append(_elem218)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.invitationRestrictions = NoteShareRelationshipRestrictions()
          self.invitationRestrictions.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteShareRelationships')
    if self.invitations is not None:
      oprot.writeFieldBegin('invitations', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.invitations))
      for iter219 in self.invitations:
        iter219.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.memberships is not None:
      oprot.writeFieldBegin('memberships', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.memberships))
      for iter220 in self.memberships:
        iter220.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.invitationRestrictions is not None:
      oprot.writeFieldBegin('invitationRestrictions', TType.STRUCT, 3)
      self.invitationRestrictions.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.invitations)
    value = (value * 31) ^ hash(self.memberships)
    value = (value * 31) ^ hash(self.invitationRestrictions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ManageNoteSharesParameters:
  """
  Attributes:
   - noteGuid
   - membershipsToUpdate
   - invitationsToUpdate
   - membershipsToUnshare
   - invitationsToUnshare
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'noteGuid', None, None, ), # 1
    (2, TType.LIST, 'membershipsToUpdate', (TType.STRUCT,(NoteMemberShareRelationship, NoteMemberShareRelationship.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'invitationsToUpdate', (TType.STRUCT,(NoteInvitationShareRelationship, NoteInvitationShareRelationship.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'membershipsToUnshare', (TType.I32,None), None, ), # 4
    (5, TType.LIST, 'invitationsToUnshare', (TType.I64,None), None, ), # 5
  )

  def __init__(self, noteGuid=None, membershipsToUpdate=None, invitationsToUpdate=None, membershipsToUnshare=None, invitationsToUnshare=None,):
    self.noteGuid = noteGuid
    self.membershipsToUpdate = membershipsToUpdate
    self.invitationsToUpdate = invitationsToUpdate
    self.membershipsToUnshare = membershipsToUnshare
    self.invitationsToUnshare = invitationsToUnshare

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.membershipsToUpdate = []
          (_etype224, _size221) = iprot.readListBegin()
          for _i225 in xrange(_size221):
            _elem226 = NoteMemberShareRelationship()
            _elem226.read(iprot)
            self.membershipsToUpdate.append(_elem226)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.invitationsToUpdate = []
          (_etype230, _size227) = iprot.readListBegin()
          for _i231 in xrange(_size227):
            _elem232 = NoteInvitationShareRelationship()
            _elem232.read(iprot)
            self.invitationsToUpdate.append(_elem232)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.membershipsToUnshare = []
          (_etype236, _size233) = iprot.readListBegin()
          for _i237 in xrange(_size233):
            _elem238 = iprot.readI32();
            self.membershipsToUnshare.append(_elem238)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.invitationsToUnshare = []
          (_etype242, _size239) = iprot.readListBegin()
          for _i243 in xrange(_size239):
            _elem244 = iprot.readI64();
            self.invitationsToUnshare.append(_elem244)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ManageNoteSharesParameters')
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 1)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.membershipsToUpdate is not None:
      oprot.writeFieldBegin('membershipsToUpdate', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.membershipsToUpdate))
      for iter245 in self.membershipsToUpdate:
        iter245.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.invitationsToUpdate is not None:
      oprot.writeFieldBegin('invitationsToUpdate', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.invitationsToUpdate))
      for iter246 in self.invitationsToUpdate:
        iter246.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.membershipsToUnshare is not None:
      oprot.writeFieldBegin('membershipsToUnshare', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.membershipsToUnshare))
      for iter247 in self.membershipsToUnshare:
        oprot.writeI32(iter247)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.invitationsToUnshare is not None:
      oprot.writeFieldBegin('invitationsToUnshare', TType.LIST, 5)
      oprot.writeListBegin(TType.I64, len(self.invitationsToUnshare))
      for iter248 in self.invitationsToUnshare:
        oprot.writeI64(iter248)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.noteGuid)
    value = (value * 31) ^ hash(self.membershipsToUpdate)
    value = (value * 31) ^ hash(self.invitationsToUpdate)
    value = (value * 31) ^ hash(self.membershipsToUnshare)
    value = (value * 31) ^ hash(self.invitationsToUnshare)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ManageNoteSharesError:
  """
  Attributes:
   - identityID
   - userID
   - userException
   - notFoundException
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'identityID', None, None, ), # 1
    (2, TType.I32, 'userID', None, None, ), # 2
    (3, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 4
  )

  def __init__(self, identityID=None, userID=None, userException=None, notFoundException=None,):
    self.identityID = identityID
    self.userID = userID
    self.userException = userException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.identityID = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.userID = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ManageNoteSharesError')
    if self.identityID is not None:
      oprot.writeFieldBegin('identityID', TType.I64, 1)
      oprot.writeI64(self.identityID)
      oprot.writeFieldEnd()
    if self.userID is not None:
      oprot.writeFieldBegin('userID', TType.I32, 2)
      oprot.writeI32(self.userID)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 3)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 4)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.identityID)
    value = (value * 31) ^ hash(self.userID)
    value = (value * 31) ^ hash(self.userException)
    value = (value * 31) ^ hash(self.notFoundException)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ManageNoteSharesResult:
  """
  Attributes:
   - errors
