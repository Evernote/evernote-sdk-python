#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    Service:  NoteStore
    <p>
    The NoteStore service is used by EDAM clients to exchange information
    about the collection of notes in an account. This is primarily used for
    synchronization, but could also be used by a "thin" client without a full
    local cache.
    </p><p>
    Most functions take an "authenticationToken" parameter, which is the
    value returned by the UserStore which permits access to the account.
    </p>

    Calls which require an authenticationToken may throw an EDAMUserException
    for the following reasons:
     <ul>
      <li>DATA_REQUIRED "authenticationToken" - token is empty</li>
      <li>BAD_DATA_FORMAT "authenticationToken" - token is malformed</li>
      <li>INVALID_AUTH "authenticationToken" - token signature is invalid</li>
      <li>AUTH_EXPIRED "authenticationToken" - token has expired or been revoked</li>
      <li>PERMISSION_DENIED "authenticationToken" - token does not grant permission
          to perform the requested action</li>
      <li>BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user is a member of a business
          that requires single sign-on, and must complete SSO before accessing business
          content.
    </ul>
    """
    def getSyncState(self, authenticationToken):
        """
        Asks the NoteStore to provide information about the status of the user
        account corresponding to the provided authentication token.

        Parameters:
         - authenticationToken
        """
        pass

    def getFilteredSyncChunk(self, authenticationToken, afterUSN, maxEntries, filter):
        """
        Asks the NoteStore to provide the state of the account in order of
        last modification.  This request retrieves one block of the server's
        state so that a client can make several small requests against a large
        account rather than getting the entire state in one big message.
        This call gives fine-grained control of the data that will
        be received by a client by omitting data elements that a client doesn't
        need. This may reduce network traffic and sync times.

        @param afterUSN
          The client can pass this value to ask only for objects that
          have been updated after a certain point.  This allows the client to
          receive updates after its last checkpoint rather than doing a full
          synchronization on every pass.  The default value of "0" indicates
          that the client wants to get objects from the start of the account.

        @param maxEntries
          The maximum number of modified objects that should be
          returned in the result SyncChunk.  This can be used to limit the size
          of each individual message to be friendly for network transfer.

        @param filter
          The caller must set some of the flags in this structure to specify which
          data types should be returned during the synchronization.  See
          the SyncChunkFilter structure for information on each flag.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "afterUSN" - if negative
          </li>
          <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - afterUSN
         - maxEntries
         - filter
        """
        pass

    def getLinkedNotebookSyncState(self, authenticationToken, linkedNotebook):
        """
        Asks the NoteStore to provide information about the status of a linked
        notebook that has been shared with the caller, or that is public to the
        world.
        This will return a result that is similar to getSyncState, but may omit
        SyncState.uploaded if the caller doesn't have permission to write to
        the linked notebook.

        This function must be called on the shard that owns the referenced
        notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
        same as LinkedNotebook.shardId.)

        @param authenticationToken
          This should be an authenticationToken for the guest who has received
          the invitation to the share.  (I.e. this should not be the result of
          NoteStore.authenticateToSharedNotebook)

        @param linkedNotebook
          This structure should contain identifying information and permissions
          to access the notebook in question.

        @throws EDAMUserException <ul>
          <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
              populated with the current username of the owner of the notebook for which
              you are obtaining sync state.
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
              correspond to a current user on the service.
          </li>
        </ul>

        @throws SystemException <ul>
          <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
              user whose account is on a shard other than that on which this method was
              invoked.
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - linkedNotebook
        """
        pass

    def getLinkedNotebookSyncChunk(self, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly):
        """
        Asks the NoteStore to provide information about the contents of a linked
        notebook that has been shared with the caller, or that is public to the
        world.
        This will return a result that is similar to getSyncChunk, but will only
        contain entries that are visible to the caller.  I.e. only that particular
        Notebook will be visible, along with its Notes, and Tags on those Notes.

        This function must be called on the shard that owns the referenced
        notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
        same as LinkedNotebook.shardId.)

        @param authenticationToken
          This should be an authenticationToken for the guest who has received
          the invitation to the share.  (I.e. this should not be the result of
          NoteStore.authenticateToSharedNotebook)

        @param linkedNotebook
          This structure should contain identifying information and permissions
          to access the notebook in question.  This must contain the valid fields
          for either a shared notebook (e.g. shareKey)
          or a public notebook (e.g. username, uri)

        @param afterUSN
          The client can pass this value to ask only for objects that
          have been updated after a certain point.  This allows the client to
          receive updates after its last checkpoint rather than doing a full
          synchronization on every pass.  The default value of "0" indicates
          that the client wants to get objects from the start of the account.

        @param maxEntries
          The maximum number of modified objects that should be
          returned in the result SyncChunk.  This can be used to limit the size
          of each individual message to be friendly for network transfer.
          Applications should not request more than 256 objects at a time,
          and must handle the case where the service returns less than the
          requested number of objects in a given request even though more
          objects are available on the service.

        @param fullSyncOnly
          If true, then the client only wants initial data for a full sync.
          In this case, the service will not return any expunged objects,
          and will not return any Resources, since these are also provided
          in their corresponding Notes.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "afterUSN" - if negative
          </li>
          <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "LinkedNotebook" - if the provided information doesn't match any
            valid notebook
          </li>
          <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
            valid notebook
          </li>
          <li> "SharedNotebook.id" - if the provided information indicates a
             shared notebook that no longer exists
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - linkedNotebook
         - afterUSN
         - maxEntries
         - fullSyncOnly
        """
        pass

    def listNotebooks(self, authenticationToken):
        """
        Returns a list of all of the notebooks in the account.

        Parameters:
         - authenticationToken
        """
        pass

    def listAccessibleBusinessNotebooks(self, authenticationToken):
        """
        Returns a list of all the notebooks in a business that the user has permission to access,
        regardless of whether the user has joined them. This includes notebooks that have been shared
        with the entire business as well as notebooks that have been shared directly with the user.

        @param authenticationToken A business authentication token obtained by calling
          UserStore.authenticateToBusiness.

        @throws EDAMUserException <ul>
          <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
            business auth token.</li>
        </ul>

        Parameters:
         - authenticationToken
        """
        pass

    def getNotebook(self, authenticationToken, guid):
        """
        Returns the current state of the notebook with the provided GUID.
        The notebook may be active or deleted (but not expunged).

        @param guid
          The GUID of the notebook to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - tag not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def getDefaultNotebook(self, authenticationToken):
        """
        Returns the notebook that should be used to store new notes in the
        user's account when no other notebooks are specified.

        Parameters:
         - authenticationToken
        """
        pass

    def createNotebook(self, authenticationToken, notebook):
        """
        Asks the service to make a notebook with the provided name.

        @param notebook
          The desired fields for the notebook must be provided on this
          object.  The name of the notebook must be set, and either the 'active'
          or 'defaultNotebook' fields may be set by the client at creation.
          If a notebook exists in the account with the same name (via
          case-insensitive compare), this will throw an EDAMUserException.

        @return
          The newly created Notebook.  The server-side GUID will be
          saved in this object's 'guid' field.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
          <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
          <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
          <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
          <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
          <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
          <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
          <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
          <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
               is set to 'true' for a Notebook that is not owned by the user identified by
               the passed authenticationToken.</li>
          <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
        </ul>

        Parameters:
         - authenticationToken
         - notebook
        """
        pass

    def updateNotebook(self, authenticationToken, notebook):
        """
        Submits notebook changes to the service.  The provided data must include
        the notebook's guid field for identification.

        @param notebook
          The notebook object containing the requested changes.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
          <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
          <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
          <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
          <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
          <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
          <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
          <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
          <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
               is set to 'true' for a Notebook that is not owned by the user identified by
               the passed authenticationToken.</li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - notebook
        """
        pass

    def expungeNotebook(self, authenticationToken, guid):
        """
        Permanently removes the notebook from the user's account.
        After this action, the notebook is no longer available for undeletion, etc.
        If the notebook contains any Notes, they will be moved to the current
        default notebook and moved into the trash (i.e. Note.active=false).
        <p/>
        NOTE: This function is generally not available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param guid
          The GUID of the notebook to delete.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
          </li>
          <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
          </li>
          <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def listTags(self, authenticationToken):
        """
        Returns a list of the tags in the account.  Evernote does not support
        the undeletion of tags, so this will only include active tags.

        Parameters:
         - authenticationToken
        """
        pass

    def listTagsByNotebook(self, authenticationToken, notebookGuid):
        """
        Returns a list of the tags that are applied to at least one note within
        the provided notebook.  If the notebook is public, the authenticationToken
        may be ignored.

        @param notebookGuid
           the GUID of the notebook to use to find tags

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - notebook not found by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - notebookGuid
        """
        pass

    def getTag(self, authenticationToken, guid):
        """
        Returns the current state of the Tag with the provided GUID.

        @param guid
          The GUID of the tag to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Tag.guid" - tag not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def createTag(self, authenticationToken, tag):
        """
        Asks the service to make a tag with a set of information.

        @param tag
          The desired list of fields for the tag are specified in this
          object.  The caller must specify the tag name, and may provide
          the parentGUID.

        @return
          The newly created Tag.  The server-side GUID will be
          saved in this object.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
          </li>
          <li> DATA_CONFLICT "Tag.name" - name already in use
          </li>
          <li> LIMIT_REACHED "Tag" - at max number of tags
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Tag.parentGuid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - tag
        """
        pass

    def updateTag(self, authenticationToken, tag):
        """
        Submits tag changes to the service.  The provided data must include
        the tag's guid field for identification.  The service will apply
        updates to the following tag fields:  name, parentGuid

        @param tag
          The tag object containing the requested changes.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
          </li>
          <li> DATA_CONFLICT "Tag.name" - name already in use
          </li>
          <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
          </li>
          <li> PERMISSION_DENIED "Tag" - user doesn't own tag
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Tag.guid" - tag not found, by GUID
          </li>
          <li> "Tag.parentGuid" - parent not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - tag
        """
        pass

    def untagAll(self, authenticationToken, guid):
        """
        Removes the provided tag from every note that is currently tagged with
        this tag.  If this operation is successful, the tag will still be in
        the account, but it will not be tagged on any notes.

        This function is not indended for use by full synchronizing clients, since
        it does not provide enough result information to the client to reconcile
        the local state without performing a follow-up sync from the service.  This
        is intended for "thin clients" that need to efficiently support this as
        a UI operation.

        @param guid
          The GUID of the tag to remove from all notes.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
          </li>
          <li> PERMISSION_DENIED "Tag" - user doesn't own tag
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Tag.guid" - tag not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def expungeTag(self, authenticationToken, guid):
        """
        Permanently deletes the tag with the provided GUID, if present.
        <p/>
        NOTE: This function is not generally available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param guid
          The GUID of the tag to delete.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
          </li>
          <li> PERMISSION_DENIED "Tag" - user doesn't own tag
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Tag.guid" - tag not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def listSearches(self, authenticationToken):
        """
        Returns a list of the searches in the account.  Evernote does not support
        the undeletion of searches, so this will only include active searches.

        Parameters:
         - authenticationToken
        """
        pass

    def getSearch(self, authenticationToken, guid):
        """
        Returns the current state of the search with the provided GUID.

        @param guid
          The GUID of the search to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
          </li>

        @throws EDAMNotFoundException <ul>
          <li> "SavedSearch.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def createSearch(self, authenticationToken, search):
        """
        Asks the service to make a saved search with a set of information.

        @param search
          The desired list of fields for the search are specified in this
          object. The caller must specify the name and query for the
          search, and may optionally specify a search scope.
          The SavedSearch.format field is ignored by the service.

        @return
          The newly created SavedSearch.  The server-side GUID will be
          saved in this object.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
          </li>
          <li> DATA_CONFLICT "SavedSearch.name" - name already in use
          </li>
          <li> LIMIT_REACHED "SavedSearch" - at max number of searches
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - search
        """
        pass

    def updateSearch(self, authenticationToken, search):
        """
        Submits search changes to the service. The provided data must include
        the search's guid field for identification. The service will apply
        updates to the following search fields: name, query, and scope.

        @param search
          The search object containing the requested changes.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
          </li>
          <li> DATA_CONFLICT "SavedSearch.name" - name already in use
          </li>
          <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "SavedSearch.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - search
        """
        pass

    def expungeSearch(self, authenticationToken, guid):
        """
        Permanently deletes the saved search with the provided GUID, if present.
        <p/>
        NOTE: This function is generally not available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param guid
          The GUID of the search to delete.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
          </li>
          <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "SavedSearch.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def findNoteOffset(self, authenticationToken, filter, guid):
        """
        Finds the position of a note within a sorted subset of all of the user's
        notes. This may be useful for thin clients that are displaying a paginated
        listing of a large account, which need to know where a particular note
        sits in the list without retrieving all notes first.

        @param authenticationToken
          Must be a valid token for the user's account unless the NoteFilter
          'notebookGuid' is the GUID of a public notebook.

        @param filter
          The list of criteria that will constrain the notes to be returned.

        @param guid
          The GUID of the note to be retrieved.

        @return
          If the note with the provided GUID is found within the matching note
          list, this will return the offset of that note within that list (where
          the first offset is 0).  If the note is not found within the set of
          notes, this will return -1.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
          </li>
          <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
          </li>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - not found, by GUID
          </li>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - filter
         - guid
        """
        pass

    def findNotesMetadata(self, authenticationToken, filter, offset, maxNotes, resultSpec):
        """
        Used to find the high-level information about a set of the notes from a
        user's account based on various criteria specified via a NoteFilter object.
        <p/>
        Web applications that wish to periodically check for new content in a user's
        Evernote account should consider using webhooks instead of polling this API.
        See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
        for more information.

        @param authenticationToken
          Must be a valid token for the user's account unless the NoteFilter
          'notebookGuid' is the GUID of a public notebook.

        @param filter
          The list of criteria that will constrain the notes to be returned.

        @param offset
          The numeric index of the first note to show within the sorted
          results.  The numbering scheme starts with "0".  This can be used for
          pagination.

        @param maxNotes
          The maximum notes to return in this query.  The service will return a set
          of notes that is no larger than this number, but may return fewer notes
          if needed.  The NoteList.totalNotes field in the return value will
          indicate whether there are more values available after the returned set.
          Currently, the service will not return more than 250 notes in a single request,
          but this number may change in the future.

        @param resultSpec
          This specifies which information should be returned for each matching
          Note. The fields on this structure can be used to eliminate data that
          the client doesn't need, which will reduce the time and bandwidth
          to receive and process the reply.

        @return
          The list of notes that match the criteria.
          The Notes.sharedNotes field will not be set.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
          </li>
          <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - filter
         - offset
         - maxNotes
         - resultSpec
        """
        pass

    def findNoteCounts(self, authenticationToken, filter, withTrash):
        """
        This function is used to determine how many notes are found for each
        notebook and tag in the user's account, given a current set of filter
        parameters that determine the current selection.  This function will
        return a structure that gives the note count for each notebook and tag
        that has at least one note under the requested filter.  Any notebook or
        tag that has zero notes in the filtered set will not be listed in the
        reply to this function (so they can be assumed to be 0).

        @param authenticationToken
          Must be a valid token for the user's account unless the NoteFilter
          'notebookGuid' is the GUID of a public notebook.

        @param filter
          The note selection filter that is currently being applied.  The note
          counts are to be calculated with this filter applied to the total set
          of notes in the user's account.

        @param withTrash
          If true, then the NoteCollectionCounts.trashCount will be calculated
          and supplied in the reply. Otherwise, the trash value will be omitted.

        @throws EDAMUserException <ul>
          <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
          <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
          <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - not found, by GUID</li>
        </ul>

        Parameters:
         - authenticationToken
         - filter
         - withTrash
        """
        pass

    def getNoteWithResultSpec(self, authenticationToken, guid, resultSpec):
        """
        Returns the current state of the note in the service with the provided
        GUID.  The ENML contents of the note will only be provided if the
        'withContent' parameter is true.  The service will include the meta-data
        for each resource in the note, but the binary contents of the resources
        and their recognition data will be omitted.
        If the Note is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).  The applicationData
        fields are returned as keysOnly.

        @param authenticationToken
          An authentication token that grants the caller access to the requested note.

        @param guid
          The GUID of the note to be retrieved.

        @param resultSpec
          A structure specifying the fields of the note that the caller would like to get.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
         - resultSpec
        """
        pass

    def getNote(self, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
        """
        DEPRECATED. See getNoteWithResultSpec.

        This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
        mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
        populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.

        Parameters:
         - authenticationToken
         - guid
         - withContent
         - withResourcesData
         - withResourcesRecognition
         - withResourcesAlternateData
        """
        pass

    def getNoteApplicationData(self, authenticationToken, guid):
        """
        Get all of the application data for the note identified by GUID,
        with values returned within the LazyMap fullMap field.
        If there are no applicationData entries, then a LazyMap
        with an empty fullMap will be returned. If your application
        only needs to fetch its own applicationData entry, use
        getNoteApplicationDataEntry instead.

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def getNoteApplicationDataEntry(self, authenticationToken, guid, key):
        """
        Get the value of a single entry in the applicationData map
        for the note identified by GUID.

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - note not found, by GUID</li>
          <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
         - key
        """
        pass

    def setNoteApplicationDataEntry(self, authenticationToken, guid, key, value):
        """
        Update, or create, an entry in the applicationData map for
        the note identified by guid.

        Parameters:
         - authenticationToken
         - guid
         - key
         - value
        """
        pass

    def unsetNoteApplicationDataEntry(self, authenticationToken, guid, key):
        """
        Remove an entry identified by 'key' from the applicationData map for
        the note identified by 'guid'. Silently ignores an unset of a
        non-existing key.

        Parameters:
         - authenticationToken
         - guid
         - key
        """
        pass

    def getNoteContent(self, authenticationToken, guid):
        """
        Returns XHTML contents of the note with the provided GUID.
        If the Note is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the note to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def getNoteSearchText(self, authenticationToken, guid, noteOnly, tokenizeForIndexing):
        """
        Returns a block of the extracted plain text contents of the note with the
        provided GUID.  This text can be indexed for search purposes by a light
        client that doesn't have capabilities to extract all of the searchable
        text content from the note and its resources.

        If the Note is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the note to be retrieved.

        @param noteOnly
          If true, this will only return the text extracted from the ENML contents
          of the note itself.  If false, this will also include the extracted text
          from any text-bearing resources (PDF, recognized images)

        @param tokenizeForIndexing
          If true, this will break the text into cleanly separated and sanitized
          tokens.  If false, this will return the more raw text extraction, with
          its original punctuation, capitalization, spacing, etc.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
         - noteOnly
         - tokenizeForIndexing
        """
        pass

    def getResourceSearchText(self, authenticationToken, guid):
        """
        Returns a block of the extracted plain text contents of the resource with
        the provided GUID.  This text can be indexed for search purposes by a light
        client that doesn't have capability to extract all of the searchable
        text content from a resource.

        If the Resource is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the resource to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def getNoteTagNames(self, authenticationToken, guid):
        """
        Returns a list of the names of the tags for the note with the provided
        guid.  This can be used with authentication to get the tags for a
        user's own note, or can be used without valid authentication to retrieve
        the names of the tags for a note in a public notebook.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def createNote(self, authenticationToken, note):
        """
        Asks the service to make a note with the provided set of information.

        @param note
          A Note object containing the desired fields to be populated on
          the service.

        @return
          The newly created Note from the service.  The server-side
          GUIDs for the Note and any Resources will be saved in this object.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
          </li>
          <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
          </li>
          <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
          </li>
          <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
          </li>
          <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
          </li>
          <li> DATA_REQUIRED "Resource.data" - resource data body missing
          </li>
          <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
          </li>
          <li> LIMIT_REACHED "Note" - at max number per account
          </li>
          <li> LIMIT_REACHED "Note.size" - total note size too large
          </li>
          <li> LIMIT_REACHED "Note.resources" - too many resources on Note
          </li>
          <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
          </li>
          <li> LIMIT_REACHED "Resource.data.size" - resource too large
          </li>
          <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
          </li>
          <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
          </li>
          <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
          </li>
          <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
          </li>
          <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
            of the specified tags had an invalid length or pattern
          </li>
          <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
            new tags would exceed the maximum number per account
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.notebookGuid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - note
        """
        pass

    def updateNote(self, authenticationToken, note):
        """
        Submit a set of changes to a note to the service.  The provided data
        must include the note's guid field for identification. The note's
        title must also be set.

        @param note
          A Note object containing the desired fields to be populated on
          the service. With the exception of the note's title and guid, fields
          that are not being changed do not need to be set. If the content is not
          being modified, note.content should be left unset. If the list of
          resources is not being modified, note.resources should be left unset.

        @return
          The metadata (no contents) for the Note on the server after the update.
          The Note.sharedNotes field will not be set.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
          </li>
          <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
          </li>
          <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
          </li>
          <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
          </li>
          <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
          </li>
          <li> DATA_REQUIRED "Resource.data" - resource data body missing
          </li>
          <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
          </li>
          <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
          </li>
          <li> LIMIT_REACHED "Note.resources" - too many resources on Note
          </li>
          <li> LIMIT_REACHED "Note.size" - total note size too large
          </li>
          <li> LIMIT_REACHED "Resource.data.size" - resource too large
          </li>
          <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
          </li>
          <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
          </li>
          <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
          <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
            modify the note's tags. note.tags must be unset.
          </li>
          <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
            to modify the note's attributes. note.attributes must be unset.
          </li>
          <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
          </li>
          <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
            of the specified tags had an invalid length or pattern
          </li>
          <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
            new tags would exceed the maximum number per account
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - note not found, by GUID
          </li>
          <li> "Note.notebookGuid" - if notebookGuid provided, but not found
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - note
        """
        pass

    def deleteNote(self, authenticationToken, guid):
        """
        Moves the note into the trash. The note may still be undeleted, unless it
        is expunged.  This is equivalent to calling updateNote() after setting
        Note.active = false

        @param guid
          The GUID of the note to delete.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> PERMISSION_DENIED "Note" - user doesn't have permission to
                 update the note.
          </li>
        </ul>

        @throws EDAMUserException <ul>
          <li> DATA_CONFLICT "Note.guid" - the note is already deleted
          </li>
        </ul>
        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def expungeNote(self, authenticationToken, guid):
        """
        Permanently removes a Note, and all of its Resources,
        from the service.
        <p/>
        NOTE: This function is not available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param guid
          The GUID of the note to delete.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> PERMISSION_DENIED "Note" - user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def copyNote(self, authenticationToken, noteGuid, toNotebookGuid):
        """
        Performs a deep copy of the Note with the provided GUID 'noteGuid' into
        the Notebook with the provided GUID 'toNotebookGuid'.
        The caller must be the owner of both the Note and the Notebook.
        This creates a new Note in the destination Notebook with new content and
        Resources that match all of the content and Resources from the original
        Note, but with new GUID identifiers.
        The original Note is not modified by this operation.
        The copied note is considered as an "upload" for the purpose of upload
        transfer limit calculation, so its size is added to the upload count for
        the owner.

        If the original note has been shared and has SharedNote records, the shares
        are NOT copied.

        @param noteGuid
          The GUID of the Note to copy.

        @param toNotebookGuid
          The GUID of the Notebook that should receive the new Note.

        @return
          The metadata for the new Note that was created.  This will include the
          new GUID for this Note (and any copied Resources), but will not include
          the content body or the binary bodies of any Resources.

        @throws EDAMUserException <ul>
          <li> LIMIT_REACHED "Note" - at max number per account
          </li>
          <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
          </li>
          <li> PERMISSION_DENIED "Note" - user doesn't own
          </li>
          <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - noteGuid
         - toNotebookGuid
        """
        pass

    def listNoteVersions(self, authenticationToken, noteGuid):
        """
        Returns a list of the prior versions of a particular note that are
        saved within the service.  These prior versions are stored to provide a
        recovery from unintentional removal of content from a note. The identifiers
        that are returned by this call can be used with getNoteVersion to retrieve
        the previous note.
        The identifiers will be listed from the most recent versions to the oldest.
        This call is only available for notes in Premium accounts. (I.e. access
        to past versions of Notes is a Premium-only feature.)

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
          </li>
          <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID.
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - noteGuid
        """
        pass

    def getNoteVersion(self, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
        """
        This can be used to retrieve a previous version of a Note after it has been
        updated within the service.  The caller must identify the note (via its
        guid) and the version (via the updateSequenceNumber of that version).
        to find a listing of the stored version USNs for a note, call
        listNoteVersions.
        This call is only available for notes in Premium accounts. (I.e. access
        to past versions of Notes is a Premium-only feature.)

        @param noteGuid
          The GUID of the note to be retrieved.

        @param updateSequenceNum
          The USN of the version of the note that is being retrieved

        @param withResourcesData
          If true, any Resource elements in this Note will include the binary
          contents of their 'data' field's body.

        @param withResourcesRecognition
          If true, any Resource elements will include the binary contents of the
          'recognition' field's body if recognition data is present.

        @param withResourcesAlternateData
          If true, any Resource elements in this Note will include the binary
          contents of their 'alternateData' fields' body, if an alternate form
          is present.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
          </li>
          <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID.
          </li>
          <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
             the corresponding USN.
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - noteGuid
         - updateSequenceNum
         - withResourcesData
         - withResourcesRecognition
         - withResourcesAlternateData
        """
        pass

    def getResource(self, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData):
        """
        Returns the current state of the resource in the service with the
        provided GUID.
        If the Resource is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).  Only the
        keys for the applicationData will be returned.

        @param guid
          The GUID of the resource to be retrieved.

        @param withData
          If true, the Resource will include the binary contents of the
          'data' field's body.

        @param withRecognition
          If true, the Resource will include the binary contents of the
          'recognition' field's body if recognition data is present.

        @param withAttributes
          If true, the Resource will include the attributes

        @param withAlternateData
          If true, the Resource will include the binary contents of the
          'alternateData' field's body, if an alternate form is present.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
         - withData
         - withRecognition
         - withAttributes
         - withAlternateData
        """
        pass

    def getResourceApplicationData(self, authenticationToken, guid):
        """
        Get all of the application data for the Resource identified by GUID,
        with values returned within the LazyMap fullMap field.
        If there are no applicationData entries, then a LazyMap
        with an empty fullMap will be returned. If your application
        only needs to fetch its own applicationData entry, use
        getResourceApplicationDataEntry instead.

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def getResourceApplicationDataEntry(self, authenticationToken, guid, key):
        """
        Get the value of a single entry in the applicationData map
        for the Resource identified by GUID.

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - Resource not found, by GUID</li>
          <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
         - key
        """
        pass

    def setResourceApplicationDataEntry(self, authenticationToken, guid, key, value):
        """
        Update, or create, an entry in the applicationData map for
        the Resource identified by guid.

        Parameters:
         - authenticationToken
         - guid
         - key
         - value
        """
        pass

    def unsetResourceApplicationDataEntry(self, authenticationToken, guid, key):
        """
        Remove an entry identified by 'key' from the applicationData map for
        the Resource identified by 'guid'.

        Parameters:
         - authenticationToken
         - guid
         - key
        """
        pass

    def updateResource(self, authenticationToken, resource):
        """
        Submit a set of changes to a resource to the service.  This can be used
        to update the meta-data about the resource, but cannot be used to change
        the binary contents of the resource (including the length and hash).  These
        cannot be changed directly without creating a new resource and removing the
        old one via updateNote.

        @param resource
          A Resource object containing the desired fields to be populated on
          the service.  The service will attempt to update the resource with the
          following fields from the client:
          <ul>
             <li>guid:  must be provided to identify the resource
             </li>
             <li>mime
             </li>
             <li>width
             </li>
             <li>height
             </li>
             <li>duration
             </li>
             <li>attributes:  optional.  if present, the set of attributes will
                  be replaced.
             </li>
          </ul>

        @return
          The Update Sequence Number of the resource after the changes have been
          applied.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
          </li>
          <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
          </li>
          <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - resource
        """
        pass

    def getResourceData(self, authenticationToken, guid):
        """
        Returns binary data of the resource with the provided GUID.  For
        example, if this were an image resource, this would contain the
        raw bits of the image.
        If the Resource is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the resource to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def getResourceByHash(self, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData):
        """
        Returns the current state of a resource, referenced by containing
        note GUID and resource content hash.

        @param noteGuid
          The GUID of the note that holds the resource to be retrieved.

        @param contentHash
          The MD5 checksum of the resource within that note. Note that
          this is the binary checksum, for example from Resource.data.bodyHash,
          and not the hex-encoded checksum that is used within an en-media
          tag in a note body.

        @param withData
          If true, the Resource will include the binary contents of the
          'data' field's body.

        @param withRecognition
          If true, the Resource will include the binary contents of the
          'recognition' field's body.

        @param withAlternateData
          If true, the Resource will include the binary contents of the
          'alternateData' field's body, if an alternate form is present.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
          </li>
          <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note" - not found, by guid
          </li>
          <li> "Resource" - not found, by hash
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - noteGuid
         - contentHash
         - withData
         - withRecognition
         - withAlternateData
        """
        pass

    def getResourceRecognition(self, authenticationToken, guid):
        """
        Returns the binary contents of the recognition index for the resource
        with the provided GUID.  If the caller asks about a resource that has
        no recognition data, this will throw EDAMNotFoundException.
        If the Resource is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the resource whose recognition data should be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
          <li> "Resource.recognition" - resource has no recognition
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def getResourceAlternateData(self, authenticationToken, guid):
        """
        If the Resource with the provided GUID has an alternate data representation
        (indicated via the Resource.alternateData field), then this request can
        be used to retrieve the binary contents of that alternate data file.
        If the caller asks about a resource that has no alternate data form, this
        will throw EDAMNotFoundException.

        @param guid
           The GUID of the resource whose recognition data should be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
          <li> "Resource.alternateData" - resource has no recognition
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def getResourceAttributes(self, authenticationToken, guid):
        """
        Returns the set of attributes for the Resource with the provided GUID.
        If the Resource is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the resource whose attributes should be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def getPublicNotebook(self, userId, publicUri):
        """
        <p>
        Looks for a user account with the provided userId on this NoteStore
        shard and determines whether that account contains a public notebook
        with the given URI.  If the account is not found, or no public notebook
        exists with this URI, this will throw an EDAMNotFoundException,
        otherwise this will return the information for that Notebook.
        </p>
        <p>
        If a notebook is visible on the web with a full URL like
        http://www.evernote.com/pub/sethdemo/api
        Then 'sethdemo' is the username that can be used to look up the userId,
        and 'api' is the publicUri.
        </p>

        @param userId
           The numeric identifier for the user who owns the public notebook.
           To find this value based on a username string, you can invoke
           UserStore.getPublicUserInfo

        @param publicUri
           The uri string for the public notebook, from Notebook.publishing.uri.

        @throws EDAMNotFoundException <ul>
          <li>"Publishing.uri" - not found, by URI</li>
        </ul>

        @throws EDAMSystemException <ul>
          <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
            taken down (for all requesters).</li>
          <li> TAKEN_DOWN "Country" - The specified public notebook is taken
            down for the requester because of an IP-based country lookup.</li>
        </ul>

        Parameters:
         - userId
         - publicUri
        """
        pass

    def shareNotebook(self, authenticationToken, sharedNotebook, message):
        """
        @Deprecated for first-party clients. See createOrUpdateNotebookShares.

        Share a notebook with an email address, and optionally to a specific
        recipient. If an existing SharedNotebook associated with
        sharedNotebook.notebookGuid is found by recipientUsername or email, then
        the values of sharedNotebook will be used to update the existing record,
        else a new record will be created.

        If recipientUsername is set and there is already a SharedNotebook
        for that Notebook with that recipientUsername and the privileges on the
        existing notebook are lower, than on this one, this will update the
        privileges and sharerUserId. If there isn't an existing SharedNotebook for
        recipientUsername, this will create and return a shared notebook for that
        email and recipientUsername. If recipientUsername is not set and there
        already is a SharedNotebook for a Notebook for that email address and the
        privileges on the existing SharedNotebook are lower than on this one, this
        will update the privileges and sharerUserId, and return the updated
        SharedNotebook. Otherwise, this will create and return a SharedNotebook for
        the email address.

        If the authenticationToken is a Business auth token, recipientUsername is
        set and the recipient is in the same business as the business auth token,
        this method will also auto-join the business user to the SharedNotebook -
        that is it will set serviceJoined on the SharedNotebook and create a
        LinkedNotebook on the recipient's account pointing to the SharedNotebook.
        The LinkedNotebook creation happens out-of-band, so there will be a delay
        on the order of half a minute between the SharedNotebook and LinkedNotebook
        creation.

        Also handles sending an email to the email addresses: if a SharedNotebook
        is being created, this will send the shared notebook invite email, and
        if a SharedNotebook already exists, it will send the shared notebook
        reminder email. Both these emails contain a link to join the notebook.
        If the notebook is being auto-joined, it sends an email with that
        information to the recipient.

        @param authenticationToken
          Must be an authentication token from the owner or a shared notebook
          authentication token or business authentication token with sufficient
          permissions to change invitations for a notebook.

        @param sharedNotebook
          A shared notebook object populated with the email address of the share
          recipient, the notebook guid and the access permissions. All other
          attributes of the shared object are ignored. The SharedNotebook.allowPreview
          field must be explicitly set with either a true or false value.

        @param message
          The sharer-defined message to put in the email sent out.

        @return
          The fully populated SharedNotebook object including the server assigned
          globalId which can both be used to uniquely identify the SharedNotebook.

        @throws EDAMUserException <ul>
          <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
          <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
              SharedNotebook.privilegeLevel was not set.</li>
          <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
              set. requireLogin is deprecated.</li>
          <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
              SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
          <li>PERMISSION_DENIED "emailConfirmation" - if the email address on the
              authenticationToken's owner's account is not confirmed.</li>
          <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
              recipientSettings is set in the sharedNotebook.  Only the recipient
              can set these values via the setSharedNotebookRecipientSettings
              method.</li>
          <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
              EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
          </ul>
        @throws EDAMNotFoundException <ul>
          <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
          </li>
          </ul>

        Parameters:
         - authenticationToken
         - sharedNotebook
         - message
        """
        pass

    def createOrUpdateNotebookShares(self, authenticationToken, shareTemplate):
        """
        Share a notebook by a messaging thread ID or a list of contacts. This function is
        intended to be used in conjunction with Evernote messaging, and as such does not
        notify the recipient that a notebook has been shared with them.

        Sharing with a subset of participants on a thread is accomplished by specifying both
        a thread ID and a list of contacts. This ensures that even if those contacts are
        on the thread under a deactivated identity, the correct user (the one who has the
        given contact on the thread) receives the share.

        @param authenticationToken
          An authentication token that grants the caller permission to share the notebook.
          This should be an owner token if the notebook is owned by the caller.
          If the notebook is a business notebook to which the caller has full access,
          this should be their business authentication token. If the notebook is a shared
          (non-business) notebook to which the caller has full access, this should be the
          shared notebook authentication token returned by NoteStore.authenticateToNotebook.

        @param shareTemplate
          Specifies the GUID of the notebook to be shared, the privilege at which the notebook
          should be shared, and the recipient information.

        @return
          A structure containing the USN of the Notebook after the change and a list of created
          or updated SharedNotebooks.

        @throws EDAMUserException <ul>
          <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
          <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
            valid GUID</li>
          <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
          <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
            specified</li>
          <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
            is not allowed.</li>
          <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
            specified, either by thread ID or as a list of contacts</li>
          <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
            number of shares</li>
        </ul>

        @throws EDAMInvalidContactsException <ul>
          <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
            in shareTemplate.recipients was not syntactically valid, or if attempting to
            share a notebook with an Evernote identity that the sharer does not have a
            connection to. The exception will specify which recipients were invalid.</li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
          <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
            specified, but no thread with that ID exists</li>
        </ul>

        Parameters:
         - authenticationToken
         - shareTemplate
        """
        pass

    def updateSharedNotebook(self, authenticationToken, sharedNotebook):
        """
        @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.

        Parameters:
         - authenticationToken
         - sharedNotebook
        """
        pass

    def setNotebookRecipientSettings(self, authenticationToken, notebookGuid, recipientSettings):
        """
        Set values for the recipient settings associated with a notebook share. Only the
        recipient of the share can update their recipient settings.

        If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
        you must leave that field unset in recipientSettings.
        This method will skip that field for updates and attempt to leave the existing value as
        it is.

        If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
        will be either left as null or converted to false (if currently true).

        @param authenticationToken The owner authentication token for the recipient of the share.

        @return The updated Notebook with the new recipient settings. Note that some of the
        recipient settings may differ from what was requested. Clients should update their state
        based on this return value.

        @throws EDAMNotFoundException <ul>
          <li>Notebook.guid - Thrown if the service does not have a notebook record with the
              notebookGuid on the given shard.</li>
          <li>Publishing.publishState - Thrown if the business notebook is not shared with the
              user and is also not published to their business.</li>
        </ul>

        @throws EDAMUserException <ul>
          <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
              allowed to set recipient settings on the specified notebook.</li>
          <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
              is allowed only for notebooks which belong to the same business as the user.</li>
          <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
              to false and any of reminder* settings to true.</li>
        </ul>

        Parameters:
         - authenticationToken
         - notebookGuid
         - recipientSettings
        """
        pass

    def listSharedNotebooks(self, authenticationToken):
        """
        Lists the collection of shared notebooks for all notebooks in the
        users account.

        @return
         The list of all SharedNotebooks for the user

        Parameters:
         - authenticationToken
        """
        pass

    def createLinkedNotebook(self, authenticationToken, linkedNotebook):
        """
        Asks the service to make a linked notebook with the provided name, username
        of the owner and identifiers provided. A linked notebook can be either a
        link to a public notebook or to a private shared notebook.

        @param linkedNotebook
          The desired fields for the linked notebook must be provided on this
          object.  The name of the linked notebook must be set. Either a username
          uri or a shard id and share key must be provided otherwise a
          EDAMUserException is thrown.

        @return
          The newly created LinkedNotebook.  The server-side id will be
          saved in this object's 'id' field.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
          <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
          </li>
          <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
          </li>
          <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
            if public notebook set but bad uri
          </li>
          <li> DATA_REQUIRED "LinkedNotebook.shardId" -
            if private notebook but shard id not provided
          </li>
          <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
          </li>
        </ul>

        @throws EDAMSystemException <ul>
          <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
            if a bad global identifer was set on a private notebook
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - linkedNotebook
        """
        pass

    def updateLinkedNotebook(self, authenticationToken, linkedNotebook):
        """
        @param linkedNotebook
          Updates the name of a linked notebook.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
          </li>
          <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
          </li>
          <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - linkedNotebook
        """
        pass

    def listLinkedNotebooks(self, authenticationToken):
        """
        Returns a list of linked notebooks

        Parameters:
         - authenticationToken
        """
        pass

    def expungeLinkedNotebook(self, authenticationToken, guid):
        """
        Permanently expunges the linked notebook from the account.
        <p/>
        NOTE: This function is generally not available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param guid
          The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
          from the account.

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def authenticateToSharedNotebook(self, shareKeyOrGlobalId, authenticationToken):
        """
        Asks the service to produce an authentication token that can be used to
        access the contents of a shared notebook from someone else's account.
        This authenticationToken can be used with the various other NoteStore
        calls to find and retrieve notes, and if the permissions in the shared
        notebook are sufficient, to make changes to the contents of the notebook.

        @param shareKeyOrGlobalId
          May be one of the following:
          <ul>
            <li>A share key for a shared notebook that was granted to some recipient
                Must be used if you are joining a notebook unless it was shared via
                createOrUpdateNotebookShares. Share keys are delivered out-of-band
                and are generally not available to clients. For security reasons,
                share keys may be invalidated at the discretion of the service.
            </li>
            <li>The shared notebook global identifier. May be used to access a
                notebook that is already joined.
            </li>
            <li>The Notebook GUID. May be used to access a notebook that was already
                joined, or to access a notebook that was shared with the recipient
                via createOrUpdateNotebookShares.
            </li>
          </ul>

        @param authenticationToken
          If a non-empty string is provided, this is the full user-based
          authentication token that identifies the user who is currently logged in
          and trying to access the shared notebook.
          If this string is empty, the service will attempt to authenticate to the
          shared notebook without any logged in user.

        @throws EDAMSystemException <ul>
          <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
          <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
        </ul>

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
                 no valid authentication token was provided.
          </li>
          <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
                 and another username has already been bound to this notebook.
          </li>
        </ul>

        Parameters:
         - shareKeyOrGlobalId
         - authenticationToken
        """
        pass

    def getSharedNotebookByAuth(self, authenticationToken):
        """
        This function is used to retrieve extended information about a shared
        notebook by a guest who has already authenticated to access that notebook.
        This requires an 'authenticationToken' parameter which should be the
        resut of a call to authenticateToSharedNotebook(...).
        I.e. this is the token that gives access to the particular shared notebook
        in someone else's account -- it's not the authenticationToken for the
        owner of the notebook itself.

        @param authenticationToken
          Should be the authentication token retrieved from the reply of
          authenticateToSharedNotebook(), proving access to a particular shared
          notebook.

        @throws EDAMUserException <ul>
          <li> PERMISSION_DENIED "authenticationToken" -
                 authentication token doesn't correspond to a valid shared notebook
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "SharedNotebook.id" - the shared notebook no longer exists
          </li>
        </ul>

        Parameters:
         - authenticationToken
        """
        pass

    def emailNote(self, authenticationToken, parameters):
        """
        Attempts to send a single note to one or more email recipients.
        <p/>
        NOTE: This function is generally not available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param authenticationToken
           The note will be sent as the user logged in via this token, using that
           user's registered email address.  If the authenticated user doesn't
           have permission to read that note, the emailing will fail.

        @param parameters
           The note must be specified either by GUID (in which case it will be
           sent using the existing data in the service), or else the full Note
           must be passed to this call.  This also specifies the additional
           email fields that will be used in the email.

        @throws EDAMUserException <ul>
          <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
            The email can't be sent because this would exceed the user's daily
            email limit.
          </li>
          <li> BAD_DATA_FORMAT "(email address)" -
            email address malformed
          </li>
          <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
            if there are no To: or Cc: addresses provided.
          </li>
          <li> DATA_REQUIRED "Note.title" -
            if the caller provides a Note parameter with no title
          </li>
          <li> DATA_REQUIRED "Note.content" -
            if the caller provides a Note parameter with no content
          </li>
          <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
          </li>
          <li> DATA_REQUIRED "NoteEmailParameters.note" -
            if no guid or note provided
          </li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - parameters
        """
        pass

    def shareNote(self, authenticationToken, guid):
        """
        If this note is not already shared publicly (via its own direct URL), then this
        will start sharing that note.
        This will return the secret "Note Key" for this note that
        can currently be used in conjunction with the Note's GUID to gain direct
        read-only access to the Note.
        If the note is already shared, then this won't make any changes to the
        note, and the existing "Note Key" will be returned.  The only way to change
        the Note Key for an existing note is to stopSharingNote first, and then
        call this function.

        @param guid
          The GUID of the note to be shared.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID</li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def stopSharingNote(self, authenticationToken, guid):
        """
        If this note is shared publicly then this will stop sharing that note
        and invalidate its "Note Key", so any existing URLs to access that Note
        will stop working.

        If the Note is not shared, then this function will do nothing.

        This function does not remove invididual shares for the note. To remove
        individual shares, see stopSharingNoteWithRecipients.

        @param guid
          The GUID of the note to be un-shared.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li>"Note.guid" - not found, by GUID</li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        pass

    def authenticateToSharedNote(self, guid, noteKey, authenticationToken):
        """
        Asks the service to produce an authentication token that can be used to
        access the contents of a single Note which was individually shared
        from someone's account.
        This authenticationToken can be used with the various other NoteStore
        calls to find and retrieve the Note and its directly-referenced children.

        @param guid
          The GUID identifying this Note on this shard.

        @param noteKey
          The 'noteKey' identifier from the Note that was originally created via
          a call to shareNote() and then given to a recipient to access.

        @param authenticationToken
          An optional authenticationToken that identifies the user accessing the
          shared note. This parameter may be required to access some shared notes.

        @throws EDAMUserException <ul>
          <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
            shared, or the noteKey doesn't match the current key for this note
          </li>
          <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
            required to access this Note, but either no authentication token or a
            "non-owner" authentication token was provided.
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "guid" - the note with that GUID is not found
          </li>
        </ul>

        @throws EDAMSystemException <ul>
          <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
            all requesters).
          </li>
          <li> TAKEN_DOWN "Country" - The specified shared note is taken down
            for the requester because of an IP-based country lookup.
          </ul>
        </ul>

        Parameters:
         - guid
         - noteKey
         - authenticationToken
        """
        pass

    def findRelated(self, authenticationToken, query, resultSpec):
        """
        Identify related entities on the service, such as notes,
        notebooks, tags and users in a business related to notes or content.

        @param query
          The information about which we are finding related entities.

        @param resultSpec
          Allows the client to indicate the type and quantity of
          information to be returned, allowing a saving of time and
          bandwidth.

        @return
          The result of the query, with information considered
          to likely be relevantly related to the information
          described by the query.

        @throws EDAMUserException <ul>
          <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
            a zero-length plain text value.
          </li>
          <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
            invalid Note GUID, that is, one that does not match the constraints
            defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
          </li>
          <li>PERMISSION_DENIED "Note" - If the caller does not have access to
            the note identified by RelatedQuery.noteGuid.
          </li>
          <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
            findExperts in the context of a non business user (i.e. The authenticationToken
            is not a business auth token).
          </li>
          <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
            in the result spec.
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li>"RelatedQuery.noteGuid" - the note with that GUID is not
            found, if that field has been set in the query.
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - query
         - resultSpec
        """
        pass

    def updateNoteIfUsnMatches(self, authenticationToken, note):
        """
        Perform the same operation as updateNote() would provided that the update
        sequence number on the parameter Note object matches the current update sequence
        number that the service has for the note.  If they do <i>not</i> match, then
        <i>no</i> update is performed and the return value will have the current server
        state in the note field and updated will be false.  If the update sequence
        numbers between the client and server do match, then the note will be updated
        and the note field of the return value will be returned as it would be for the
        updateNote method.  This method allows you to check for an update to the note
        on the service, by another client instance, from when you obtained the
        note state as a baseline for your edits and the time when you wish to save your
        edits.  If your client can merge the conflict, you can avoid overwriting changes
        that were saved to the service by the other client.

        See the updateNote method for information on the exceptions and parameters for
        this method.  The only difference is that you must have an update sequence number
        defined on the note parameter (equal to the USN of the note as synched to the
        client), and the following additional exceptions might be thrown.

        @throws EDAMUserException <ul>
          <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
              not provided.  This includes a value that is set as 0.</li>
          <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
              sequence number that is larger than the current server value, which should
              not happen if your client is working correctly.</li>
        </ul>

        Parameters:
         - authenticationToken
         - note
        """
        pass

    def manageNotebookShares(self, authenticationToken, parameters):
        """
        Manage invitations and memberships associated with a given notebook.

        <i>Note:</i> Beta method! This method is currently intended for
        limited use by Evernote clients that have discussed using this
        routine with the platform team.

        @param parameters A structure containing all parameters for the updates.
           See the structure documentation for details.

        @throws EDAMUserException <ul>
          <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
           notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
           shares.</li>
        </ul>

        Parameters:
         - authenticationToken
         - parameters
        """
        pass

    def getNotebookShares(self, authenticationToken, notebookGuid):
        """
        Return the share relationships for the given notebook, including
        both the invitations and the memberships.

        <i>Note:</i> Beta method! This method is currently intended for
        limited use by Evernote clients that have discussed using this
        routine with the platform team.

        Parameters:
         - authenticationToken
         - notebookGuid
        """
        pass


class Client(Iface):
    """
    Service:  NoteStore
    <p>
    The NoteStore service is used by EDAM clients to exchange information
    about the collection of notes in an account. This is primarily used for
    synchronization, but could also be used by a "thin" client without a full
    local cache.
    </p><p>
    Most functions take an "authenticationToken" parameter, which is the
    value returned by the UserStore which permits access to the account.
    </p>

    Calls which require an authenticationToken may throw an EDAMUserException
    for the following reasons:
     <ul>
      <li>DATA_REQUIRED "authenticationToken" - token is empty</li>
      <li>BAD_DATA_FORMAT "authenticationToken" - token is malformed</li>
      <li>INVALID_AUTH "authenticationToken" - token signature is invalid</li>
      <li>AUTH_EXPIRED "authenticationToken" - token has expired or been revoked</li>
      <li>PERMISSION_DENIED "authenticationToken" - token does not grant permission
          to perform the requested action</li>
      <li>BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user is a member of a business
          that requires single sign-on, and must complete SSO before accessing business
          content.
    </ul>
    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getSyncState(self, authenticationToken):
        """
        Asks the NoteStore to provide information about the status of the user
        account corresponding to the provided authentication token.

        Parameters:
         - authenticationToken
        """
        self.send_getSyncState(authenticationToken)
        return self.recv_getSyncState()

    def send_getSyncState(self, authenticationToken):
        self._oprot.writeMessageBegin('getSyncState', TMessageType.CALL, self._seqid)
        args = getSyncState_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSyncState(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSyncState_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSyncState failed: unknown result")

    def getFilteredSyncChunk(self, authenticationToken, afterUSN, maxEntries, filter):
        """
        Asks the NoteStore to provide the state of the account in order of
        last modification.  This request retrieves one block of the server's
        state so that a client can make several small requests against a large
        account rather than getting the entire state in one big message.
        This call gives fine-grained control of the data that will
        be received by a client by omitting data elements that a client doesn't
        need. This may reduce network traffic and sync times.

        @param afterUSN
          The client can pass this value to ask only for objects that
          have been updated after a certain point.  This allows the client to
          receive updates after its last checkpoint rather than doing a full
          synchronization on every pass.  The default value of "0" indicates
          that the client wants to get objects from the start of the account.

        @param maxEntries
          The maximum number of modified objects that should be
          returned in the result SyncChunk.  This can be used to limit the size
          of each individual message to be friendly for network transfer.

        @param filter
          The caller must set some of the flags in this structure to specify which
          data types should be returned during the synchronization.  See
          the SyncChunkFilter structure for information on each flag.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "afterUSN" - if negative
          </li>
          <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - afterUSN
         - maxEntries
         - filter
        """
        self.send_getFilteredSyncChunk(authenticationToken, afterUSN, maxEntries, filter)
        return self.recv_getFilteredSyncChunk()

    def send_getFilteredSyncChunk(self, authenticationToken, afterUSN, maxEntries, filter):
        self._oprot.writeMessageBegin('getFilteredSyncChunk', TMessageType.CALL, self._seqid)
        args = getFilteredSyncChunk_args()
        args.authenticationToken = authenticationToken
        args.afterUSN = afterUSN
        args.maxEntries = maxEntries
        args.filter = filter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFilteredSyncChunk(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFilteredSyncChunk_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFilteredSyncChunk failed: unknown result")

    def getLinkedNotebookSyncState(self, authenticationToken, linkedNotebook):
        """
        Asks the NoteStore to provide information about the status of a linked
        notebook that has been shared with the caller, or that is public to the
        world.
        This will return a result that is similar to getSyncState, but may omit
        SyncState.uploaded if the caller doesn't have permission to write to
        the linked notebook.

        This function must be called on the shard that owns the referenced
        notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
        same as LinkedNotebook.shardId.)

        @param authenticationToken
          This should be an authenticationToken for the guest who has received
          the invitation to the share.  (I.e. this should not be the result of
          NoteStore.authenticateToSharedNotebook)

        @param linkedNotebook
          This structure should contain identifying information and permissions
          to access the notebook in question.

        @throws EDAMUserException <ul>
          <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
              populated with the current username of the owner of the notebook for which
              you are obtaining sync state.
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
              correspond to a current user on the service.
          </li>
        </ul>

        @throws SystemException <ul>
          <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
              user whose account is on a shard other than that on which this method was
              invoked.
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - linkedNotebook
        """
        self.send_getLinkedNotebookSyncState(authenticationToken, linkedNotebook)
        return self.recv_getLinkedNotebookSyncState()

    def send_getLinkedNotebookSyncState(self, authenticationToken, linkedNotebook):
        self._oprot.writeMessageBegin('getLinkedNotebookSyncState', TMessageType.CALL, self._seqid)
        args = getLinkedNotebookSyncState_args()
        args.authenticationToken = authenticationToken
        args.linkedNotebook = linkedNotebook
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLinkedNotebookSyncState(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLinkedNotebookSyncState_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinkedNotebookSyncState failed: unknown result")

    def getLinkedNotebookSyncChunk(self, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly):
        """
        Asks the NoteStore to provide information about the contents of a linked
        notebook that has been shared with the caller, or that is public to the
        world.
        This will return a result that is similar to getSyncChunk, but will only
        contain entries that are visible to the caller.  I.e. only that particular
        Notebook will be visible, along with its Notes, and Tags on those Notes.

        This function must be called on the shard that owns the referenced
        notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
        same as LinkedNotebook.shardId.)

        @param authenticationToken
          This should be an authenticationToken for the guest who has received
          the invitation to the share.  (I.e. this should not be the result of
          NoteStore.authenticateToSharedNotebook)

        @param linkedNotebook
          This structure should contain identifying information and permissions
          to access the notebook in question.  This must contain the valid fields
          for either a shared notebook (e.g. shareKey)
          or a public notebook (e.g. username, uri)

        @param afterUSN
          The client can pass this value to ask only for objects that
          have been updated after a certain point.  This allows the client to
          receive updates after its last checkpoint rather than doing a full
          synchronization on every pass.  The default value of "0" indicates
          that the client wants to get objects from the start of the account.

        @param maxEntries
          The maximum number of modified objects that should be
          returned in the result SyncChunk.  This can be used to limit the size
          of each individual message to be friendly for network transfer.
          Applications should not request more than 256 objects at a time,
          and must handle the case where the service returns less than the
          requested number of objects in a given request even though more
          objects are available on the service.

        @param fullSyncOnly
          If true, then the client only wants initial data for a full sync.
          In this case, the service will not return any expunged objects,
          and will not return any Resources, since these are also provided
          in their corresponding Notes.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "afterUSN" - if negative
          </li>
          <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "LinkedNotebook" - if the provided information doesn't match any
            valid notebook
          </li>
          <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
            valid notebook
          </li>
          <li> "SharedNotebook.id" - if the provided information indicates a
             shared notebook that no longer exists
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - linkedNotebook
         - afterUSN
         - maxEntries
         - fullSyncOnly
        """
        self.send_getLinkedNotebookSyncChunk(authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly)
        return self.recv_getLinkedNotebookSyncChunk()

    def send_getLinkedNotebookSyncChunk(self, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly):
        self._oprot.writeMessageBegin('getLinkedNotebookSyncChunk', TMessageType.CALL, self._seqid)
        args = getLinkedNotebookSyncChunk_args()
        args.authenticationToken = authenticationToken
        args.linkedNotebook = linkedNotebook
        args.afterUSN = afterUSN
        args.maxEntries = maxEntries
        args.fullSyncOnly = fullSyncOnly
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLinkedNotebookSyncChunk(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLinkedNotebookSyncChunk_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinkedNotebookSyncChunk failed: unknown result")

    def listNotebooks(self, authenticationToken):
        """
        Returns a list of all of the notebooks in the account.

        Parameters:
         - authenticationToken
        """
        self.send_listNotebooks(authenticationToken)
        return self.recv_listNotebooks()

    def send_listNotebooks(self, authenticationToken):
        self._oprot.writeMessageBegin('listNotebooks', TMessageType.CALL, self._seqid)
        args = listNotebooks_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listNotebooks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listNotebooks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNotebooks failed: unknown result")

    def listAccessibleBusinessNotebooks(self, authenticationToken):
        """
        Returns a list of all the notebooks in a business that the user has permission to access,
        regardless of whether the user has joined them. This includes notebooks that have been shared
        with the entire business as well as notebooks that have been shared directly with the user.

        @param authenticationToken A business authentication token obtained by calling
          UserStore.authenticateToBusiness.

        @throws EDAMUserException <ul>
          <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
            business auth token.</li>
        </ul>

        Parameters:
         - authenticationToken
        """
        self.send_listAccessibleBusinessNotebooks(authenticationToken)
        return self.recv_listAccessibleBusinessNotebooks()

    def send_listAccessibleBusinessNotebooks(self, authenticationToken):
        self._oprot.writeMessageBegin('listAccessibleBusinessNotebooks', TMessageType.CALL, self._seqid)
        args = listAccessibleBusinessNotebooks_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listAccessibleBusinessNotebooks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listAccessibleBusinessNotebooks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listAccessibleBusinessNotebooks failed: unknown result")

    def getNotebook(self, authenticationToken, guid):
        """
        Returns the current state of the notebook with the provided GUID.
        The notebook may be active or deleted (but not expunged).

        @param guid
          The GUID of the notebook to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - tag not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getNotebook(authenticationToken, guid)
        return self.recv_getNotebook()

    def send_getNotebook(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getNotebook', TMessageType.CALL, self._seqid)
        args = getNotebook_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNotebook failed: unknown result")

    def getDefaultNotebook(self, authenticationToken):
        """
        Returns the notebook that should be used to store new notes in the
        user's account when no other notebooks are specified.

        Parameters:
         - authenticationToken
        """
        self.send_getDefaultNotebook(authenticationToken)
        return self.recv_getDefaultNotebook()

    def send_getDefaultNotebook(self, authenticationToken):
        self._oprot.writeMessageBegin('getDefaultNotebook', TMessageType.CALL, self._seqid)
        args = getDefaultNotebook_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDefaultNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDefaultNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDefaultNotebook failed: unknown result")

    def createNotebook(self, authenticationToken, notebook):
        """
        Asks the service to make a notebook with the provided name.

        @param notebook
          The desired fields for the notebook must be provided on this
          object.  The name of the notebook must be set, and either the 'active'
          or 'defaultNotebook' fields may be set by the client at creation.
          If a notebook exists in the account with the same name (via
          case-insensitive compare), this will throw an EDAMUserException.

        @return
          The newly created Notebook.  The server-side GUID will be
          saved in this object's 'guid' field.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
          <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
          <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
          <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
          <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
          <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
          <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
          <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
          <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
               is set to 'true' for a Notebook that is not owned by the user identified by
               the passed authenticationToken.</li>
          <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
        </ul>

        Parameters:
         - authenticationToken
         - notebook
        """
        self.send_createNotebook(authenticationToken, notebook)
        return self.recv_createNotebook()

    def send_createNotebook(self, authenticationToken, notebook):
        self._oprot.writeMessageBegin('createNotebook', TMessageType.CALL, self._seqid)
        args = createNotebook_args()
        args.authenticationToken = authenticationToken
        args.notebook = notebook
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createNotebook failed: unknown result")

    def updateNotebook(self, authenticationToken, notebook):
        """
        Submits notebook changes to the service.  The provided data must include
        the notebook's guid field for identification.

        @param notebook
          The notebook object containing the requested changes.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
          <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
          <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
          <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
          <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
          <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
          <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
          <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
          <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
               is set to 'true' for a Notebook that is not owned by the user identified by
               the passed authenticationToken.</li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - notebook
        """
        self.send_updateNotebook(authenticationToken, notebook)
        return self.recv_updateNotebook()

    def send_updateNotebook(self, authenticationToken, notebook):
        self._oprot.writeMessageBegin('updateNotebook', TMessageType.CALL, self._seqid)
        args = updateNotebook_args()
        args.authenticationToken = authenticationToken
        args.notebook = notebook
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateNotebook failed: unknown result")

    def expungeNotebook(self, authenticationToken, guid):
        """
        Permanently removes the notebook from the user's account.
        After this action, the notebook is no longer available for undeletion, etc.
        If the notebook contains any Notes, they will be moved to the current
        default notebook and moved into the trash (i.e. Note.active=false).
        <p/>
        NOTE: This function is generally not available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param guid
          The GUID of the notebook to delete.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
          </li>
          <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
          </li>
          <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_expungeNotebook(authenticationToken, guid)
        return self.recv_expungeNotebook()

    def send_expungeNotebook(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('expungeNotebook', TMessageType.CALL, self._seqid)
        args = expungeNotebook_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_expungeNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = expungeNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeNotebook failed: unknown result")

    def listTags(self, authenticationToken):
        """
        Returns a list of the tags in the account.  Evernote does not support
        the undeletion of tags, so this will only include active tags.

        Parameters:
         - authenticationToken
        """
        self.send_listTags(authenticationToken)
        return self.recv_listTags()

    def send_listTags(self, authenticationToken):
        self._oprot.writeMessageBegin('listTags', TMessageType.CALL, self._seqid)
        args = listTags_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listTags(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listTags_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listTags failed: unknown result")

    def listTagsByNotebook(self, authenticationToken, notebookGuid):
        """
        Returns a list of the tags that are applied to at least one note within
        the provided notebook.  If the notebook is public, the authenticationToken
        may be ignored.

        @param notebookGuid
           the GUID of the notebook to use to find tags

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - notebook not found by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - notebookGuid
        """
        self.send_listTagsByNotebook(authenticationToken, notebookGuid)
        return self.recv_listTagsByNotebook()

    def send_listTagsByNotebook(self, authenticationToken, notebookGuid):
        self._oprot.writeMessageBegin('listTagsByNotebook', TMessageType.CALL, self._seqid)
        args = listTagsByNotebook_args()
        args.authenticationToken = authenticationToken
        args.notebookGuid = notebookGuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listTagsByNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listTagsByNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listTagsByNotebook failed: unknown result")

    def getTag(self, authenticationToken, guid):
        """
        Returns the current state of the Tag with the provided GUID.

        @param guid
          The GUID of the tag to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Tag.guid" - tag not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getTag(authenticationToken, guid)
        return self.recv_getTag()

    def send_getTag(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getTag', TMessageType.CALL, self._seqid)
        args = getTag_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTag(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTag_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTag failed: unknown result")

    def createTag(self, authenticationToken, tag):
        """
        Asks the service to make a tag with a set of information.

        @param tag
          The desired list of fields for the tag are specified in this
          object.  The caller must specify the tag name, and may provide
          the parentGUID.

        @return
          The newly created Tag.  The server-side GUID will be
          saved in this object.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
          </li>
          <li> DATA_CONFLICT "Tag.name" - name already in use
          </li>
          <li> LIMIT_REACHED "Tag" - at max number of tags
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Tag.parentGuid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - tag
        """
        self.send_createTag(authenticationToken, tag)
        return self.recv_createTag()

    def send_createTag(self, authenticationToken, tag):
        self._oprot.writeMessageBegin('createTag', TMessageType.CALL, self._seqid)
        args = createTag_args()
        args.authenticationToken = authenticationToken
        args.tag = tag
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createTag(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createTag_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createTag failed: unknown result")

    def updateTag(self, authenticationToken, tag):
        """
        Submits tag changes to the service.  The provided data must include
        the tag's guid field for identification.  The service will apply
        updates to the following tag fields:  name, parentGuid

        @param tag
          The tag object containing the requested changes.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
          </li>
          <li> DATA_CONFLICT "Tag.name" - name already in use
          </li>
          <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
          </li>
          <li> PERMISSION_DENIED "Tag" - user doesn't own tag
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Tag.guid" - tag not found, by GUID
          </li>
          <li> "Tag.parentGuid" - parent not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - tag
        """
        self.send_updateTag(authenticationToken, tag)
        return self.recv_updateTag()

    def send_updateTag(self, authenticationToken, tag):
        self._oprot.writeMessageBegin('updateTag', TMessageType.CALL, self._seqid)
        args = updateTag_args()
        args.authenticationToken = authenticationToken
        args.tag = tag
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateTag(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateTag_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateTag failed: unknown result")

    def untagAll(self, authenticationToken, guid):
        """
        Removes the provided tag from every note that is currently tagged with
        this tag.  If this operation is successful, the tag will still be in
        the account, but it will not be tagged on any notes.

        This function is not indended for use by full synchronizing clients, since
        it does not provide enough result information to the client to reconcile
        the local state without performing a follow-up sync from the service.  This
        is intended for "thin clients" that need to efficiently support this as
        a UI operation.

        @param guid
          The GUID of the tag to remove from all notes.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
          </li>
          <li> PERMISSION_DENIED "Tag" - user doesn't own tag
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Tag.guid" - tag not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_untagAll(authenticationToken, guid)
        self.recv_untagAll()

    def send_untagAll(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('untagAll', TMessageType.CALL, self._seqid)
        args = untagAll_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_untagAll(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = untagAll_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        return

    def expungeTag(self, authenticationToken, guid):
        """
        Permanently deletes the tag with the provided GUID, if present.
        <p/>
        NOTE: This function is not generally available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param guid
          The GUID of the tag to delete.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
          </li>
          <li> PERMISSION_DENIED "Tag" - user doesn't own tag
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Tag.guid" - tag not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_expungeTag(authenticationToken, guid)
        return self.recv_expungeTag()

    def send_expungeTag(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('expungeTag', TMessageType.CALL, self._seqid)
        args = expungeTag_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_expungeTag(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = expungeTag_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeTag failed: unknown result")

    def listSearches(self, authenticationToken):
        """
        Returns a list of the searches in the account.  Evernote does not support
        the undeletion of searches, so this will only include active searches.

        Parameters:
         - authenticationToken
        """
        self.send_listSearches(authenticationToken)
        return self.recv_listSearches()

    def send_listSearches(self, authenticationToken):
        self._oprot.writeMessageBegin('listSearches', TMessageType.CALL, self._seqid)
        args = listSearches_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listSearches(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listSearches_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listSearches failed: unknown result")

    def getSearch(self, authenticationToken, guid):
        """
        Returns the current state of the search with the provided GUID.

        @param guid
          The GUID of the search to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
          </li>

        @throws EDAMNotFoundException <ul>
          <li> "SavedSearch.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getSearch(authenticationToken, guid)
        return self.recv_getSearch()

    def send_getSearch(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getSearch', TMessageType.CALL, self._seqid)
        args = getSearch_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSearch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSearch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSearch failed: unknown result")

    def createSearch(self, authenticationToken, search):
        """
        Asks the service to make a saved search with a set of information.

        @param search
          The desired list of fields for the search are specified in this
          object. The caller must specify the name and query for the
          search, and may optionally specify a search scope.
          The SavedSearch.format field is ignored by the service.

        @return
          The newly created SavedSearch.  The server-side GUID will be
          saved in this object.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
          </li>
          <li> DATA_CONFLICT "SavedSearch.name" - name already in use
          </li>
          <li> LIMIT_REACHED "SavedSearch" - at max number of searches
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - search
        """
        self.send_createSearch(authenticationToken, search)
        return self.recv_createSearch()

    def send_createSearch(self, authenticationToken, search):
        self._oprot.writeMessageBegin('createSearch', TMessageType.CALL, self._seqid)
        args = createSearch_args()
        args.authenticationToken = authenticationToken
        args.search = search
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createSearch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createSearch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createSearch failed: unknown result")

    def updateSearch(self, authenticationToken, search):
        """
        Submits search changes to the service. The provided data must include
        the search's guid field for identification. The service will apply
        updates to the following search fields: name, query, and scope.

        @param search
          The search object containing the requested changes.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
          </li>
          <li> DATA_CONFLICT "SavedSearch.name" - name already in use
          </li>
          <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "SavedSearch.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - search
        """
        self.send_updateSearch(authenticationToken, search)
        return self.recv_updateSearch()

    def send_updateSearch(self, authenticationToken, search):
        self._oprot.writeMessageBegin('updateSearch', TMessageType.CALL, self._seqid)
        args = updateSearch_args()
        args.authenticationToken = authenticationToken
        args.search = search
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateSearch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateSearch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateSearch failed: unknown result")

    def expungeSearch(self, authenticationToken, guid):
        """
        Permanently deletes the saved search with the provided GUID, if present.
        <p/>
        NOTE: This function is generally not available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param guid
          The GUID of the search to delete.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
          </li>
          <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "SavedSearch.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_expungeSearch(authenticationToken, guid)
        return self.recv_expungeSearch()

    def send_expungeSearch(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('expungeSearch', TMessageType.CALL, self._seqid)
        args = expungeSearch_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_expungeSearch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = expungeSearch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeSearch failed: unknown result")

    def findNoteOffset(self, authenticationToken, filter, guid):
        """
        Finds the position of a note within a sorted subset of all of the user's
        notes. This may be useful for thin clients that are displaying a paginated
        listing of a large account, which need to know where a particular note
        sits in the list without retrieving all notes first.

        @param authenticationToken
          Must be a valid token for the user's account unless the NoteFilter
          'notebookGuid' is the GUID of a public notebook.

        @param filter
          The list of criteria that will constrain the notes to be returned.

        @param guid
          The GUID of the note to be retrieved.

        @return
          If the note with the provided GUID is found within the matching note
          list, this will return the offset of that note within that list (where
          the first offset is 0).  If the note is not found within the set of
          notes, this will return -1.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
          </li>
          <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
          </li>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - not found, by GUID
          </li>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - filter
         - guid
        """
        self.send_findNoteOffset(authenticationToken, filter, guid)
        return self.recv_findNoteOffset()

    def send_findNoteOffset(self, authenticationToken, filter, guid):
        self._oprot.writeMessageBegin('findNoteOffset', TMessageType.CALL, self._seqid)
        args = findNoteOffset_args()
        args.authenticationToken = authenticationToken
        args.filter = filter
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findNoteOffset(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findNoteOffset_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findNoteOffset failed: unknown result")

    def findNotesMetadata(self, authenticationToken, filter, offset, maxNotes, resultSpec):
        """
        Used to find the high-level information about a set of the notes from a
        user's account based on various criteria specified via a NoteFilter object.
        <p/>
        Web applications that wish to periodically check for new content in a user's
        Evernote account should consider using webhooks instead of polling this API.
        See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
        for more information.

        @param authenticationToken
          Must be a valid token for the user's account unless the NoteFilter
          'notebookGuid' is the GUID of a public notebook.

        @param filter
          The list of criteria that will constrain the notes to be returned.

        @param offset
          The numeric index of the first note to show within the sorted
          results.  The numbering scheme starts with "0".  This can be used for
          pagination.

        @param maxNotes
          The maximum notes to return in this query.  The service will return a set
          of notes that is no larger than this number, but may return fewer notes
          if needed.  The NoteList.totalNotes field in the return value will
          indicate whether there are more values available after the returned set.
          Currently, the service will not return more than 250 notes in a single request,
          but this number may change in the future.

        @param resultSpec
          This specifies which information should be returned for each matching
          Note. The fields on this structure can be used to eliminate data that
          the client doesn't need, which will reduce the time and bandwidth
          to receive and process the reply.

        @return
          The list of notes that match the criteria.
          The Notes.sharedNotes field will not be set.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
          </li>
          <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - filter
         - offset
         - maxNotes
         - resultSpec
        """
        self.send_findNotesMetadata(authenticationToken, filter, offset, maxNotes, resultSpec)
        return self.recv_findNotesMetadata()

    def send_findNotesMetadata(self, authenticationToken, filter, offset, maxNotes, resultSpec):
        self._oprot.writeMessageBegin('findNotesMetadata', TMessageType.CALL, self._seqid)
        args = findNotesMetadata_args()
        args.authenticationToken = authenticationToken
        args.filter = filter
        args.offset = offset
        args.maxNotes = maxNotes
        args.resultSpec = resultSpec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findNotesMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findNotesMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findNotesMetadata failed: unknown result")

    def findNoteCounts(self, authenticationToken, filter, withTrash):
        """
        This function is used to determine how many notes are found for each
        notebook and tag in the user's account, given a current set of filter
        parameters that determine the current selection.  This function will
        return a structure that gives the note count for each notebook and tag
        that has at least one note under the requested filter.  Any notebook or
        tag that has zero notes in the filtered set will not be listed in the
        reply to this function (so they can be assumed to be 0).

        @param authenticationToken
          Must be a valid token for the user's account unless the NoteFilter
          'notebookGuid' is the GUID of a public notebook.

        @param filter
          The note selection filter that is currently being applied.  The note
          counts are to be calculated with this filter applied to the total set
          of notes in the user's account.

        @param withTrash
          If true, then the NoteCollectionCounts.trashCount will be calculated
          and supplied in the reply. Otherwise, the trash value will be omitted.

        @throws EDAMUserException <ul>
          <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
          <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
          <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - not found, by GUID</li>
        </ul>

        Parameters:
         - authenticationToken
         - filter
         - withTrash
        """
        self.send_findNoteCounts(authenticationToken, filter, withTrash)
        return self.recv_findNoteCounts()

    def send_findNoteCounts(self, authenticationToken, filter, withTrash):
        self._oprot.writeMessageBegin('findNoteCounts', TMessageType.CALL, self._seqid)
        args = findNoteCounts_args()
        args.authenticationToken = authenticationToken
        args.filter = filter
        args.withTrash = withTrash
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findNoteCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findNoteCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findNoteCounts failed: unknown result")

    def getNoteWithResultSpec(self, authenticationToken, guid, resultSpec):
        """
        Returns the current state of the note in the service with the provided
        GUID.  The ENML contents of the note will only be provided if the
        'withContent' parameter is true.  The service will include the meta-data
        for each resource in the note, but the binary contents of the resources
        and their recognition data will be omitted.
        If the Note is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).  The applicationData
        fields are returned as keysOnly.

        @param authenticationToken
          An authentication token that grants the caller access to the requested note.

        @param guid
          The GUID of the note to be retrieved.

        @param resultSpec
          A structure specifying the fields of the note that the caller would like to get.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
         - resultSpec
        """
        self.send_getNoteWithResultSpec(authenticationToken, guid, resultSpec)
        return self.recv_getNoteWithResultSpec()

    def send_getNoteWithResultSpec(self, authenticationToken, guid, resultSpec):
        self._oprot.writeMessageBegin('getNoteWithResultSpec', TMessageType.CALL, self._seqid)
        args = getNoteWithResultSpec_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.resultSpec = resultSpec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNoteWithResultSpec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNoteWithResultSpec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteWithResultSpec failed: unknown result")

    def getNote(self, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
        """
        DEPRECATED. See getNoteWithResultSpec.

        This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
        mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
        populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.

        Parameters:
         - authenticationToken
         - guid
         - withContent
         - withResourcesData
         - withResourcesRecognition
         - withResourcesAlternateData
        """
        self.send_getNote(authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData)
        return self.recv_getNote()

    def send_getNote(self, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
        self._oprot.writeMessageBegin('getNote', TMessageType.CALL, self._seqid)
        args = getNote_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.withContent = withContent
        args.withResourcesData = withResourcesData
        args.withResourcesRecognition = withResourcesRecognition
        args.withResourcesAlternateData = withResourcesAlternateData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNote(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNote_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNote failed: unknown result")

    def getNoteApplicationData(self, authenticationToken, guid):
        """
        Get all of the application data for the note identified by GUID,
        with values returned within the LazyMap fullMap field.
        If there are no applicationData entries, then a LazyMap
        with an empty fullMap will be returned. If your application
        only needs to fetch its own applicationData entry, use
        getNoteApplicationDataEntry instead.

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getNoteApplicationData(authenticationToken, guid)
        return self.recv_getNoteApplicationData()

    def send_getNoteApplicationData(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getNoteApplicationData', TMessageType.CALL, self._seqid)
        args = getNoteApplicationData_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNoteApplicationData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNoteApplicationData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteApplicationData failed: unknown result")

    def getNoteApplicationDataEntry(self, authenticationToken, guid, key):
        """
        Get the value of a single entry in the applicationData map
        for the note identified by GUID.

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - note not found, by GUID</li>
          <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
         - key
        """
        self.send_getNoteApplicationDataEntry(authenticationToken, guid, key)
        return self.recv_getNoteApplicationDataEntry()

    def send_getNoteApplicationDataEntry(self, authenticationToken, guid, key):
        self._oprot.writeMessageBegin('getNoteApplicationDataEntry', TMessageType.CALL, self._seqid)
        args = getNoteApplicationDataEntry_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNoteApplicationDataEntry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNoteApplicationDataEntry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteApplicationDataEntry failed: unknown result")

    def setNoteApplicationDataEntry(self, authenticationToken, guid, key, value):
        """
        Update, or create, an entry in the applicationData map for
        the note identified by guid.

        Parameters:
         - authenticationToken
         - guid
         - key
         - value
        """
        self.send_setNoteApplicationDataEntry(authenticationToken, guid, key, value)
        return self.recv_setNoteApplicationDataEntry()

    def send_setNoteApplicationDataEntry(self, authenticationToken, guid, key, value):
        self._oprot.writeMessageBegin('setNoteApplicationDataEntry', TMessageType.CALL, self._seqid)
        args = setNoteApplicationDataEntry_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setNoteApplicationDataEntry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setNoteApplicationDataEntry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setNoteApplicationDataEntry failed: unknown result")

    def unsetNoteApplicationDataEntry(self, authenticationToken, guid, key):
        """
        Remove an entry identified by 'key' from the applicationData map for
        the note identified by 'guid'. Silently ignores an unset of a
        non-existing key.

        Parameters:
         - authenticationToken
         - guid
         - key
        """
        self.send_unsetNoteApplicationDataEntry(authenticationToken, guid, key)
        return self.recv_unsetNoteApplicationDataEntry()

    def send_unsetNoteApplicationDataEntry(self, authenticationToken, guid, key):
        self._oprot.writeMessageBegin('unsetNoteApplicationDataEntry', TMessageType.CALL, self._seqid)
        args = unsetNoteApplicationDataEntry_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unsetNoteApplicationDataEntry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unsetNoteApplicationDataEntry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "unsetNoteApplicationDataEntry failed: unknown result")

    def getNoteContent(self, authenticationToken, guid):
        """
        Returns XHTML contents of the note with the provided GUID.
        If the Note is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the note to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getNoteContent(authenticationToken, guid)
        return self.recv_getNoteContent()

    def send_getNoteContent(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getNoteContent', TMessageType.CALL, self._seqid)
        args = getNoteContent_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNoteContent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNoteContent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteContent failed: unknown result")

    def getNoteSearchText(self, authenticationToken, guid, noteOnly, tokenizeForIndexing):
        """
        Returns a block of the extracted plain text contents of the note with the
        provided GUID.  This text can be indexed for search purposes by a light
        client that doesn't have capabilities to extract all of the searchable
        text content from the note and its resources.

        If the Note is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the note to be retrieved.

        @param noteOnly
          If true, this will only return the text extracted from the ENML contents
          of the note itself.  If false, this will also include the extracted text
          from any text-bearing resources (PDF, recognized images)

        @param tokenizeForIndexing
          If true, this will break the text into cleanly separated and sanitized
          tokens.  If false, this will return the more raw text extraction, with
          its original punctuation, capitalization, spacing, etc.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
         - noteOnly
         - tokenizeForIndexing
        """
        self.send_getNoteSearchText(authenticationToken, guid, noteOnly, tokenizeForIndexing)
        return self.recv_getNoteSearchText()

    def send_getNoteSearchText(self, authenticationToken, guid, noteOnly, tokenizeForIndexing):
        self._oprot.writeMessageBegin('getNoteSearchText', TMessageType.CALL, self._seqid)
        args = getNoteSearchText_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.noteOnly = noteOnly
        args.tokenizeForIndexing = tokenizeForIndexing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNoteSearchText(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNoteSearchText_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteSearchText failed: unknown result")

    def getResourceSearchText(self, authenticationToken, guid):
        """
        Returns a block of the extracted plain text contents of the resource with
        the provided GUID.  This text can be indexed for search purposes by a light
        client that doesn't have capability to extract all of the searchable
        text content from a resource.

        If the Resource is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the resource to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getResourceSearchText(authenticationToken, guid)
        return self.recv_getResourceSearchText()

    def send_getResourceSearchText(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getResourceSearchText', TMessageType.CALL, self._seqid)
        args = getResourceSearchText_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getResourceSearchText(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getResourceSearchText_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceSearchText failed: unknown result")

    def getNoteTagNames(self, authenticationToken, guid):
        """
        Returns a list of the names of the tags for the note with the provided
        guid.  This can be used with authentication to get the tags for a
        user's own note, or can be used without valid authentication to retrieve
        the names of the tags for a note in a public notebook.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getNoteTagNames(authenticationToken, guid)
        return self.recv_getNoteTagNames()

    def send_getNoteTagNames(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getNoteTagNames', TMessageType.CALL, self._seqid)
        args = getNoteTagNames_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNoteTagNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNoteTagNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteTagNames failed: unknown result")

    def createNote(self, authenticationToken, note):
        """
        Asks the service to make a note with the provided set of information.

        @param note
          A Note object containing the desired fields to be populated on
          the service.

        @return
          The newly created Note from the service.  The server-side
          GUIDs for the Note and any Resources will be saved in this object.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
          </li>
          <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
          </li>
          <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
          </li>
          <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
          </li>
          <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
          </li>
          <li> DATA_REQUIRED "Resource.data" - resource data body missing
          </li>
          <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
          </li>
          <li> LIMIT_REACHED "Note" - at max number per account
          </li>
          <li> LIMIT_REACHED "Note.size" - total note size too large
          </li>
          <li> LIMIT_REACHED "Note.resources" - too many resources on Note
          </li>
          <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
          </li>
          <li> LIMIT_REACHED "Resource.data.size" - resource too large
          </li>
          <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
          </li>
          <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
          </li>
          <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
          </li>
          <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
          </li>
          <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
            of the specified tags had an invalid length or pattern
          </li>
          <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
            new tags would exceed the maximum number per account
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.notebookGuid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - note
        """
        self.send_createNote(authenticationToken, note)
        return self.recv_createNote()

    def send_createNote(self, authenticationToken, note):
        self._oprot.writeMessageBegin('createNote', TMessageType.CALL, self._seqid)
        args = createNote_args()
        args.authenticationToken = authenticationToken
        args.note = note
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createNote(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createNote_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createNote failed: unknown result")

    def updateNote(self, authenticationToken, note):
        """
        Submit a set of changes to a note to the service.  The provided data
        must include the note's guid field for identification. The note's
        title must also be set.

        @param note
          A Note object containing the desired fields to be populated on
          the service. With the exception of the note's title and guid, fields
          that are not being changed do not need to be set. If the content is not
          being modified, note.content should be left unset. If the list of
          resources is not being modified, note.resources should be left unset.

        @return
          The metadata (no contents) for the Note on the server after the update.
          The Note.sharedNotes field will not be set.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
          </li>
          <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
          </li>
          <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
          </li>
          <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
          </li>
          <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
          </li>
          <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
          </li>
          <li> DATA_REQUIRED "Resource.data" - resource data body missing
          </li>
          <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
          </li>
          <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
          </li>
          <li> LIMIT_REACHED "Note.resources" - too many resources on Note
          </li>
          <li> LIMIT_REACHED "Note.size" - total note size too large
          </li>
          <li> LIMIT_REACHED "Resource.data.size" - resource too large
          </li>
          <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
          </li>
          <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
          </li>
          <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
          <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
            modify the note's tags. note.tags must be unset.
          </li>
          <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
            to modify the note's attributes. note.attributes must be unset.
          </li>
          <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
          </li>
          <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
            of the specified tags had an invalid length or pattern
          </li>
          <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
            new tags would exceed the maximum number per account
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - note not found, by GUID
          </li>
          <li> "Note.notebookGuid" - if notebookGuid provided, but not found
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - note
        """
        self.send_updateNote(authenticationToken, note)
        return self.recv_updateNote()

    def send_updateNote(self, authenticationToken, note):
        self._oprot.writeMessageBegin('updateNote', TMessageType.CALL, self._seqid)
        args = updateNote_args()
        args.authenticationToken = authenticationToken
        args.note = note
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateNote(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateNote_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateNote failed: unknown result")

    def deleteNote(self, authenticationToken, guid):
        """
        Moves the note into the trash. The note may still be undeleted, unless it
        is expunged.  This is equivalent to calling updateNote() after setting
        Note.active = false

        @param guid
          The GUID of the note to delete.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> PERMISSION_DENIED "Note" - user doesn't have permission to
                 update the note.
          </li>
        </ul>

        @throws EDAMUserException <ul>
          <li> DATA_CONFLICT "Note.guid" - the note is already deleted
          </li>
        </ul>
        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_deleteNote(authenticationToken, guid)
        return self.recv_deleteNote()

    def send_deleteNote(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('deleteNote', TMessageType.CALL, self._seqid)
        args = deleteNote_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteNote(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteNote_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteNote failed: unknown result")

    def expungeNote(self, authenticationToken, guid):
        """
        Permanently removes a Note, and all of its Resources,
        from the service.
        <p/>
        NOTE: This function is not available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param guid
          The GUID of the note to delete.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> PERMISSION_DENIED "Note" - user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_expungeNote(authenticationToken, guid)
        return self.recv_expungeNote()

    def send_expungeNote(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('expungeNote', TMessageType.CALL, self._seqid)
        args = expungeNote_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_expungeNote(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = expungeNote_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeNote failed: unknown result")

    def copyNote(self, authenticationToken, noteGuid, toNotebookGuid):
        """
        Performs a deep copy of the Note with the provided GUID 'noteGuid' into
        the Notebook with the provided GUID 'toNotebookGuid'.
        The caller must be the owner of both the Note and the Notebook.
        This creates a new Note in the destination Notebook with new content and
        Resources that match all of the content and Resources from the original
        Note, but with new GUID identifiers.
        The original Note is not modified by this operation.
        The copied note is considered as an "upload" for the purpose of upload
        transfer limit calculation, so its size is added to the upload count for
        the owner.

        If the original note has been shared and has SharedNote records, the shares
        are NOT copied.

        @param noteGuid
          The GUID of the Note to copy.

        @param toNotebookGuid
          The GUID of the Notebook that should receive the new Note.

        @return
          The metadata for the new Note that was created.  This will include the
          new GUID for this Note (and any copied Resources), but will not include
          the content body or the binary bodies of any Resources.

        @throws EDAMUserException <ul>
          <li> LIMIT_REACHED "Note" - at max number per account
          </li>
          <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
          </li>
          <li> PERMISSION_DENIED "Note" - user doesn't own
          </li>
          <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Notebook.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - noteGuid
         - toNotebookGuid
        """
        self.send_copyNote(authenticationToken, noteGuid, toNotebookGuid)
        return self.recv_copyNote()

    def send_copyNote(self, authenticationToken, noteGuid, toNotebookGuid):
        self._oprot.writeMessageBegin('copyNote', TMessageType.CALL, self._seqid)
        args = copyNote_args()
        args.authenticationToken = authenticationToken
        args.noteGuid = noteGuid
        args.toNotebookGuid = toNotebookGuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_copyNote(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = copyNote_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "copyNote failed: unknown result")

    def listNoteVersions(self, authenticationToken, noteGuid):
        """
        Returns a list of the prior versions of a particular note that are
        saved within the service.  These prior versions are stored to provide a
        recovery from unintentional removal of content from a note. The identifiers
        that are returned by this call can be used with getNoteVersion to retrieve
        the previous note.
        The identifiers will be listed from the most recent versions to the oldest.
        This call is only available for notes in Premium accounts. (I.e. access
        to past versions of Notes is a Premium-only feature.)

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
          </li>
          <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID.
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - noteGuid
        """
        self.send_listNoteVersions(authenticationToken, noteGuid)
        return self.recv_listNoteVersions()

    def send_listNoteVersions(self, authenticationToken, noteGuid):
        self._oprot.writeMessageBegin('listNoteVersions', TMessageType.CALL, self._seqid)
        args = listNoteVersions_args()
        args.authenticationToken = authenticationToken
        args.noteGuid = noteGuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listNoteVersions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listNoteVersions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNoteVersions failed: unknown result")

    def getNoteVersion(self, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
        """
        This can be used to retrieve a previous version of a Note after it has been
        updated within the service.  The caller must identify the note (via its
        guid) and the version (via the updateSequenceNumber of that version).
        to find a listing of the stored version USNs for a note, call
        listNoteVersions.
        This call is only available for notes in Premium accounts. (I.e. access
        to past versions of Notes is a Premium-only feature.)

        @param noteGuid
          The GUID of the note to be retrieved.

        @param updateSequenceNum
          The USN of the version of the note that is being retrieved

        @param withResourcesData
          If true, any Resource elements in this Note will include the binary
          contents of their 'data' field's body.

        @param withResourcesRecognition
          If true, any Resource elements will include the binary contents of the
          'recognition' field's body if recognition data is present.

        @param withResourcesAlternateData
          If true, any Resource elements in this Note will include the binary
          contents of their 'alternateData' fields' body, if an alternate form
          is present.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
          </li>
          <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID.
          </li>
          <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
             the corresponding USN.
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - noteGuid
         - updateSequenceNum
         - withResourcesData
         - withResourcesRecognition
         - withResourcesAlternateData
        """
        self.send_getNoteVersion(authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData)
        return self.recv_getNoteVersion()

    def send_getNoteVersion(self, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
        self._oprot.writeMessageBegin('getNoteVersion', TMessageType.CALL, self._seqid)
        args = getNoteVersion_args()
        args.authenticationToken = authenticationToken
        args.noteGuid = noteGuid
        args.updateSequenceNum = updateSequenceNum
        args.withResourcesData = withResourcesData
        args.withResourcesRecognition = withResourcesRecognition
        args.withResourcesAlternateData = withResourcesAlternateData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNoteVersion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNoteVersion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteVersion failed: unknown result")

    def getResource(self, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData):
        """
        Returns the current state of the resource in the service with the
        provided GUID.
        If the Resource is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).  Only the
        keys for the applicationData will be returned.

        @param guid
          The GUID of the resource to be retrieved.

        @param withData
          If true, the Resource will include the binary contents of the
          'data' field's body.

        @param withRecognition
          If true, the Resource will include the binary contents of the
          'recognition' field's body if recognition data is present.

        @param withAttributes
          If true, the Resource will include the attributes

        @param withAlternateData
          If true, the Resource will include the binary contents of the
          'alternateData' field's body, if an alternate form is present.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
         - withData
         - withRecognition
         - withAttributes
         - withAlternateData
        """
        self.send_getResource(authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData)
        return self.recv_getResource()

    def send_getResource(self, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData):
        self._oprot.writeMessageBegin('getResource', TMessageType.CALL, self._seqid)
        args = getResource_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.withData = withData
        args.withRecognition = withRecognition
        args.withAttributes = withAttributes
        args.withAlternateData = withAlternateData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getResource(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getResource_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getResource failed: unknown result")

    def getResourceApplicationData(self, authenticationToken, guid):
        """
        Get all of the application data for the Resource identified by GUID,
        with values returned within the LazyMap fullMap field.
        If there are no applicationData entries, then a LazyMap
        with an empty fullMap will be returned. If your application
        only needs to fetch its own applicationData entry, use
        getResourceApplicationDataEntry instead.

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getResourceApplicationData(authenticationToken, guid)
        return self.recv_getResourceApplicationData()

    def send_getResourceApplicationData(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getResourceApplicationData', TMessageType.CALL, self._seqid)
        args = getResourceApplicationData_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getResourceApplicationData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getResourceApplicationData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceApplicationData failed: unknown result")

    def getResourceApplicationDataEntry(self, authenticationToken, guid, key):
        """
        Get the value of a single entry in the applicationData map
        for the Resource identified by GUID.

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - Resource not found, by GUID</li>
          <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
         - key
        """
        self.send_getResourceApplicationDataEntry(authenticationToken, guid, key)
        return self.recv_getResourceApplicationDataEntry()

    def send_getResourceApplicationDataEntry(self, authenticationToken, guid, key):
        self._oprot.writeMessageBegin('getResourceApplicationDataEntry', TMessageType.CALL, self._seqid)
        args = getResourceApplicationDataEntry_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getResourceApplicationDataEntry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getResourceApplicationDataEntry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceApplicationDataEntry failed: unknown result")

    def setResourceApplicationDataEntry(self, authenticationToken, guid, key, value):
        """
        Update, or create, an entry in the applicationData map for
        the Resource identified by guid.

        Parameters:
         - authenticationToken
         - guid
         - key
         - value
        """
        self.send_setResourceApplicationDataEntry(authenticationToken, guid, key, value)
        return self.recv_setResourceApplicationDataEntry()

    def send_setResourceApplicationDataEntry(self, authenticationToken, guid, key, value):
        self._oprot.writeMessageBegin('setResourceApplicationDataEntry', TMessageType.CALL, self._seqid)
        args = setResourceApplicationDataEntry_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setResourceApplicationDataEntry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setResourceApplicationDataEntry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setResourceApplicationDataEntry failed: unknown result")

    def unsetResourceApplicationDataEntry(self, authenticationToken, guid, key):
        """
        Remove an entry identified by 'key' from the applicationData map for
        the Resource identified by 'guid'.

        Parameters:
         - authenticationToken
         - guid
         - key
        """
        self.send_unsetResourceApplicationDataEntry(authenticationToken, guid, key)
        return self.recv_unsetResourceApplicationDataEntry()

    def send_unsetResourceApplicationDataEntry(self, authenticationToken, guid, key):
        self._oprot.writeMessageBegin('unsetResourceApplicationDataEntry', TMessageType.CALL, self._seqid)
        args = unsetResourceApplicationDataEntry_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unsetResourceApplicationDataEntry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unsetResourceApplicationDataEntry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "unsetResourceApplicationDataEntry failed: unknown result")

    def updateResource(self, authenticationToken, resource):
        """
        Submit a set of changes to a resource to the service.  This can be used
        to update the meta-data about the resource, but cannot be used to change
        the binary contents of the resource (including the length and hash).  These
        cannot be changed directly without creating a new resource and removing the
        old one via updateNote.

        @param resource
          A Resource object containing the desired fields to be populated on
          the service.  The service will attempt to update the resource with the
          following fields from the client:
          <ul>
             <li>guid:  must be provided to identify the resource
             </li>
             <li>mime
             </li>
             <li>width
             </li>
             <li>height
             </li>
             <li>duration
             </li>
             <li>attributes:  optional.  if present, the set of attributes will
                  be replaced.
             </li>
          </ul>

        @return
          The Update Sequence Number of the resource after the changes have been
          applied.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
          </li>
          <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
          </li>
          <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - resource
        """
        self.send_updateResource(authenticationToken, resource)
        return self.recv_updateResource()

    def send_updateResource(self, authenticationToken, resource):
        self._oprot.writeMessageBegin('updateResource', TMessageType.CALL, self._seqid)
        args = updateResource_args()
        args.authenticationToken = authenticationToken
        args.resource = resource
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateResource(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateResource_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateResource failed: unknown result")

    def getResourceData(self, authenticationToken, guid):
        """
        Returns binary data of the resource with the provided GUID.  For
        example, if this were an image resource, this would contain the
        raw bits of the image.
        If the Resource is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the resource to be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getResourceData(authenticationToken, guid)
        return self.recv_getResourceData()

    def send_getResourceData(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getResourceData', TMessageType.CALL, self._seqid)
        args = getResourceData_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getResourceData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getResourceData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceData failed: unknown result")

    def getResourceByHash(self, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData):
        """
        Returns the current state of a resource, referenced by containing
        note GUID and resource content hash.

        @param noteGuid
          The GUID of the note that holds the resource to be retrieved.

        @param contentHash
          The MD5 checksum of the resource within that note. Note that
          this is the binary checksum, for example from Resource.data.bodyHash,
          and not the hex-encoded checksum that is used within an en-media
          tag in a note body.

        @param withData
          If true, the Resource will include the binary contents of the
          'data' field's body.

        @param withRecognition
          If true, the Resource will include the binary contents of the
          'recognition' field's body.

        @param withAlternateData
          If true, the Resource will include the binary contents of the
          'alternateData' field's body, if an alternate form is present.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
          </li>
          <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note" - not found, by guid
          </li>
          <li> "Resource" - not found, by hash
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - noteGuid
         - contentHash
         - withData
         - withRecognition
         - withAlternateData
        """
        self.send_getResourceByHash(authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData)
        return self.recv_getResourceByHash()

    def send_getResourceByHash(self, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData):
        self._oprot.writeMessageBegin('getResourceByHash', TMessageType.CALL, self._seqid)
        args = getResourceByHash_args()
        args.authenticationToken = authenticationToken
        args.noteGuid = noteGuid
        args.contentHash = contentHash
        args.withData = withData
        args.withRecognition = withRecognition
        args.withAlternateData = withAlternateData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getResourceByHash(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getResourceByHash_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceByHash failed: unknown result")

    def getResourceRecognition(self, authenticationToken, guid):
        """
        Returns the binary contents of the recognition index for the resource
        with the provided GUID.  If the caller asks about a resource that has
        no recognition data, this will throw EDAMNotFoundException.
        If the Resource is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the resource whose recognition data should be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
          <li> "Resource.recognition" - resource has no recognition
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getResourceRecognition(authenticationToken, guid)
        return self.recv_getResourceRecognition()

    def send_getResourceRecognition(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getResourceRecognition', TMessageType.CALL, self._seqid)
        args = getResourceRecognition_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getResourceRecognition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getResourceRecognition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceRecognition failed: unknown result")

    def getResourceAlternateData(self, authenticationToken, guid):
        """
        If the Resource with the provided GUID has an alternate data representation
        (indicated via the Resource.alternateData field), then this request can
        be used to retrieve the binary contents of that alternate data file.
        If the caller asks about a resource that has no alternate data form, this
        will throw EDAMNotFoundException.

        @param guid
           The GUID of the resource whose recognition data should be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
          <li> "Resource.alternateData" - resource has no recognition
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getResourceAlternateData(authenticationToken, guid)
        return self.recv_getResourceAlternateData()

    def send_getResourceAlternateData(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getResourceAlternateData', TMessageType.CALL, self._seqid)
        args = getResourceAlternateData_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getResourceAlternateData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getResourceAlternateData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceAlternateData failed: unknown result")

    def getResourceAttributes(self, authenticationToken, guid):
        """
        Returns the set of attributes for the Resource with the provided GUID.
        If the Resource is found in a public notebook, the authenticationToken
        will be ignored (so it could be an empty string).

        @param guid
          The GUID of the resource whose attributes should be retrieved.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
          </li>
          <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Resource.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_getResourceAttributes(authenticationToken, guid)
        return self.recv_getResourceAttributes()

    def send_getResourceAttributes(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('getResourceAttributes', TMessageType.CALL, self._seqid)
        args = getResourceAttributes_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getResourceAttributes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getResourceAttributes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceAttributes failed: unknown result")

    def getPublicNotebook(self, userId, publicUri):
        """
        <p>
        Looks for a user account with the provided userId on this NoteStore
        shard and determines whether that account contains a public notebook
        with the given URI.  If the account is not found, or no public notebook
        exists with this URI, this will throw an EDAMNotFoundException,
        otherwise this will return the information for that Notebook.
        </p>
        <p>
        If a notebook is visible on the web with a full URL like
        http://www.evernote.com/pub/sethdemo/api
        Then 'sethdemo' is the username that can be used to look up the userId,
        and 'api' is the publicUri.
        </p>

        @param userId
           The numeric identifier for the user who owns the public notebook.
           To find this value based on a username string, you can invoke
           UserStore.getPublicUserInfo

        @param publicUri
           The uri string for the public notebook, from Notebook.publishing.uri.

        @throws EDAMNotFoundException <ul>
          <li>"Publishing.uri" - not found, by URI</li>
        </ul>

        @throws EDAMSystemException <ul>
          <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
            taken down (for all requesters).</li>
          <li> TAKEN_DOWN "Country" - The specified public notebook is taken
            down for the requester because of an IP-based country lookup.</li>
        </ul>

        Parameters:
         - userId
         - publicUri
        """
        self.send_getPublicNotebook(userId, publicUri)
        return self.recv_getPublicNotebook()

    def send_getPublicNotebook(self, userId, publicUri):
        self._oprot.writeMessageBegin('getPublicNotebook', TMessageType.CALL, self._seqid)
        args = getPublicNotebook_args()
        args.userId = userId
        args.publicUri = publicUri
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPublicNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPublicNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPublicNotebook failed: unknown result")

    def shareNotebook(self, authenticationToken, sharedNotebook, message):
        """
        @Deprecated for first-party clients. See createOrUpdateNotebookShares.

        Share a notebook with an email address, and optionally to a specific
        recipient. If an existing SharedNotebook associated with
        sharedNotebook.notebookGuid is found by recipientUsername or email, then
        the values of sharedNotebook will be used to update the existing record,
        else a new record will be created.

        If recipientUsername is set and there is already a SharedNotebook
        for that Notebook with that recipientUsername and the privileges on the
        existing notebook are lower, than on this one, this will update the
        privileges and sharerUserId. If there isn't an existing SharedNotebook for
        recipientUsername, this will create and return a shared notebook for that
        email and recipientUsername. If recipientUsername is not set and there
        already is a SharedNotebook for a Notebook for that email address and the
        privileges on the existing SharedNotebook are lower than on this one, this
        will update the privileges and sharerUserId, and return the updated
        SharedNotebook. Otherwise, this will create and return a SharedNotebook for
        the email address.

        If the authenticationToken is a Business auth token, recipientUsername is
        set and the recipient is in the same business as the business auth token,
        this method will also auto-join the business user to the SharedNotebook -
        that is it will set serviceJoined on the SharedNotebook and create a
        LinkedNotebook on the recipient's account pointing to the SharedNotebook.
        The LinkedNotebook creation happens out-of-band, so there will be a delay
        on the order of half a minute between the SharedNotebook and LinkedNotebook
        creation.

        Also handles sending an email to the email addresses: if a SharedNotebook
        is being created, this will send the shared notebook invite email, and
        if a SharedNotebook already exists, it will send the shared notebook
        reminder email. Both these emails contain a link to join the notebook.
        If the notebook is being auto-joined, it sends an email with that
        information to the recipient.

        @param authenticationToken
          Must be an authentication token from the owner or a shared notebook
          authentication token or business authentication token with sufficient
          permissions to change invitations for a notebook.

        @param sharedNotebook
          A shared notebook object populated with the email address of the share
          recipient, the notebook guid and the access permissions. All other
          attributes of the shared object are ignored. The SharedNotebook.allowPreview
          field must be explicitly set with either a true or false value.

        @param message
          The sharer-defined message to put in the email sent out.

        @return
          The fully populated SharedNotebook object including the server assigned
          globalId which can both be used to uniquely identify the SharedNotebook.

        @throws EDAMUserException <ul>
          <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
          <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
              SharedNotebook.privilegeLevel was not set.</li>
          <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
              set. requireLogin is deprecated.</li>
          <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
              SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
          <li>PERMISSION_DENIED "emailConfirmation" - if the email address on the
              authenticationToken's owner's account is not confirmed.</li>
          <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
              recipientSettings is set in the sharedNotebook.  Only the recipient
              can set these values via the setSharedNotebookRecipientSettings
              method.</li>
          <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
              EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
          </ul>
        @throws EDAMNotFoundException <ul>
          <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
          </li>
          </ul>

        Parameters:
         - authenticationToken
         - sharedNotebook
         - message
        """
        self.send_shareNotebook(authenticationToken, sharedNotebook, message)
        return self.recv_shareNotebook()

    def send_shareNotebook(self, authenticationToken, sharedNotebook, message):
        self._oprot.writeMessageBegin('shareNotebook', TMessageType.CALL, self._seqid)
        args = shareNotebook_args()
        args.authenticationToken = authenticationToken
        args.sharedNotebook = sharedNotebook
        args.message = message
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shareNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shareNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "shareNotebook failed: unknown result")

    def createOrUpdateNotebookShares(self, authenticationToken, shareTemplate):
        """
        Share a notebook by a messaging thread ID or a list of contacts. This function is
        intended to be used in conjunction with Evernote messaging, and as such does not
        notify the recipient that a notebook has been shared with them.

        Sharing with a subset of participants on a thread is accomplished by specifying both
        a thread ID and a list of contacts. This ensures that even if those contacts are
        on the thread under a deactivated identity, the correct user (the one who has the
        given contact on the thread) receives the share.

        @param authenticationToken
          An authentication token that grants the caller permission to share the notebook.
          This should be an owner token if the notebook is owned by the caller.
          If the notebook is a business notebook to which the caller has full access,
          this should be their business authentication token. If the notebook is a shared
          (non-business) notebook to which the caller has full access, this should be the
          shared notebook authentication token returned by NoteStore.authenticateToNotebook.

        @param shareTemplate
          Specifies the GUID of the notebook to be shared, the privilege at which the notebook
          should be shared, and the recipient information.

        @return
          A structure containing the USN of the Notebook after the change and a list of created
          or updated SharedNotebooks.

        @throws EDAMUserException <ul>
          <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
          <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
            valid GUID</li>
          <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
          <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
            specified</li>
          <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
            is not allowed.</li>
          <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
            specified, either by thread ID or as a list of contacts</li>
          <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
            number of shares</li>
        </ul>

        @throws EDAMInvalidContactsException <ul>
          <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
            in shareTemplate.recipients was not syntactically valid, or if attempting to
            share a notebook with an Evernote identity that the sharer does not have a
            connection to. The exception will specify which recipients were invalid.</li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
          <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
            specified, but no thread with that ID exists</li>
        </ul>

        Parameters:
         - authenticationToken
         - shareTemplate
        """
        self.send_createOrUpdateNotebookShares(authenticationToken, shareTemplate)
        return self.recv_createOrUpdateNotebookShares()

    def send_createOrUpdateNotebookShares(self, authenticationToken, shareTemplate):
        self._oprot.writeMessageBegin('createOrUpdateNotebookShares', TMessageType.CALL, self._seqid)
        args = createOrUpdateNotebookShares_args()
        args.authenticationToken = authenticationToken
        args.shareTemplate = shareTemplate
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createOrUpdateNotebookShares(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createOrUpdateNotebookShares_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        if result.invalidContactsException is not None:
            raise result.invalidContactsException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createOrUpdateNotebookShares failed: unknown result")

    def updateSharedNotebook(self, authenticationToken, sharedNotebook):
        """
        @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.

        Parameters:
         - authenticationToken
         - sharedNotebook
        """
        self.send_updateSharedNotebook(authenticationToken, sharedNotebook)
        return self.recv_updateSharedNotebook()

    def send_updateSharedNotebook(self, authenticationToken, sharedNotebook):
        self._oprot.writeMessageBegin('updateSharedNotebook', TMessageType.CALL, self._seqid)
        args = updateSharedNotebook_args()
        args.authenticationToken = authenticationToken
        args.sharedNotebook = sharedNotebook
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateSharedNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateSharedNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateSharedNotebook failed: unknown result")

    def setNotebookRecipientSettings(self, authenticationToken, notebookGuid, recipientSettings):
        """
        Set values for the recipient settings associated with a notebook share. Only the
        recipient of the share can update their recipient settings.

        If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
        you must leave that field unset in recipientSettings.
        This method will skip that field for updates and attempt to leave the existing value as
        it is.

        If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
        will be either left as null or converted to false (if currently true).

        @param authenticationToken The owner authentication token for the recipient of the share.

        @return The updated Notebook with the new recipient settings. Note that some of the
        recipient settings may differ from what was requested. Clients should update their state
        based on this return value.

        @throws EDAMNotFoundException <ul>
          <li>Notebook.guid - Thrown if the service does not have a notebook record with the
              notebookGuid on the given shard.</li>
          <li>Publishing.publishState - Thrown if the business notebook is not shared with the
              user and is also not published to their business.</li>
        </ul>

        @throws EDAMUserException <ul>
          <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
              allowed to set recipient settings on the specified notebook.</li>
          <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
              is allowed only for notebooks which belong to the same business as the user.</li>
          <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
              to false and any of reminder* settings to true.</li>
        </ul>

        Parameters:
         - authenticationToken
         - notebookGuid
         - recipientSettings
        """
        self.send_setNotebookRecipientSettings(authenticationToken, notebookGuid, recipientSettings)
        return self.recv_setNotebookRecipientSettings()

    def send_setNotebookRecipientSettings(self, authenticationToken, notebookGuid, recipientSettings):
        self._oprot.writeMessageBegin('setNotebookRecipientSettings', TMessageType.CALL, self._seqid)
        args = setNotebookRecipientSettings_args()
        args.authenticationToken = authenticationToken
        args.notebookGuid = notebookGuid
        args.recipientSettings = recipientSettings
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setNotebookRecipientSettings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setNotebookRecipientSettings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setNotebookRecipientSettings failed: unknown result")

    def listSharedNotebooks(self, authenticationToken):
        """
        Lists the collection of shared notebooks for all notebooks in the
        users account.

        @return
         The list of all SharedNotebooks for the user

        Parameters:
         - authenticationToken
        """
        self.send_listSharedNotebooks(authenticationToken)
        return self.recv_listSharedNotebooks()

    def send_listSharedNotebooks(self, authenticationToken):
        self._oprot.writeMessageBegin('listSharedNotebooks', TMessageType.CALL, self._seqid)
        args = listSharedNotebooks_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listSharedNotebooks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listSharedNotebooks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listSharedNotebooks failed: unknown result")

    def createLinkedNotebook(self, authenticationToken, linkedNotebook):
        """
        Asks the service to make a linked notebook with the provided name, username
        of the owner and identifiers provided. A linked notebook can be either a
        link to a public notebook or to a private shared notebook.

        @param linkedNotebook
          The desired fields for the linked notebook must be provided on this
          object.  The name of the linked notebook must be set. Either a username
          uri or a shard id and share key must be provided otherwise a
          EDAMUserException is thrown.

        @return
          The newly created LinkedNotebook.  The server-side id will be
          saved in this object's 'id' field.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
          <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
          </li>
          <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
          </li>
          <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
            if public notebook set but bad uri
          </li>
          <li> DATA_REQUIRED "LinkedNotebook.shardId" -
            if private notebook but shard id not provided
          </li>
          <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
          </li>
        </ul>

        @throws EDAMSystemException <ul>
          <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
            if a bad global identifer was set on a private notebook
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - linkedNotebook
        """
        self.send_createLinkedNotebook(authenticationToken, linkedNotebook)
        return self.recv_createLinkedNotebook()

    def send_createLinkedNotebook(self, authenticationToken, linkedNotebook):
        self._oprot.writeMessageBegin('createLinkedNotebook', TMessageType.CALL, self._seqid)
        args = createLinkedNotebook_args()
        args.authenticationToken = authenticationToken
        args.linkedNotebook = linkedNotebook
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createLinkedNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createLinkedNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createLinkedNotebook failed: unknown result")

    def updateLinkedNotebook(self, authenticationToken, linkedNotebook):
        """
        @param linkedNotebook
          Updates the name of a linked notebook.

        @return
          The Update Sequence Number for this change within the account.

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
          </li>
          <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
          </li>
          <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - linkedNotebook
        """
        self.send_updateLinkedNotebook(authenticationToken, linkedNotebook)
        return self.recv_updateLinkedNotebook()

    def send_updateLinkedNotebook(self, authenticationToken, linkedNotebook):
        self._oprot.writeMessageBegin('updateLinkedNotebook', TMessageType.CALL, self._seqid)
        args = updateLinkedNotebook_args()
        args.authenticationToken = authenticationToken
        args.linkedNotebook = linkedNotebook
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateLinkedNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateLinkedNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateLinkedNotebook failed: unknown result")

    def listLinkedNotebooks(self, authenticationToken):
        """
        Returns a list of linked notebooks

        Parameters:
         - authenticationToken
        """
        self.send_listLinkedNotebooks(authenticationToken)
        return self.recv_listLinkedNotebooks()

    def send_listLinkedNotebooks(self, authenticationToken):
        self._oprot.writeMessageBegin('listLinkedNotebooks', TMessageType.CALL, self._seqid)
        args = listLinkedNotebooks_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listLinkedNotebooks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listLinkedNotebooks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listLinkedNotebooks failed: unknown result")

    def expungeLinkedNotebook(self, authenticationToken, guid):
        """
        Permanently expunges the linked notebook from the account.
        <p/>
        NOTE: This function is generally not available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param guid
          The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
          from the account.

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_expungeLinkedNotebook(authenticationToken, guid)
        return self.recv_expungeLinkedNotebook()

    def send_expungeLinkedNotebook(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('expungeLinkedNotebook', TMessageType.CALL, self._seqid)
        args = expungeLinkedNotebook_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_expungeLinkedNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = expungeLinkedNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeLinkedNotebook failed: unknown result")

    def authenticateToSharedNotebook(self, shareKeyOrGlobalId, authenticationToken):
        """
        Asks the service to produce an authentication token that can be used to
        access the contents of a shared notebook from someone else's account.
        This authenticationToken can be used with the various other NoteStore
        calls to find and retrieve notes, and if the permissions in the shared
        notebook are sufficient, to make changes to the contents of the notebook.

        @param shareKeyOrGlobalId
          May be one of the following:
          <ul>
            <li>A share key for a shared notebook that was granted to some recipient
                Must be used if you are joining a notebook unless it was shared via
                createOrUpdateNotebookShares. Share keys are delivered out-of-band
                and are generally not available to clients. For security reasons,
                share keys may be invalidated at the discretion of the service.
            </li>
            <li>The shared notebook global identifier. May be used to access a
                notebook that is already joined.
            </li>
            <li>The Notebook GUID. May be used to access a notebook that was already
                joined, or to access a notebook that was shared with the recipient
                via createOrUpdateNotebookShares.
            </li>
          </ul>

        @param authenticationToken
          If a non-empty string is provided, this is the full user-based
          authentication token that identifies the user who is currently logged in
          and trying to access the shared notebook.
          If this string is empty, the service will attempt to authenticate to the
          shared notebook without any logged in user.

        @throws EDAMSystemException <ul>
          <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
          <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
        </ul>

        @throws EDAMUserException <ul>
          <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
                 no valid authentication token was provided.
          </li>
          <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
                 and another username has already been bound to this notebook.
          </li>
        </ul>

        Parameters:
         - shareKeyOrGlobalId
         - authenticationToken
        """
        self.send_authenticateToSharedNotebook(shareKeyOrGlobalId, authenticationToken)
        return self.recv_authenticateToSharedNotebook()

    def send_authenticateToSharedNotebook(self, shareKeyOrGlobalId, authenticationToken):
        self._oprot.writeMessageBegin('authenticateToSharedNotebook', TMessageType.CALL, self._seqid)
        args = authenticateToSharedNotebook_args()
        args.shareKeyOrGlobalId = shareKeyOrGlobalId
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_authenticateToSharedNotebook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = authenticateToSharedNotebook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateToSharedNotebook failed: unknown result")

    def getSharedNotebookByAuth(self, authenticationToken):
        """
        This function is used to retrieve extended information about a shared
        notebook by a guest who has already authenticated to access that notebook.
        This requires an 'authenticationToken' parameter which should be the
        resut of a call to authenticateToSharedNotebook(...).
        I.e. this is the token that gives access to the particular shared notebook
        in someone else's account -- it's not the authenticationToken for the
        owner of the notebook itself.

        @param authenticationToken
          Should be the authentication token retrieved from the reply of
          authenticateToSharedNotebook(), proving access to a particular shared
          notebook.

        @throws EDAMUserException <ul>
          <li> PERMISSION_DENIED "authenticationToken" -
                 authentication token doesn't correspond to a valid shared notebook
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "SharedNotebook.id" - the shared notebook no longer exists
          </li>
        </ul>

        Parameters:
         - authenticationToken
        """
        self.send_getSharedNotebookByAuth(authenticationToken)
        return self.recv_getSharedNotebookByAuth()

    def send_getSharedNotebookByAuth(self, authenticationToken):
        self._oprot.writeMessageBegin('getSharedNotebookByAuth', TMessageType.CALL, self._seqid)
        args = getSharedNotebookByAuth_args()
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSharedNotebookByAuth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSharedNotebookByAuth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSharedNotebookByAuth failed: unknown result")

    def emailNote(self, authenticationToken, parameters):
        """
        Attempts to send a single note to one or more email recipients.
        <p/>
        NOTE: This function is generally not available to third party applications.
        Calls will result in an EDAMUserException with the error code
        PERMISSION_DENIED.

        @param authenticationToken
           The note will be sent as the user logged in via this token, using that
           user's registered email address.  If the authenticated user doesn't
           have permission to read that note, the emailing will fail.

        @param parameters
           The note must be specified either by GUID (in which case it will be
           sent using the existing data in the service), or else the full Note
           must be passed to this call.  This also specifies the additional
           email fields that will be used in the email.

        @throws EDAMUserException <ul>
          <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
            The email can't be sent because this would exceed the user's daily
            email limit.
          </li>
          <li> BAD_DATA_FORMAT "(email address)" -
            email address malformed
          </li>
          <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
            if there are no To: or Cc: addresses provided.
          </li>
          <li> DATA_REQUIRED "Note.title" -
            if the caller provides a Note parameter with no title
          </li>
          <li> DATA_REQUIRED "Note.content" -
            if the caller provides a Note parameter with no content
          </li>
          <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
          </li>
          <li> DATA_REQUIRED "NoteEmailParameters.note" -
            if no guid or note provided
          </li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - parameters
        """
        self.send_emailNote(authenticationToken, parameters)
        self.recv_emailNote()

    def send_emailNote(self, authenticationToken, parameters):
        self._oprot.writeMessageBegin('emailNote', TMessageType.CALL, self._seqid)
        args = emailNote_args()
        args.authenticationToken = authenticationToken
        args.parameters = parameters
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_emailNote(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = emailNote_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        return

    def shareNote(self, authenticationToken, guid):
        """
        If this note is not already shared publicly (via its own direct URL), then this
        will start sharing that note.
        This will return the secret "Note Key" for this note that
        can currently be used in conjunction with the Note's GUID to gain direct
        read-only access to the Note.
        If the note is already shared, then this won't make any changes to the
        note, and the existing "Note Key" will be returned.  The only way to change
        the Note Key for an existing note is to stopSharingNote first, and then
        call this function.

        @param guid
          The GUID of the note to be shared.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "Note.guid" - not found, by GUID</li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_shareNote(authenticationToken, guid)
        return self.recv_shareNote()

    def send_shareNote(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('shareNote', TMessageType.CALL, self._seqid)
        args = shareNote_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shareNote(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shareNote_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "shareNote failed: unknown result")

    def stopSharingNote(self, authenticationToken, guid):
        """
        If this note is shared publicly then this will stop sharing that note
        and invalidate its "Note Key", so any existing URLs to access that Note
        will stop working.

        If the Note is not shared, then this function will do nothing.

        This function does not remove invididual shares for the note. To remove
        individual shares, see stopSharingNoteWithRecipients.

        @param guid
          The GUID of the note to be un-shared.

        @throws EDAMUserException <ul>
          <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
          <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li>"Note.guid" - not found, by GUID</li>
        </ul>

        Parameters:
         - authenticationToken
         - guid
        """
        self.send_stopSharingNote(authenticationToken, guid)
        self.recv_stopSharingNote()

    def send_stopSharingNote(self, authenticationToken, guid):
        self._oprot.writeMessageBegin('stopSharingNote', TMessageType.CALL, self._seqid)
        args = stopSharingNote_args()
        args.authenticationToken = authenticationToken
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stopSharingNote(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stopSharingNote_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        return

    def authenticateToSharedNote(self, guid, noteKey, authenticationToken):
        """
        Asks the service to produce an authentication token that can be used to
        access the contents of a single Note which was individually shared
        from someone's account.
        This authenticationToken can be used with the various other NoteStore
        calls to find and retrieve the Note and its directly-referenced children.

        @param guid
          The GUID identifying this Note on this shard.

        @param noteKey
          The 'noteKey' identifier from the Note that was originally created via
          a call to shareNote() and then given to a recipient to access.

        @param authenticationToken
          An optional authenticationToken that identifies the user accessing the
          shared note. This parameter may be required to access some shared notes.

        @throws EDAMUserException <ul>
          <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
            shared, or the noteKey doesn't match the current key for this note
          </li>
          <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
            required to access this Note, but either no authentication token or a
            "non-owner" authentication token was provided.
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li> "guid" - the note with that GUID is not found
          </li>
        </ul>

        @throws EDAMSystemException <ul>
          <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
            all requesters).
          </li>
          <li> TAKEN_DOWN "Country" - The specified shared note is taken down
            for the requester because of an IP-based country lookup.
          </ul>
        </ul>

        Parameters:
         - guid
         - noteKey
         - authenticationToken
        """
        self.send_authenticateToSharedNote(guid, noteKey, authenticationToken)
        return self.recv_authenticateToSharedNote()

    def send_authenticateToSharedNote(self, guid, noteKey, authenticationToken):
        self._oprot.writeMessageBegin('authenticateToSharedNote', TMessageType.CALL, self._seqid)
        args = authenticateToSharedNote_args()
        args.guid = guid
        args.noteKey = noteKey
        args.authenticationToken = authenticationToken
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_authenticateToSharedNote(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = authenticateToSharedNote_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateToSharedNote failed: unknown result")

    def findRelated(self, authenticationToken, query, resultSpec):
        """
        Identify related entities on the service, such as notes,
        notebooks, tags and users in a business related to notes or content.

        @param query
          The information about which we are finding related entities.

        @param resultSpec
          Allows the client to indicate the type and quantity of
          information to be returned, allowing a saving of time and
          bandwidth.

        @return
          The result of the query, with information considered
          to likely be relevantly related to the information
          described by the query.

        @throws EDAMUserException <ul>
          <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
            a zero-length plain text value.
          </li>
          <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
            invalid Note GUID, that is, one that does not match the constraints
            defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
          </li>
          <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
          </li>
          <li>PERMISSION_DENIED "Note" - If the caller does not have access to
            the note identified by RelatedQuery.noteGuid.
          </li>
          <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
            findExperts in the context of a non business user (i.e. The authenticationToken
            is not a business auth token).
          </li>
          <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
            in the result spec.
          </li>
        </ul>

        @throws EDAMNotFoundException <ul>
          <li>"RelatedQuery.noteGuid" - the note with that GUID is not
            found, if that field has been set in the query.
          </li>
        </ul>

        Parameters:
         - authenticationToken
         - query
         - resultSpec
        """
        self.send_findRelated(authenticationToken, query, resultSpec)
        return self.recv_findRelated()

    def send_findRelated(self, authenticationToken, query, resultSpec):
        self._oprot.writeMessageBegin('findRelated', TMessageType.CALL, self._seqid)
        args = findRelated_args()
        args.authenticationToken = authenticationToken
        args.query = query
        args.resultSpec = resultSpec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findRelated(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findRelated_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.systemException is not None:
            raise result.systemException
        if result.notFoundException is not None:
            raise result.notFoundException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findRelated failed: unknown result")

    def updateNoteIfUsnMatches(self, authenticationToken, note):
        """
        Perform the same operation as updateNote() would provided that the update
        sequence number on the parameter Note object matches the current update sequence
        number that the service has for the note.  If they do <i>not</i> match, then
        <i>no</i> update is performed and the return value will have the current server
        state in the note field and updated will be false.  If the update sequence
        numbers between the client and server do match, then the note will be updated
        and the note field of the return value will be returned as it would be for the
        updateNote method.  This method allows you to check for an update to the note
        on the service, by another client instance, from when you obtained the
        note state as a baseline for your edits and the time when you wish to save your
        edits.  If your client can merge the conflict, you can avoid overwriting changes
        that were saved to the service by the other client.

        See the updateNote method for information on the exceptions and parameters for
        this method.  The only difference is that you must have an update sequence number
        defined on the note parameter (equal to the USN of the note as synched to the
        client), and the following additional exceptions might be thrown.

        @throws EDAMUserException <ul>
          <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
              not provided.  This includes a value that is set as 0.</li>
          <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
              sequence number that is larger than the current server value, which should
              not happen if your client is working correctly.</li>
        </ul>

        Parameters:
         - authenticationToken
         - note
        """
        self.send_updateNoteIfUsnMatches(authenticationToken, note)
        return self.recv_updateNoteIfUsnMatches()

    def send_updateNoteIfUsnMatches(self, authenticationToken, note):
        self._oprot.writeMessageBegin('updateNoteIfUsnMatches', TMessageType.CALL, self._seqid)
        args = updateNoteIfUsnMatches_args()
        args.authenticationToken = authenticationToken
        args.note = note
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateNoteIfUsnMatches(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateNoteIfUsnMatches_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateNoteIfUsnMatches failed: unknown result")

    def manageNotebookShares(self, authenticationToken, parameters):
        """
        Manage invitations and memberships associated with a given notebook.

        <i>Note:</i> Beta method! This method is currently intended for
        limited use by Evernote clients that have discussed using this
        routine with the platform team.

        @param parameters A structure containing all parameters for the updates.
           See the structure documentation for details.

        @throws EDAMUserException <ul>
          <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
           notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
           shares.</li>
        </ul>

        Parameters:
         - authenticationToken
         - parameters
        """
        self.send_manageNotebookShares(authenticationToken, parameters)
        return self.recv_manageNotebookShares()

    def send_manageNotebookShares(self, authenticationToken, parameters):
        self._oprot.writeMessageBegin('manageNotebookShares', TMessageType.CALL, self._seqid)
        args = manageNotebookShares_args()
        args.authenticationToken = authenticationToken
        args.parameters = parameters
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_manageNotebookShares(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = manageNotebookShares_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "manageNotebookShares failed: unknown result")

    def getNotebookShares(self, authenticationToken, notebookGuid):
        """
        Return the share relationships for the given notebook, including
        both the invitations and the memberships.

        <i>Note:</i> Beta method! This method is currently intended for
        limited use by Evernote clients that have discussed using this
        routine with the platform team.

        Parameters:
         - authenticationToken
         - notebookGuid
        """
        self.send_getNotebookShares(authenticationToken, notebookGuid)
        return self.recv_getNotebookShares()

    def send_getNotebookShares(self, authenticationToken, notebookGuid):
        self._oprot.writeMessageBegin('getNotebookShares', TMessageType.CALL, self._seqid)
        args = getNotebookShares_args()
        args.authenticationToken = authenticationToken
        args.notebookGuid = notebookGuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNotebookShares(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNotebookShares_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.userException is not None:
            raise result.userException
        if result.notFoundException is not None:
            raise result.notFoundException
        if result.systemException is not None:
            raise result.systemException
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNotebookShares failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getSyncState"] = Processor.process_getSyncState
        self._processMap["getFilteredSyncChunk"] = Processor.process_getFilteredSyncChunk
        self._processMap["getLinkedNotebookSyncState"] = Processor.process_getLinkedNotebookSyncState
        self._processMap["getLinkedNotebookSyncChunk"] = Processor.process_getLinkedNotebookSyncChunk
        self._processMap["listNotebooks"] = Processor.process_listNotebooks
        self._processMap["listAccessibleBusinessNotebooks"] = Processor.process_listAccessibleBusinessNotebooks
        self._processMap["getNotebook"] = Processor.process_getNotebook
        self._processMap["getDefaultNotebook"] = Processor.process_getDefaultNotebook
        self._processMap["createNotebook"] = Processor.process_createNotebook
        self._processMap["updateNotebook"] = Processor.process_updateNotebook
        self._processMap["expungeNotebook"] = Processor.process_expungeNotebook
        self._processMap["listTags"] = Processor.process_listTags
        self._processMap["listTagsByNotebook"] = Processor.process_listTagsByNotebook
        self._processMap["getTag"] = Processor.process_getTag
        self._processMap["createTag"] = Processor.process_createTag
        self._processMap["updateTag"] = Processor.process_updateTag
        self._processMap["untagAll"] = Processor.process_untagAll
        self._processMap["expungeTag"] = Processor.process_expungeTag
        self._processMap["listSearches"] = Processor.process_listSearches
        self._processMap["getSearch"] = Processor.process_getSearch
        self._processMap["createSearch"] = Processor.process_createSearch
        self._processMap["updateSearch"] = Processor.process_updateSearch
        self._processMap["expungeSearch"] = Processor.process_expungeSearch
        self._processMap["findNoteOffset"] = Processor.process_findNoteOffset
        self._processMap["findNotesMetadata"] = Processor.process_findNotesMetadata
        self._processMap["findNoteCounts"] = Processor.process_findNoteCounts
        self._processMap["getNoteWithResultSpec"] = Processor.process_getNoteWithResultSpec
        self._processMap["getNote"] = Processor.process_getNote
        self._processMap["getNoteApplicationData"] = Processor.process_getNoteApplicationData
        self._processMap["getNoteApplicationDataEntry"] = Processor.process_getNoteApplicationDataEntry
        self._processMap["setNoteApplicationDataEntry"] = Processor.process_setNoteApplicationDataEntry
        self._processMap["unsetNoteApplicationDataEntry"] = Processor.process_unsetNoteApplicationDataEntry
        self._processMap["getNoteContent"] = Processor.process_getNoteContent
        self._processMap["getNoteSearchText"] = Processor.process_getNoteSearchText
        self._processMap["getResourceSearchText"] = Processor.process_getResourceSearchText
        self._processMap["getNoteTagNames"] = Processor.process_getNoteTagNames
        self._processMap["createNote"] = Processor.process_createNote
        self._processMap["updateNote"] = Processor.process_updateNote
        self._processMap["deleteNote"] = Processor.process_deleteNote
        self._processMap["expungeNote"] = Processor.process_expungeNote
        self._processMap["copyNote"] = Processor.process_copyNote
        self._processMap["listNoteVersions"] = Processor.process_listNoteVersions
        self._processMap["getNoteVersion"] = Processor.process_getNoteVersion
        self._processMap["getResource"] = Processor.process_getResource
        self._processMap["getResourceApplicationData"] = Processor.process_getResourceApplicationData
        self._processMap["getResourceApplicationDataEntry"] = Processor.process_getResourceApplicationDataEntry
        self._processMap["setResourceApplicationDataEntry"] = Processor.process_setResourceApplicationDataEntry
        self._processMap["unsetResourceApplicationDataEntry"] = Processor.process_unsetResourceApplicationDataEntry
        self._processMap["updateResource"] = Processor.process_updateResource
        self._processMap["getResourceData"] = Processor.process_getResourceData
        self._processMap["getResourceByHash"] = Processor.process_getResourceByHash
        self._processMap["getResourceRecognition"] = Processor.process_getResourceRecognition
        self._processMap["getResourceAlternateData"] = Processor.process_getResourceAlternateData
        self._processMap["getResourceAttributes"] = Processor.process_getResourceAttributes
        self._processMap["getPublicNotebook"] = Processor.process_getPublicNotebook
        self._processMap["shareNotebook"] = Processor.process_shareNotebook
        self._processMap["createOrUpdateNotebookShares"] = Processor.process_createOrUpdateNotebookShares
        self._processMap["updateSharedNotebook"] = Processor.process_updateSharedNotebook
        self._processMap["setNotebookRecipientSettings"] = Processor.process_setNotebookRecipientSettings
        self._processMap["listSharedNotebooks"] = Processor.process_listSharedNotebooks
        self._processMap["createLinkedNotebook"] = Processor.process_createLinkedNotebook
        self._processMap["updateLinkedNotebook"] = Processor.process_updateLinkedNotebook
        self._processMap["listLinkedNotebooks"] = Processor.process_listLinkedNotebooks
        self._processMap["expungeLinkedNotebook"] = Processor.process_expungeLinkedNotebook
        self._processMap["authenticateToSharedNotebook"] = Processor.process_authenticateToSharedNotebook
        self._processMap["getSharedNotebookByAuth"] = Processor.process_getSharedNotebookByAuth
        self._processMap["emailNote"] = Processor.process_emailNote
        self._processMap["shareNote"] = Processor.process_shareNote
        self._processMap["stopSharingNote"] = Processor.process_stopSharingNote
        self._processMap["authenticateToSharedNote"] = Processor.process_authenticateToSharedNote
        self._processMap["findRelated"] = Processor.process_findRelated
        self._processMap["updateNoteIfUsnMatches"] = Processor.process_updateNoteIfUsnMatches
        self._processMap["manageNotebookShares"] = Processor.process_manageNotebookShares
        self._processMap["getNotebookShares"] = Processor.process_getNotebookShares

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getSyncState(self, seqid, iprot, oprot):
        args = getSyncState_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSyncState_result()
        try:
            result.success = self._handler.getSyncState(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSyncState", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFilteredSyncChunk(self, seqid, iprot, oprot):
        args = getFilteredSyncChunk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFilteredSyncChunk_result()
        try:
            result.success = self._handler.getFilteredSyncChunk(args.authenticationToken, args.afterUSN, args.maxEntries, args.filter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFilteredSyncChunk", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLinkedNotebookSyncState(self, seqid, iprot, oprot):
        args = getLinkedNotebookSyncState_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLinkedNotebookSyncState_result()
        try:
            result.success = self._handler.getLinkedNotebookSyncState(args.authenticationToken, args.linkedNotebook)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLinkedNotebookSyncState", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLinkedNotebookSyncChunk(self, seqid, iprot, oprot):
        args = getLinkedNotebookSyncChunk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLinkedNotebookSyncChunk_result()
        try:
            result.success = self._handler.getLinkedNotebookSyncChunk(args.authenticationToken, args.linkedNotebook, args.afterUSN, args.maxEntries, args.fullSyncOnly)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLinkedNotebookSyncChunk", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listNotebooks(self, seqid, iprot, oprot):
        args = listNotebooks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listNotebooks_result()
        try:
            result.success = self._handler.listNotebooks(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listNotebooks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listAccessibleBusinessNotebooks(self, seqid, iprot, oprot):
        args = listAccessibleBusinessNotebooks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listAccessibleBusinessNotebooks_result()
        try:
            result.success = self._handler.listAccessibleBusinessNotebooks(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listAccessibleBusinessNotebooks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNotebook(self, seqid, iprot, oprot):
        args = getNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNotebook_result()
        try:
            result.success = self._handler.getNotebook(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDefaultNotebook(self, seqid, iprot, oprot):
        args = getDefaultNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDefaultNotebook_result()
        try:
            result.success = self._handler.getDefaultNotebook(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDefaultNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createNotebook(self, seqid, iprot, oprot):
        args = createNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createNotebook_result()
        try:
            result.success = self._handler.createNotebook(args.authenticationToken, args.notebook)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateNotebook(self, seqid, iprot, oprot):
        args = updateNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateNotebook_result()
        try:
            result.success = self._handler.updateNotebook(args.authenticationToken, args.notebook)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_expungeNotebook(self, seqid, iprot, oprot):
        args = expungeNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = expungeNotebook_result()
        try:
            result.success = self._handler.expungeNotebook(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("expungeNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listTags(self, seqid, iprot, oprot):
        args = listTags_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listTags_result()
        try:
            result.success = self._handler.listTags(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listTags", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listTagsByNotebook(self, seqid, iprot, oprot):
        args = listTagsByNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listTagsByNotebook_result()
        try:
            result.success = self._handler.listTagsByNotebook(args.authenticationToken, args.notebookGuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listTagsByNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTag(self, seqid, iprot, oprot):
        args = getTag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTag_result()
        try:
            result.success = self._handler.getTag(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTag", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createTag(self, seqid, iprot, oprot):
        args = createTag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createTag_result()
        try:
            result.success = self._handler.createTag(args.authenticationToken, args.tag)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createTag", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateTag(self, seqid, iprot, oprot):
        args = updateTag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateTag_result()
        try:
            result.success = self._handler.updateTag(args.authenticationToken, args.tag)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateTag", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_untagAll(self, seqid, iprot, oprot):
        args = untagAll_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = untagAll_result()
        try:
            self._handler.untagAll(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("untagAll", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_expungeTag(self, seqid, iprot, oprot):
        args = expungeTag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = expungeTag_result()
        try:
            result.success = self._handler.expungeTag(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("expungeTag", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listSearches(self, seqid, iprot, oprot):
        args = listSearches_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listSearches_result()
        try:
            result.success = self._handler.listSearches(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listSearches", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSearch(self, seqid, iprot, oprot):
        args = getSearch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSearch_result()
        try:
            result.success = self._handler.getSearch(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSearch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createSearch(self, seqid, iprot, oprot):
        args = createSearch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createSearch_result()
        try:
            result.success = self._handler.createSearch(args.authenticationToken, args.search)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createSearch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateSearch(self, seqid, iprot, oprot):
        args = updateSearch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateSearch_result()
        try:
            result.success = self._handler.updateSearch(args.authenticationToken, args.search)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateSearch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_expungeSearch(self, seqid, iprot, oprot):
        args = expungeSearch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = expungeSearch_result()
        try:
            result.success = self._handler.expungeSearch(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("expungeSearch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findNoteOffset(self, seqid, iprot, oprot):
        args = findNoteOffset_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findNoteOffset_result()
        try:
            result.success = self._handler.findNoteOffset(args.authenticationToken, args.filter, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findNoteOffset", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findNotesMetadata(self, seqid, iprot, oprot):
        args = findNotesMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findNotesMetadata_result()
        try:
            result.success = self._handler.findNotesMetadata(args.authenticationToken, args.filter, args.offset, args.maxNotes, args.resultSpec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findNotesMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findNoteCounts(self, seqid, iprot, oprot):
        args = findNoteCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findNoteCounts_result()
        try:
            result.success = self._handler.findNoteCounts(args.authenticationToken, args.filter, args.withTrash)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findNoteCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNoteWithResultSpec(self, seqid, iprot, oprot):
        args = getNoteWithResultSpec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNoteWithResultSpec_result()
        try:
            result.success = self._handler.getNoteWithResultSpec(args.authenticationToken, args.guid, args.resultSpec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNoteWithResultSpec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNote(self, seqid, iprot, oprot):
        args = getNote_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNote_result()
        try:
            result.success = self._handler.getNote(args.authenticationToken, args.guid, args.withContent, args.withResourcesData, args.withResourcesRecognition, args.withResourcesAlternateData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNote", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNoteApplicationData(self, seqid, iprot, oprot):
        args = getNoteApplicationData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNoteApplicationData_result()
        try:
            result.success = self._handler.getNoteApplicationData(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNoteApplicationData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNoteApplicationDataEntry(self, seqid, iprot, oprot):
        args = getNoteApplicationDataEntry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNoteApplicationDataEntry_result()
        try:
            result.success = self._handler.getNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNoteApplicationDataEntry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setNoteApplicationDataEntry(self, seqid, iprot, oprot):
        args = setNoteApplicationDataEntry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setNoteApplicationDataEntry_result()
        try:
            result.success = self._handler.setNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setNoteApplicationDataEntry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unsetNoteApplicationDataEntry(self, seqid, iprot, oprot):
        args = unsetNoteApplicationDataEntry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unsetNoteApplicationDataEntry_result()
        try:
            result.success = self._handler.unsetNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("unsetNoteApplicationDataEntry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNoteContent(self, seqid, iprot, oprot):
        args = getNoteContent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNoteContent_result()
        try:
            result.success = self._handler.getNoteContent(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNoteContent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNoteSearchText(self, seqid, iprot, oprot):
        args = getNoteSearchText_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNoteSearchText_result()
        try:
            result.success = self._handler.getNoteSearchText(args.authenticationToken, args.guid, args.noteOnly, args.tokenizeForIndexing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNoteSearchText", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getResourceSearchText(self, seqid, iprot, oprot):
        args = getResourceSearchText_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getResourceSearchText_result()
        try:
            result.success = self._handler.getResourceSearchText(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getResourceSearchText", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNoteTagNames(self, seqid, iprot, oprot):
        args = getNoteTagNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNoteTagNames_result()
        try:
            result.success = self._handler.getNoteTagNames(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNoteTagNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createNote(self, seqid, iprot, oprot):
        args = createNote_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createNote_result()
        try:
            result.success = self._handler.createNote(args.authenticationToken, args.note)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createNote", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateNote(self, seqid, iprot, oprot):
        args = updateNote_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateNote_result()
        try:
            result.success = self._handler.updateNote(args.authenticationToken, args.note)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateNote", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteNote(self, seqid, iprot, oprot):
        args = deleteNote_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteNote_result()
        try:
            result.success = self._handler.deleteNote(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteNote", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_expungeNote(self, seqid, iprot, oprot):
        args = expungeNote_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = expungeNote_result()
        try:
            result.success = self._handler.expungeNote(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("expungeNote", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_copyNote(self, seqid, iprot, oprot):
        args = copyNote_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = copyNote_result()
        try:
            result.success = self._handler.copyNote(args.authenticationToken, args.noteGuid, args.toNotebookGuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("copyNote", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listNoteVersions(self, seqid, iprot, oprot):
        args = listNoteVersions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listNoteVersions_result()
        try:
            result.success = self._handler.listNoteVersions(args.authenticationToken, args.noteGuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listNoteVersions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNoteVersion(self, seqid, iprot, oprot):
        args = getNoteVersion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNoteVersion_result()
        try:
            result.success = self._handler.getNoteVersion(args.authenticationToken, args.noteGuid, args.updateSequenceNum, args.withResourcesData, args.withResourcesRecognition, args.withResourcesAlternateData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNoteVersion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getResource(self, seqid, iprot, oprot):
        args = getResource_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getResource_result()
        try:
            result.success = self._handler.getResource(args.authenticationToken, args.guid, args.withData, args.withRecognition, args.withAttributes, args.withAlternateData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getResource", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getResourceApplicationData(self, seqid, iprot, oprot):
        args = getResourceApplicationData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getResourceApplicationData_result()
        try:
            result.success = self._handler.getResourceApplicationData(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getResourceApplicationData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getResourceApplicationDataEntry(self, seqid, iprot, oprot):
        args = getResourceApplicationDataEntry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getResourceApplicationDataEntry_result()
        try:
            result.success = self._handler.getResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getResourceApplicationDataEntry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setResourceApplicationDataEntry(self, seqid, iprot, oprot):
        args = setResourceApplicationDataEntry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setResourceApplicationDataEntry_result()
        try:
            result.success = self._handler.setResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setResourceApplicationDataEntry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unsetResourceApplicationDataEntry(self, seqid, iprot, oprot):
        args = unsetResourceApplicationDataEntry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unsetResourceApplicationDataEntry_result()
        try:
            result.success = self._handler.unsetResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("unsetResourceApplicationDataEntry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateResource(self, seqid, iprot, oprot):
        args = updateResource_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateResource_result()
        try:
            result.success = self._handler.updateResource(args.authenticationToken, args.resource)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateResource", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getResourceData(self, seqid, iprot, oprot):
        args = getResourceData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getResourceData_result()
        try:
            result.success = self._handler.getResourceData(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getResourceData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getResourceByHash(self, seqid, iprot, oprot):
        args = getResourceByHash_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getResourceByHash_result()
        try:
            result.success = self._handler.getResourceByHash(args.authenticationToken, args.noteGuid, args.contentHash, args.withData, args.withRecognition, args.withAlternateData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getResourceByHash", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getResourceRecognition(self, seqid, iprot, oprot):
        args = getResourceRecognition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getResourceRecognition_result()
        try:
            result.success = self._handler.getResourceRecognition(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getResourceRecognition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getResourceAlternateData(self, seqid, iprot, oprot):
        args = getResourceAlternateData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getResourceAlternateData_result()
        try:
            result.success = self._handler.getResourceAlternateData(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getResourceAlternateData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getResourceAttributes(self, seqid, iprot, oprot):
        args = getResourceAttributes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getResourceAttributes_result()
        try:
            result.success = self._handler.getResourceAttributes(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getResourceAttributes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPublicNotebook(self, seqid, iprot, oprot):
        args = getPublicNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPublicNotebook_result()
        try:
            result.success = self._handler.getPublicNotebook(args.userId, args.publicUri)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPublicNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shareNotebook(self, seqid, iprot, oprot):
        args = shareNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shareNotebook_result()
        try:
            result.success = self._handler.shareNotebook(args.authenticationToken, args.sharedNotebook, args.message)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shareNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createOrUpdateNotebookShares(self, seqid, iprot, oprot):
        args = createOrUpdateNotebookShares_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createOrUpdateNotebookShares_result()
        try:
            result.success = self._handler.createOrUpdateNotebookShares(args.authenticationToken, args.shareTemplate)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMInvalidContactsException as invalidContactsException:
            msg_type = TMessageType.REPLY
            result.invalidContactsException = invalidContactsException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createOrUpdateNotebookShares", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateSharedNotebook(self, seqid, iprot, oprot):
        args = updateSharedNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateSharedNotebook_result()
        try:
            result.success = self._handler.updateSharedNotebook(args.authenticationToken, args.sharedNotebook)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateSharedNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setNotebookRecipientSettings(self, seqid, iprot, oprot):
        args = setNotebookRecipientSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setNotebookRecipientSettings_result()
        try:
            result.success = self._handler.setNotebookRecipientSettings(args.authenticationToken, args.notebookGuid, args.recipientSettings)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setNotebookRecipientSettings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listSharedNotebooks(self, seqid, iprot, oprot):
        args = listSharedNotebooks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listSharedNotebooks_result()
        try:
            result.success = self._handler.listSharedNotebooks(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listSharedNotebooks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createLinkedNotebook(self, seqid, iprot, oprot):
        args = createLinkedNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createLinkedNotebook_result()
        try:
            result.success = self._handler.createLinkedNotebook(args.authenticationToken, args.linkedNotebook)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createLinkedNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateLinkedNotebook(self, seqid, iprot, oprot):
        args = updateLinkedNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateLinkedNotebook_result()
        try:
            result.success = self._handler.updateLinkedNotebook(args.authenticationToken, args.linkedNotebook)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateLinkedNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listLinkedNotebooks(self, seqid, iprot, oprot):
        args = listLinkedNotebooks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listLinkedNotebooks_result()
        try:
            result.success = self._handler.listLinkedNotebooks(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listLinkedNotebooks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_expungeLinkedNotebook(self, seqid, iprot, oprot):
        args = expungeLinkedNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = expungeLinkedNotebook_result()
        try:
            result.success = self._handler.expungeLinkedNotebook(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("expungeLinkedNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_authenticateToSharedNotebook(self, seqid, iprot, oprot):
        args = authenticateToSharedNotebook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = authenticateToSharedNotebook_result()
        try:
            result.success = self._handler.authenticateToSharedNotebook(args.shareKeyOrGlobalId, args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("authenticateToSharedNotebook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSharedNotebookByAuth(self, seqid, iprot, oprot):
        args = getSharedNotebookByAuth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSharedNotebookByAuth_result()
        try:
            result.success = self._handler.getSharedNotebookByAuth(args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSharedNotebookByAuth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_emailNote(self, seqid, iprot, oprot):
        args = emailNote_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = emailNote_result()
        try:
            self._handler.emailNote(args.authenticationToken, args.parameters)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("emailNote", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shareNote(self, seqid, iprot, oprot):
        args = shareNote_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shareNote_result()
        try:
            result.success = self._handler.shareNote(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shareNote", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stopSharingNote(self, seqid, iprot, oprot):
        args = stopSharingNote_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stopSharingNote_result()
        try:
            self._handler.stopSharingNote(args.authenticationToken, args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stopSharingNote", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_authenticateToSharedNote(self, seqid, iprot, oprot):
        args = authenticateToSharedNote_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = authenticateToSharedNote_result()
        try:
            result.success = self._handler.authenticateToSharedNote(args.guid, args.noteKey, args.authenticationToken)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("authenticateToSharedNote", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findRelated(self, seqid, iprot, oprot):
        args = findRelated_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findRelated_result()
        try:
            result.success = self._handler.findRelated(args.authenticationToken, args.query, args.resultSpec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findRelated", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateNoteIfUsnMatches(self, seqid, iprot, oprot):
        args = updateNoteIfUsnMatches_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateNoteIfUsnMatches_result()
        try:
            result.success = self._handler.updateNoteIfUsnMatches(args.authenticationToken, args.note)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateNoteIfUsnMatches", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_manageNotebookShares(self, seqid, iprot, oprot):
        args = manageNotebookShares_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = manageNotebookShares_result()
        try:
            result.success = self._handler.manageNotebookShares(args.authenticationToken, args.parameters)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("manageNotebookShares", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNotebookShares(self, seqid, iprot, oprot):
        args = getNotebookShares_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNotebookShares_result()
        try:
            result.success = self._handler.getNotebookShares(args.authenticationToken, args.notebookGuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except evernote2.edam.error.ttypes.EDAMUserException as userException:
            msg_type = TMessageType.REPLY
            result.userException = userException
        except evernote2.edam.error.ttypes.EDAMNotFoundException as notFoundException:
            msg_type = TMessageType.REPLY
            result.notFoundException = notFoundException
        except evernote2.edam.error.ttypes.EDAMSystemException as systemException:
            msg_type = TMessageType.REPLY
            result.systemException = systemException
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNotebookShares", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getSyncState_args(object):
    """
    Attributes:
     - authenticationToken
    """


    def __init__(self, authenticationToken=None,):
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSyncState_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSyncState_args)
getSyncState_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class getSyncState_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
    """


    def __init__(self, success=None, userException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SyncState()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSyncState_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSyncState_result)
getSyncState_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SyncState, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class getFilteredSyncChunk_args(object):
    """
    Attributes:
     - authenticationToken
     - afterUSN
     - maxEntries
     - filter
    """


    def __init__(self, authenticationToken=None, afterUSN=None, maxEntries=None, filter=None,):
        self.authenticationToken = authenticationToken
        self.afterUSN = afterUSN
        self.maxEntries = maxEntries
        self.filter = filter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.afterUSN = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.maxEntries = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.filter = SyncChunkFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFilteredSyncChunk_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.afterUSN is not None:
            oprot.writeFieldBegin('afterUSN', TType.I32, 2)
            oprot.writeI32(self.afterUSN)
            oprot.writeFieldEnd()
        if self.maxEntries is not None:
            oprot.writeFieldBegin('maxEntries', TType.I32, 3)
            oprot.writeI32(self.maxEntries)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 4)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFilteredSyncChunk_args)
getFilteredSyncChunk_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.I32, 'afterUSN', None, None, ),  # 2
    (3, TType.I32, 'maxEntries', None, None, ),  # 3
    (4, TType.STRUCT, 'filter', [SyncChunkFilter, None], None, ),  # 4
)


class getFilteredSyncChunk_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
    """


    def __init__(self, success=None, userException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SyncChunk()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFilteredSyncChunk_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFilteredSyncChunk_result)
getFilteredSyncChunk_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SyncChunk, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class getLinkedNotebookSyncState_args(object):
    """
    Attributes:
     - authenticationToken
     - linkedNotebook
    """


    def __init__(self, authenticationToken=None, linkedNotebook=None,):
        self.authenticationToken = authenticationToken
        self.linkedNotebook = linkedNotebook

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.linkedNotebook = evernote2.edam.type.ttypes.LinkedNotebook()
                    self.linkedNotebook.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLinkedNotebookSyncState_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.linkedNotebook is not None:
            oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
            self.linkedNotebook.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLinkedNotebookSyncState_args)
getLinkedNotebookSyncState_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'linkedNotebook', [evernote2.edam.type.ttypes.LinkedNotebook, None], None, ),  # 2
)


class getLinkedNotebookSyncState_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SyncState()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLinkedNotebookSyncState_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLinkedNotebookSyncState_result)
getLinkedNotebookSyncState_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SyncState, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getLinkedNotebookSyncChunk_args(object):
    """
    Attributes:
     - authenticationToken
     - linkedNotebook
     - afterUSN
     - maxEntries
     - fullSyncOnly
    """


    def __init__(self, authenticationToken=None, linkedNotebook=None, afterUSN=None, maxEntries=None, fullSyncOnly=None,):
        self.authenticationToken = authenticationToken
        self.linkedNotebook = linkedNotebook
        self.afterUSN = afterUSN
        self.maxEntries = maxEntries
        self.fullSyncOnly = fullSyncOnly

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.linkedNotebook = evernote2.edam.type.ttypes.LinkedNotebook()
                    self.linkedNotebook.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.afterUSN = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maxEntries = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.fullSyncOnly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLinkedNotebookSyncChunk_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.linkedNotebook is not None:
            oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
            self.linkedNotebook.write(oprot)
            oprot.writeFieldEnd()
        if self.afterUSN is not None:
            oprot.writeFieldBegin('afterUSN', TType.I32, 3)
            oprot.writeI32(self.afterUSN)
            oprot.writeFieldEnd()
        if self.maxEntries is not None:
            oprot.writeFieldBegin('maxEntries', TType.I32, 4)
            oprot.writeI32(self.maxEntries)
            oprot.writeFieldEnd()
        if self.fullSyncOnly is not None:
            oprot.writeFieldBegin('fullSyncOnly', TType.BOOL, 5)
            oprot.writeBool(self.fullSyncOnly)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLinkedNotebookSyncChunk_args)
getLinkedNotebookSyncChunk_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'linkedNotebook', [evernote2.edam.type.ttypes.LinkedNotebook, None], None, ),  # 2
    (3, TType.I32, 'afterUSN', None, None, ),  # 3
    (4, TType.I32, 'maxEntries', None, None, ),  # 4
    (5, TType.BOOL, 'fullSyncOnly', None, None, ),  # 5
)


class getLinkedNotebookSyncChunk_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SyncChunk()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLinkedNotebookSyncChunk_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLinkedNotebookSyncChunk_result)
getLinkedNotebookSyncChunk_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SyncChunk, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class listNotebooks_args(object):
    """
    Attributes:
     - authenticationToken
    """


    def __init__(self, authenticationToken=None,):
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listNotebooks_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listNotebooks_args)
listNotebooks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class listNotebooks_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
    """


    def __init__(self, success=None, userException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype336, _size333) = iprot.readListBegin()
                    for _i337 in range(_size333):
                        _elem338 = evernote2.edam.type.ttypes.Notebook()
                        _elem338.read(iprot)
                        self.success.append(_elem338)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listNotebooks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter339 in self.success:
                iter339.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listNotebooks_result)
listNotebooks_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [evernote2.edam.type.ttypes.Notebook, None], False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class listAccessibleBusinessNotebooks_args(object):
    """
    Attributes:
     - authenticationToken
    """


    def __init__(self, authenticationToken=None,):
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listAccessibleBusinessNotebooks_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listAccessibleBusinessNotebooks_args)
listAccessibleBusinessNotebooks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class listAccessibleBusinessNotebooks_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
    """


    def __init__(self, success=None, userException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype343, _size340) = iprot.readListBegin()
                    for _i344 in range(_size340):
                        _elem345 = evernote2.edam.type.ttypes.Notebook()
                        _elem345.read(iprot)
                        self.success.append(_elem345)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listAccessibleBusinessNotebooks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter346 in self.success:
                iter346.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listAccessibleBusinessNotebooks_result)
listAccessibleBusinessNotebooks_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [evernote2.edam.type.ttypes.Notebook, None], False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class getNotebook_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNotebook_args)
getNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Notebook()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNotebook_result)
getNotebook_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Notebook, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getDefaultNotebook_args(object):
    """
    Attributes:
     - authenticationToken
    """


    def __init__(self, authenticationToken=None,):
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDefaultNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDefaultNotebook_args)
getDefaultNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class getDefaultNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
    """


    def __init__(self, success=None, userException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Notebook()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDefaultNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDefaultNotebook_result)
getDefaultNotebook_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Notebook, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class createNotebook_args(object):
    """
    Attributes:
     - authenticationToken
     - notebook
    """


    def __init__(self, authenticationToken=None, notebook=None,):
        self.authenticationToken = authenticationToken
        self.notebook = notebook

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notebook = evernote2.edam.type.ttypes.Notebook()
                    self.notebook.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.notebook is not None:
            oprot.writeFieldBegin('notebook', TType.STRUCT, 2)
            self.notebook.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createNotebook_args)
createNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'notebook', [evernote2.edam.type.ttypes.Notebook, None], None, ),  # 2
)


class createNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
    """


    def __init__(self, success=None, userException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Notebook()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createNotebook_result)
createNotebook_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Notebook, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class updateNotebook_args(object):
    """
    Attributes:
     - authenticationToken
     - notebook
    """


    def __init__(self, authenticationToken=None, notebook=None,):
        self.authenticationToken = authenticationToken
        self.notebook = notebook

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notebook = evernote2.edam.type.ttypes.Notebook()
                    self.notebook.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.notebook is not None:
            oprot.writeFieldBegin('notebook', TType.STRUCT, 2)
            self.notebook.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateNotebook_args)
updateNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'notebook', [evernote2.edam.type.ttypes.Notebook, None], None, ),  # 2
)


class updateNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateNotebook_result)
updateNotebook_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class expungeNotebook_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expungeNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expungeNotebook_args)
expungeNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class expungeNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expungeNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expungeNotebook_result)
expungeNotebook_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class listTags_args(object):
    """
    Attributes:
     - authenticationToken
    """


    def __init__(self, authenticationToken=None,):
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listTags_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listTags_args)
listTags_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class listTags_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
    """


    def __init__(self, success=None, userException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype350, _size347) = iprot.readListBegin()
                    for _i351 in range(_size347):
                        _elem352 = evernote2.edam.type.ttypes.Tag()
                        _elem352.read(iprot)
                        self.success.append(_elem352)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listTags_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter353 in self.success:
                iter353.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listTags_result)
listTags_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [evernote2.edam.type.ttypes.Tag, None], False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class listTagsByNotebook_args(object):
    """
    Attributes:
     - authenticationToken
     - notebookGuid
    """


    def __init__(self, authenticationToken=None, notebookGuid=None,):
        self.authenticationToken = authenticationToken
        self.notebookGuid = notebookGuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.notebookGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listTagsByNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.notebookGuid is not None:
            oprot.writeFieldBegin('notebookGuid', TType.STRING, 2)
            oprot.writeString(self.notebookGuid.encode('utf-8') if sys.version_info[0] == 2 else self.notebookGuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listTagsByNotebook_args)
listTagsByNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'notebookGuid', 'UTF8', None, ),  # 2
)


class listTagsByNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype357, _size354) = iprot.readListBegin()
                    for _i358 in range(_size354):
                        _elem359 = evernote2.edam.type.ttypes.Tag()
                        _elem359.read(iprot)
                        self.success.append(_elem359)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listTagsByNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter360 in self.success:
                iter360.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listTagsByNotebook_result)
listTagsByNotebook_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [evernote2.edam.type.ttypes.Tag, None], False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getTag_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTag_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTag_args)
getTag_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getTag_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Tag()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTag_result)
getTag_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Tag, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class createTag_args(object):
    """
    Attributes:
     - authenticationToken
     - tag
    """


    def __init__(self, authenticationToken=None, tag=None,):
        self.authenticationToken = authenticationToken
        self.tag = tag

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.tag = evernote2.edam.type.ttypes.Tag()
                    self.tag.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createTag_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRUCT, 2)
            self.tag.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createTag_args)
createTag_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'tag', [evernote2.edam.type.ttypes.Tag, None], None, ),  # 2
)


class createTag_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Tag()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createTag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createTag_result)
createTag_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Tag, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class updateTag_args(object):
    """
    Attributes:
     - authenticationToken
     - tag
    """


    def __init__(self, authenticationToken=None, tag=None,):
        self.authenticationToken = authenticationToken
        self.tag = tag

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.tag = evernote2.edam.type.ttypes.Tag()
                    self.tag.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateTag_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRUCT, 2)
            self.tag.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateTag_args)
updateTag_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'tag', [evernote2.edam.type.ttypes.Tag, None], None, ),  # 2
)


class updateTag_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateTag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateTag_result)
updateTag_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class untagAll_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('untagAll_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(untagAll_args)
untagAll_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class untagAll_result(object):
    """
    Attributes:
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, userException=None, systemException=None, notFoundException=None,):
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('untagAll_result')
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(untagAll_result)
untagAll_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class expungeTag_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expungeTag_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expungeTag_args)
expungeTag_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class expungeTag_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expungeTag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expungeTag_result)
expungeTag_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class listSearches_args(object):
    """
    Attributes:
     - authenticationToken
    """


    def __init__(self, authenticationToken=None,):
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listSearches_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listSearches_args)
listSearches_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class listSearches_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
    """


    def __init__(self, success=None, userException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype364, _size361) = iprot.readListBegin()
                    for _i365 in range(_size361):
                        _elem366 = evernote2.edam.type.ttypes.SavedSearch()
                        _elem366.read(iprot)
                        self.success.append(_elem366)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listSearches_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter367 in self.success:
                iter367.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listSearches_result)
listSearches_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [evernote2.edam.type.ttypes.SavedSearch, None], False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class getSearch_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSearch_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSearch_args)
getSearch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getSearch_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.SavedSearch()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSearch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSearch_result)
getSearch_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.SavedSearch, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class createSearch_args(object):
    """
    Attributes:
     - authenticationToken
     - search
    """


    def __init__(self, authenticationToken=None, search=None,):
        self.authenticationToken = authenticationToken
        self.search = search

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.search = evernote2.edam.type.ttypes.SavedSearch()
                    self.search.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createSearch_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.search is not None:
            oprot.writeFieldBegin('search', TType.STRUCT, 2)
            self.search.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createSearch_args)
createSearch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'search', [evernote2.edam.type.ttypes.SavedSearch, None], None, ),  # 2
)


class createSearch_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
    """


    def __init__(self, success=None, userException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.SavedSearch()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createSearch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createSearch_result)
createSearch_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.SavedSearch, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
)


class updateSearch_args(object):
    """
    Attributes:
     - authenticationToken
     - search
    """


    def __init__(self, authenticationToken=None, search=None,):
        self.authenticationToken = authenticationToken
        self.search = search

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.search = evernote2.edam.type.ttypes.SavedSearch()
                    self.search.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateSearch_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.search is not None:
            oprot.writeFieldBegin('search', TType.STRUCT, 2)
            self.search.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateSearch_args)
updateSearch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'search', [evernote2.edam.type.ttypes.SavedSearch, None], None, ),  # 2
)


class updateSearch_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateSearch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateSearch_result)
updateSearch_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class expungeSearch_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expungeSearch_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expungeSearch_args)
expungeSearch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class expungeSearch_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expungeSearch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expungeSearch_result)
expungeSearch_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class findNoteOffset_args(object):
    """
    Attributes:
     - authenticationToken
     - filter
     - guid
    """


    def __init__(self, authenticationToken=None, filter=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.filter = filter
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.filter = NoteFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findNoteOffset_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 2)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 3)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findNoteOffset_args)
findNoteOffset_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'filter', [NoteFilter, None], None, ),  # 2
    (3, TType.STRING, 'guid', 'UTF8', None, ),  # 3
)


class findNoteOffset_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findNoteOffset_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findNoteOffset_result)
findNoteOffset_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class findNotesMetadata_args(object):
    """
    Attributes:
     - authenticationToken
     - filter
     - offset
     - maxNotes
     - resultSpec
    """


    def __init__(self, authenticationToken=None, filter=None, offset=None, maxNotes=None, resultSpec=None,):
        self.authenticationToken = authenticationToken
        self.filter = filter
        self.offset = offset
        self.maxNotes = maxNotes
        self.resultSpec = resultSpec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.filter = NoteFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maxNotes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.resultSpec = NotesMetadataResultSpec()
                    self.resultSpec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findNotesMetadata_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 2)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 3)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.maxNotes is not None:
            oprot.writeFieldBegin('maxNotes', TType.I32, 4)
            oprot.writeI32(self.maxNotes)
            oprot.writeFieldEnd()
        if self.resultSpec is not None:
            oprot.writeFieldBegin('resultSpec', TType.STRUCT, 5)
            self.resultSpec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findNotesMetadata_args)
findNotesMetadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'filter', [NoteFilter, None], None, ),  # 2
    (3, TType.I32, 'offset', None, None, ),  # 3
    (4, TType.I32, 'maxNotes', None, None, ),  # 4
    (5, TType.STRUCT, 'resultSpec', [NotesMetadataResultSpec, None], None, ),  # 5
)


class findNotesMetadata_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NotesMetadataList()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findNotesMetadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findNotesMetadata_result)
findNotesMetadata_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NotesMetadataList, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class findNoteCounts_args(object):
    """
    Attributes:
     - authenticationToken
     - filter
     - withTrash
    """


    def __init__(self, authenticationToken=None, filter=None, withTrash=None,):
        self.authenticationToken = authenticationToken
        self.filter = filter
        self.withTrash = withTrash

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.filter = NoteFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.withTrash = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findNoteCounts_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 2)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        if self.withTrash is not None:
            oprot.writeFieldBegin('withTrash', TType.BOOL, 3)
            oprot.writeBool(self.withTrash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findNoteCounts_args)
findNoteCounts_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'filter', [NoteFilter, None], None, ),  # 2
    (3, TType.BOOL, 'withTrash', None, None, ),  # 3
)


class findNoteCounts_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NoteCollectionCounts()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findNoteCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findNoteCounts_result)
findNoteCounts_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NoteCollectionCounts, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getNoteWithResultSpec_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
     - resultSpec
    """


    def __init__(self, authenticationToken=None, guid=None, resultSpec=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid
        self.resultSpec = resultSpec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.resultSpec = NoteResultSpec()
                    self.resultSpec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteWithResultSpec_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.resultSpec is not None:
            oprot.writeFieldBegin('resultSpec', TType.STRUCT, 3)
            self.resultSpec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteWithResultSpec_args)
getNoteWithResultSpec_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'resultSpec', [NoteResultSpec, None], None, ),  # 3
)


class getNoteWithResultSpec_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Note()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteWithResultSpec_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteWithResultSpec_result)
getNoteWithResultSpec_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Note, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getNote_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
     - withContent
     - withResourcesData
     - withResourcesRecognition
     - withResourcesAlternateData
    """


    def __init__(self, authenticationToken=None, guid=None, withContent=None, withResourcesData=None, withResourcesRecognition=None, withResourcesAlternateData=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid
        self.withContent = withContent
        self.withResourcesData = withResourcesData
        self.withResourcesRecognition = withResourcesRecognition
        self.withResourcesAlternateData = withResourcesAlternateData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.withContent = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.withResourcesData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.withResourcesRecognition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.withResourcesAlternateData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNote_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.withContent is not None:
            oprot.writeFieldBegin('withContent', TType.BOOL, 3)
            oprot.writeBool(self.withContent)
            oprot.writeFieldEnd()
        if self.withResourcesData is not None:
            oprot.writeFieldBegin('withResourcesData', TType.BOOL, 4)
            oprot.writeBool(self.withResourcesData)
            oprot.writeFieldEnd()
        if self.withResourcesRecognition is not None:
            oprot.writeFieldBegin('withResourcesRecognition', TType.BOOL, 5)
            oprot.writeBool(self.withResourcesRecognition)
            oprot.writeFieldEnd()
        if self.withResourcesAlternateData is not None:
            oprot.writeFieldBegin('withResourcesAlternateData', TType.BOOL, 6)
            oprot.writeBool(self.withResourcesAlternateData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNote_args)
getNote_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'withContent', None, None, ),  # 3
    (4, TType.BOOL, 'withResourcesData', None, None, ),  # 4
    (5, TType.BOOL, 'withResourcesRecognition', None, None, ),  # 5
    (6, TType.BOOL, 'withResourcesAlternateData', None, None, ),  # 6
)


class getNote_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Note()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNote_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNote_result)
getNote_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Note, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getNoteApplicationData_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteApplicationData_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteApplicationData_args)
getNoteApplicationData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getNoteApplicationData_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.LazyMap()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteApplicationData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteApplicationData_result)
getNoteApplicationData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.LazyMap, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getNoteApplicationDataEntry_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
     - key
    """


    def __init__(self, authenticationToken=None, guid=None, key=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteApplicationDataEntry_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 3)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteApplicationDataEntry_args)
getNoteApplicationDataEntry_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'key', 'UTF8', None, ),  # 3
)


class getNoteApplicationDataEntry_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteApplicationDataEntry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteApplicationDataEntry_result)
getNoteApplicationDataEntry_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class setNoteApplicationDataEntry_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
     - key
     - value
    """


    def __init__(self, authenticationToken=None, guid=None, key=None, value=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setNoteApplicationDataEntry_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 3)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 4)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setNoteApplicationDataEntry_args)
setNoteApplicationDataEntry_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'key', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
)


class setNoteApplicationDataEntry_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setNoteApplicationDataEntry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setNoteApplicationDataEntry_result)
setNoteApplicationDataEntry_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class unsetNoteApplicationDataEntry_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
     - key
    """


    def __init__(self, authenticationToken=None, guid=None, key=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unsetNoteApplicationDataEntry_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 3)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unsetNoteApplicationDataEntry_args)
unsetNoteApplicationDataEntry_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'key', 'UTF8', None, ),  # 3
)


class unsetNoteApplicationDataEntry_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unsetNoteApplicationDataEntry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unsetNoteApplicationDataEntry_result)
unsetNoteApplicationDataEntry_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getNoteContent_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteContent_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteContent_args)
getNoteContent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getNoteContent_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteContent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteContent_result)
getNoteContent_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getNoteSearchText_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
     - noteOnly
     - tokenizeForIndexing
    """


    def __init__(self, authenticationToken=None, guid=None, noteOnly=None, tokenizeForIndexing=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid
        self.noteOnly = noteOnly
        self.tokenizeForIndexing = tokenizeForIndexing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.noteOnly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.tokenizeForIndexing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteSearchText_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.noteOnly is not None:
            oprot.writeFieldBegin('noteOnly', TType.BOOL, 3)
            oprot.writeBool(self.noteOnly)
            oprot.writeFieldEnd()
        if self.tokenizeForIndexing is not None:
            oprot.writeFieldBegin('tokenizeForIndexing', TType.BOOL, 4)
            oprot.writeBool(self.tokenizeForIndexing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteSearchText_args)
getNoteSearchText_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'noteOnly', None, None, ),  # 3
    (4, TType.BOOL, 'tokenizeForIndexing', None, None, ),  # 4
)


class getNoteSearchText_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteSearchText_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteSearchText_result)
getNoteSearchText_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getResourceSearchText_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceSearchText_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceSearchText_args)
getResourceSearchText_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getResourceSearchText_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceSearchText_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceSearchText_result)
getResourceSearchText_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getNoteTagNames_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteTagNames_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteTagNames_args)
getNoteTagNames_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getNoteTagNames_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype371, _size368) = iprot.readListBegin()
                    for _i372 in range(_size368):
                        _elem373 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem373)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteTagNames_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter374 in self.success:
                oprot.writeString(iter374.encode('utf-8') if sys.version_info[0] == 2 else iter374)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteTagNames_result)
getNoteTagNames_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class createNote_args(object):
    """
    Attributes:
     - authenticationToken
     - note
    """


    def __init__(self, authenticationToken=None, note=None,):
        self.authenticationToken = authenticationToken
        self.note = note

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.note = evernote2.edam.type.ttypes.Note()
                    self.note.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createNote_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.note is not None:
            oprot.writeFieldBegin('note', TType.STRUCT, 2)
            self.note.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createNote_args)
createNote_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'note', [evernote2.edam.type.ttypes.Note, None], None, ),  # 2
)


class createNote_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Note()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createNote_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createNote_result)
createNote_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Note, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class updateNote_args(object):
    """
    Attributes:
     - authenticationToken
     - note
    """


    def __init__(self, authenticationToken=None, note=None,):
        self.authenticationToken = authenticationToken
        self.note = note

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.note = evernote2.edam.type.ttypes.Note()
                    self.note.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateNote_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.note is not None:
            oprot.writeFieldBegin('note', TType.STRUCT, 2)
            self.note.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateNote_args)
updateNote_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'note', [evernote2.edam.type.ttypes.Note, None], None, ),  # 2
)


class updateNote_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Note()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateNote_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateNote_result)
updateNote_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Note, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class deleteNote_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteNote_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteNote_args)
deleteNote_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class deleteNote_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteNote_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteNote_result)
deleteNote_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class expungeNote_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expungeNote_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expungeNote_args)
expungeNote_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class expungeNote_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expungeNote_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expungeNote_result)
expungeNote_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class copyNote_args(object):
    """
    Attributes:
     - authenticationToken
     - noteGuid
     - toNotebookGuid
    """


    def __init__(self, authenticationToken=None, noteGuid=None, toNotebookGuid=None,):
        self.authenticationToken = authenticationToken
        self.noteGuid = noteGuid
        self.toNotebookGuid = toNotebookGuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.noteGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.toNotebookGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('copyNote_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.noteGuid is not None:
            oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
            oprot.writeString(self.noteGuid.encode('utf-8') if sys.version_info[0] == 2 else self.noteGuid)
            oprot.writeFieldEnd()
        if self.toNotebookGuid is not None:
            oprot.writeFieldBegin('toNotebookGuid', TType.STRING, 3)
            oprot.writeString(self.toNotebookGuid.encode('utf-8') if sys.version_info[0] == 2 else self.toNotebookGuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(copyNote_args)
copyNote_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'noteGuid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'toNotebookGuid', 'UTF8', None, ),  # 3
)


class copyNote_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Note()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('copyNote_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(copyNote_result)
copyNote_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Note, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class listNoteVersions_args(object):
    """
    Attributes:
     - authenticationToken
     - noteGuid
    """


    def __init__(self, authenticationToken=None, noteGuid=None,):
        self.authenticationToken = authenticationToken
        self.noteGuid = noteGuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.noteGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listNoteVersions_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.noteGuid is not None:
            oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
            oprot.writeString(self.noteGuid.encode('utf-8') if sys.version_info[0] == 2 else self.noteGuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listNoteVersions_args)
listNoteVersions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'noteGuid', 'UTF8', None, ),  # 2
)


class listNoteVersions_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype378, _size375) = iprot.readListBegin()
                    for _i379 in range(_size375):
                        _elem380 = NoteVersionId()
                        _elem380.read(iprot)
                        self.success.append(_elem380)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listNoteVersions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter381 in self.success:
                iter381.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listNoteVersions_result)
listNoteVersions_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NoteVersionId, None], False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getNoteVersion_args(object):
    """
    Attributes:
     - authenticationToken
     - noteGuid
     - updateSequenceNum
     - withResourcesData
     - withResourcesRecognition
     - withResourcesAlternateData
    """


    def __init__(self, authenticationToken=None, noteGuid=None, updateSequenceNum=None, withResourcesData=None, withResourcesRecognition=None, withResourcesAlternateData=None,):
        self.authenticationToken = authenticationToken
        self.noteGuid = noteGuid
        self.updateSequenceNum = updateSequenceNum
        self.withResourcesData = withResourcesData
        self.withResourcesRecognition = withResourcesRecognition
        self.withResourcesAlternateData = withResourcesAlternateData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.noteGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.updateSequenceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.withResourcesData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.withResourcesRecognition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.withResourcesAlternateData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteVersion_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.noteGuid is not None:
            oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
            oprot.writeString(self.noteGuid.encode('utf-8') if sys.version_info[0] == 2 else self.noteGuid)
            oprot.writeFieldEnd()
        if self.updateSequenceNum is not None:
            oprot.writeFieldBegin('updateSequenceNum', TType.I32, 3)
            oprot.writeI32(self.updateSequenceNum)
            oprot.writeFieldEnd()
        if self.withResourcesData is not None:
            oprot.writeFieldBegin('withResourcesData', TType.BOOL, 4)
            oprot.writeBool(self.withResourcesData)
            oprot.writeFieldEnd()
        if self.withResourcesRecognition is not None:
            oprot.writeFieldBegin('withResourcesRecognition', TType.BOOL, 5)
            oprot.writeBool(self.withResourcesRecognition)
            oprot.writeFieldEnd()
        if self.withResourcesAlternateData is not None:
            oprot.writeFieldBegin('withResourcesAlternateData', TType.BOOL, 6)
            oprot.writeBool(self.withResourcesAlternateData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteVersion_args)
getNoteVersion_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'noteGuid', 'UTF8', None, ),  # 2
    (3, TType.I32, 'updateSequenceNum', None, None, ),  # 3
    (4, TType.BOOL, 'withResourcesData', None, None, ),  # 4
    (5, TType.BOOL, 'withResourcesRecognition', None, None, ),  # 5
    (6, TType.BOOL, 'withResourcesAlternateData', None, None, ),  # 6
)


class getNoteVersion_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Note()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNoteVersion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNoteVersion_result)
getNoteVersion_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Note, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getResource_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
     - withData
     - withRecognition
     - withAttributes
     - withAlternateData
    """


    def __init__(self, authenticationToken=None, guid=None, withData=None, withRecognition=None, withAttributes=None, withAlternateData=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid
        self.withData = withData
        self.withRecognition = withRecognition
        self.withAttributes = withAttributes
        self.withAlternateData = withAlternateData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.withData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.withRecognition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.withAttributes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.withAlternateData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResource_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.withData is not None:
            oprot.writeFieldBegin('withData', TType.BOOL, 3)
            oprot.writeBool(self.withData)
            oprot.writeFieldEnd()
        if self.withRecognition is not None:
            oprot.writeFieldBegin('withRecognition', TType.BOOL, 4)
            oprot.writeBool(self.withRecognition)
            oprot.writeFieldEnd()
        if self.withAttributes is not None:
            oprot.writeFieldBegin('withAttributes', TType.BOOL, 5)
            oprot.writeBool(self.withAttributes)
            oprot.writeFieldEnd()
        if self.withAlternateData is not None:
            oprot.writeFieldBegin('withAlternateData', TType.BOOL, 6)
            oprot.writeBool(self.withAlternateData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResource_args)
getResource_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'withData', None, None, ),  # 3
    (4, TType.BOOL, 'withRecognition', None, None, ),  # 4
    (5, TType.BOOL, 'withAttributes', None, None, ),  # 5
    (6, TType.BOOL, 'withAlternateData', None, None, ),  # 6
)


class getResource_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Resource()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResource_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResource_result)
getResource_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Resource, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getResourceApplicationData_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceApplicationData_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceApplicationData_args)
getResourceApplicationData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getResourceApplicationData_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.LazyMap()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceApplicationData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceApplicationData_result)
getResourceApplicationData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.LazyMap, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getResourceApplicationDataEntry_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
     - key
    """


    def __init__(self, authenticationToken=None, guid=None, key=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceApplicationDataEntry_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 3)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceApplicationDataEntry_args)
getResourceApplicationDataEntry_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'key', 'UTF8', None, ),  # 3
)


class getResourceApplicationDataEntry_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceApplicationDataEntry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceApplicationDataEntry_result)
getResourceApplicationDataEntry_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class setResourceApplicationDataEntry_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
     - key
     - value
    """


    def __init__(self, authenticationToken=None, guid=None, key=None, value=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setResourceApplicationDataEntry_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 3)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 4)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setResourceApplicationDataEntry_args)
setResourceApplicationDataEntry_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'key', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
)


class setResourceApplicationDataEntry_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setResourceApplicationDataEntry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setResourceApplicationDataEntry_result)
setResourceApplicationDataEntry_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class unsetResourceApplicationDataEntry_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
     - key
    """


    def __init__(self, authenticationToken=None, guid=None, key=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unsetResourceApplicationDataEntry_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 3)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unsetResourceApplicationDataEntry_args)
unsetResourceApplicationDataEntry_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'key', 'UTF8', None, ),  # 3
)


class unsetResourceApplicationDataEntry_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unsetResourceApplicationDataEntry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unsetResourceApplicationDataEntry_result)
unsetResourceApplicationDataEntry_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class updateResource_args(object):
    """
    Attributes:
     - authenticationToken
     - resource
    """


    def __init__(self, authenticationToken=None, resource=None,):
        self.authenticationToken = authenticationToken
        self.resource = resource

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.resource = evernote2.edam.type.ttypes.Resource()
                    self.resource.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateResource_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.resource is not None:
            oprot.writeFieldBegin('resource', TType.STRUCT, 2)
            self.resource.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateResource_args)
updateResource_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'resource', [evernote2.edam.type.ttypes.Resource, None], None, ),  # 2
)


class updateResource_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateResource_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateResource_result)
updateResource_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getResourceData_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceData_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceData_args)
getResourceData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getResourceData_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceData_result)
getResourceData_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getResourceByHash_args(object):
    """
    Attributes:
     - authenticationToken
     - noteGuid
     - contentHash
     - withData
     - withRecognition
     - withAlternateData
    """


    def __init__(self, authenticationToken=None, noteGuid=None, contentHash=None, withData=None, withRecognition=None, withAlternateData=None,):
        self.authenticationToken = authenticationToken
        self.noteGuid = noteGuid
        self.contentHash = contentHash
        self.withData = withData
        self.withRecognition = withRecognition
        self.withAlternateData = withAlternateData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.noteGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.contentHash = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.withData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.withRecognition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.withAlternateData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceByHash_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.noteGuid is not None:
            oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
            oprot.writeString(self.noteGuid.encode('utf-8') if sys.version_info[0] == 2 else self.noteGuid)
            oprot.writeFieldEnd()
        if self.contentHash is not None:
            oprot.writeFieldBegin('contentHash', TType.STRING, 3)
            oprot.writeBinary(self.contentHash)
            oprot.writeFieldEnd()
        if self.withData is not None:
            oprot.writeFieldBegin('withData', TType.BOOL, 4)
            oprot.writeBool(self.withData)
            oprot.writeFieldEnd()
        if self.withRecognition is not None:
            oprot.writeFieldBegin('withRecognition', TType.BOOL, 5)
            oprot.writeBool(self.withRecognition)
            oprot.writeFieldEnd()
        if self.withAlternateData is not None:
            oprot.writeFieldBegin('withAlternateData', TType.BOOL, 6)
            oprot.writeBool(self.withAlternateData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceByHash_args)
getResourceByHash_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'noteGuid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'contentHash', 'BINARY', None, ),  # 3
    (4, TType.BOOL, 'withData', None, None, ),  # 4
    (5, TType.BOOL, 'withRecognition', None, None, ),  # 5
    (6, TType.BOOL, 'withAlternateData', None, None, ),  # 6
)


class getResourceByHash_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Resource()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceByHash_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceByHash_result)
getResourceByHash_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Resource, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getResourceRecognition_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceRecognition_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceRecognition_args)
getResourceRecognition_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getResourceRecognition_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceRecognition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceRecognition_result)
getResourceRecognition_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getResourceAlternateData_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceAlternateData_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceAlternateData_args)
getResourceAlternateData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getResourceAlternateData_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceAlternateData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceAlternateData_result)
getResourceAlternateData_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getResourceAttributes_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceAttributes_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceAttributes_args)
getResourceAttributes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class getResourceAttributes_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.ResourceAttributes()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResourceAttributes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResourceAttributes_result)
getResourceAttributes_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.ResourceAttributes, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class getPublicNotebook_args(object):
    """
    Attributes:
     - userId
     - publicUri
    """


    def __init__(self, userId=None, publicUri=None,):
        self.userId = userId
        self.publicUri = publicUri

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.userId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.publicUri = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPublicNotebook_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.I32, 1)
            oprot.writeI32(self.userId)
            oprot.writeFieldEnd()
        if self.publicUri is not None:
            oprot.writeFieldBegin('publicUri', TType.STRING, 2)
            oprot.writeString(self.publicUri.encode('utf-8') if sys.version_info[0] == 2 else self.publicUri)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPublicNotebook_args)
getPublicNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'userId', None, None, ),  # 1
    (2, TType.STRING, 'publicUri', 'UTF8', None, ),  # 2
)


class getPublicNotebook_result(object):
    """
    Attributes:
     - success
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, systemException=None, notFoundException=None,):
        self.success = success
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Notebook()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPublicNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 1)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPublicNotebook_result)
getPublicNotebook_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Notebook, None], None, ),  # 0
    (1, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
)


class shareNotebook_args(object):
    """
    Attributes:
     - authenticationToken
     - sharedNotebook
     - message
    """


    def __init__(self, authenticationToken=None, sharedNotebook=None, message=None,):
        self.authenticationToken = authenticationToken
        self.sharedNotebook = sharedNotebook
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sharedNotebook = evernote2.edam.type.ttypes.SharedNotebook()
                    self.sharedNotebook.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shareNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.sharedNotebook is not None:
            oprot.writeFieldBegin('sharedNotebook', TType.STRUCT, 2)
            self.sharedNotebook.write(oprot)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 3)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shareNotebook_args)
shareNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'sharedNotebook', [evernote2.edam.type.ttypes.SharedNotebook, None], None, ),  # 2
    (3, TType.STRING, 'message', 'UTF8', None, ),  # 3
)


class shareNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.SharedNotebook()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shareNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shareNotebook_result)
shareNotebook_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.SharedNotebook, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class createOrUpdateNotebookShares_args(object):
    """
    Attributes:
     - authenticationToken
     - shareTemplate
    """


    def __init__(self, authenticationToken=None, shareTemplate=None,):
        self.authenticationToken = authenticationToken
        self.shareTemplate = shareTemplate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.shareTemplate = NotebookShareTemplate()
                    self.shareTemplate.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createOrUpdateNotebookShares_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.shareTemplate is not None:
            oprot.writeFieldBegin('shareTemplate', TType.STRUCT, 2)
            self.shareTemplate.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createOrUpdateNotebookShares_args)
createOrUpdateNotebookShares_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'shareTemplate', [NotebookShareTemplate, None], None, ),  # 2
)


class createOrUpdateNotebookShares_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
     - invalidContactsException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None, invalidContactsException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException
        self.invalidContactsException = invalidContactsException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CreateOrUpdateNotebookSharesResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.invalidContactsException = evernote2.edam.error.ttypes.EDAMInvalidContactsException()
                    self.invalidContactsException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createOrUpdateNotebookShares_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.invalidContactsException is not None:
            oprot.writeFieldBegin('invalidContactsException', TType.STRUCT, 4)
            self.invalidContactsException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createOrUpdateNotebookShares_result)
createOrUpdateNotebookShares_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [CreateOrUpdateNotebookSharesResult, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
    (4, TType.STRUCT, 'invalidContactsException', [evernote2.edam.error.ttypes.EDAMInvalidContactsException, None], None, ),  # 4
)


class updateSharedNotebook_args(object):
    """
    Attributes:
     - authenticationToken
     - sharedNotebook
    """


    def __init__(self, authenticationToken=None, sharedNotebook=None,):
        self.authenticationToken = authenticationToken
        self.sharedNotebook = sharedNotebook

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sharedNotebook = evernote2.edam.type.ttypes.SharedNotebook()
                    self.sharedNotebook.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateSharedNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.sharedNotebook is not None:
            oprot.writeFieldBegin('sharedNotebook', TType.STRUCT, 2)
            self.sharedNotebook.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateSharedNotebook_args)
updateSharedNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'sharedNotebook', [evernote2.edam.type.ttypes.SharedNotebook, None], None, ),  # 2
)


class updateSharedNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateSharedNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateSharedNotebook_result)
updateSharedNotebook_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class setNotebookRecipientSettings_args(object):
    """
    Attributes:
     - authenticationToken
     - notebookGuid
     - recipientSettings
    """


    def __init__(self, authenticationToken=None, notebookGuid=None, recipientSettings=None,):
        self.authenticationToken = authenticationToken
        self.notebookGuid = notebookGuid
        self.recipientSettings = recipientSettings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.notebookGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.recipientSettings = evernote2.edam.type.ttypes.NotebookRecipientSettings()
                    self.recipientSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setNotebookRecipientSettings_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.notebookGuid is not None:
            oprot.writeFieldBegin('notebookGuid', TType.STRING, 2)
            oprot.writeString(self.notebookGuid.encode('utf-8') if sys.version_info[0] == 2 else self.notebookGuid)
            oprot.writeFieldEnd()
        if self.recipientSettings is not None:
            oprot.writeFieldBegin('recipientSettings', TType.STRUCT, 3)
            self.recipientSettings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setNotebookRecipientSettings_args)
setNotebookRecipientSettings_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'notebookGuid', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'recipientSettings', [evernote2.edam.type.ttypes.NotebookRecipientSettings, None], None, ),  # 3
)


class setNotebookRecipientSettings_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.Notebook()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setNotebookRecipientSettings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setNotebookRecipientSettings_result)
setNotebookRecipientSettings_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.Notebook, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class listSharedNotebooks_args(object):
    """
    Attributes:
     - authenticationToken
    """


    def __init__(self, authenticationToken=None,):
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listSharedNotebooks_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listSharedNotebooks_args)
listSharedNotebooks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class listSharedNotebooks_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype385, _size382) = iprot.readListBegin()
                    for _i386 in range(_size382):
                        _elem387 = evernote2.edam.type.ttypes.SharedNotebook()
                        _elem387.read(iprot)
                        self.success.append(_elem387)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listSharedNotebooks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter388 in self.success:
                iter388.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listSharedNotebooks_result)
listSharedNotebooks_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [evernote2.edam.type.ttypes.SharedNotebook, None], False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class createLinkedNotebook_args(object):
    """
    Attributes:
     - authenticationToken
     - linkedNotebook
    """


    def __init__(self, authenticationToken=None, linkedNotebook=None,):
        self.authenticationToken = authenticationToken
        self.linkedNotebook = linkedNotebook

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.linkedNotebook = evernote2.edam.type.ttypes.LinkedNotebook()
                    self.linkedNotebook.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createLinkedNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.linkedNotebook is not None:
            oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
            self.linkedNotebook.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createLinkedNotebook_args)
createLinkedNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'linkedNotebook', [evernote2.edam.type.ttypes.LinkedNotebook, None], None, ),  # 2
)


class createLinkedNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.LinkedNotebook()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createLinkedNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createLinkedNotebook_result)
createLinkedNotebook_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.LinkedNotebook, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class updateLinkedNotebook_args(object):
    """
    Attributes:
     - authenticationToken
     - linkedNotebook
    """


    def __init__(self, authenticationToken=None, linkedNotebook=None,):
        self.authenticationToken = authenticationToken
        self.linkedNotebook = linkedNotebook

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.linkedNotebook = evernote2.edam.type.ttypes.LinkedNotebook()
                    self.linkedNotebook.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateLinkedNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.linkedNotebook is not None:
            oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
            self.linkedNotebook.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateLinkedNotebook_args)
updateLinkedNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'linkedNotebook', [evernote2.edam.type.ttypes.LinkedNotebook, None], None, ),  # 2
)


class updateLinkedNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateLinkedNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateLinkedNotebook_result)
updateLinkedNotebook_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class listLinkedNotebooks_args(object):
    """
    Attributes:
     - authenticationToken
    """


    def __init__(self, authenticationToken=None,):
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listLinkedNotebooks_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listLinkedNotebooks_args)
listLinkedNotebooks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class listLinkedNotebooks_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype392, _size389) = iprot.readListBegin()
                    for _i393 in range(_size389):
                        _elem394 = evernote2.edam.type.ttypes.LinkedNotebook()
                        _elem394.read(iprot)
                        self.success.append(_elem394)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listLinkedNotebooks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter395 in self.success:
                iter395.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listLinkedNotebooks_result)
listLinkedNotebooks_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [evernote2.edam.type.ttypes.LinkedNotebook, None], False), None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class expungeLinkedNotebook_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expungeLinkedNotebook_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expungeLinkedNotebook_args)
expungeLinkedNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class expungeLinkedNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('expungeLinkedNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(expungeLinkedNotebook_result)
expungeLinkedNotebook_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class authenticateToSharedNotebook_args(object):
    """
    Attributes:
     - shareKeyOrGlobalId
     - authenticationToken
    """


    def __init__(self, shareKeyOrGlobalId=None, authenticationToken=None,):
        self.shareKeyOrGlobalId = shareKeyOrGlobalId
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.shareKeyOrGlobalId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateToSharedNotebook_args')
        if self.shareKeyOrGlobalId is not None:
            oprot.writeFieldBegin('shareKeyOrGlobalId', TType.STRING, 1)
            oprot.writeString(self.shareKeyOrGlobalId.encode('utf-8') if sys.version_info[0] == 2 else self.shareKeyOrGlobalId)
            oprot.writeFieldEnd()
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 2)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateToSharedNotebook_args)
authenticateToSharedNotebook_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'shareKeyOrGlobalId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 2
)


class authenticateToSharedNotebook_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.userstore.ttypes.AuthenticationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateToSharedNotebook_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateToSharedNotebook_result)
authenticateToSharedNotebook_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.userstore.ttypes.AuthenticationResult, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class getSharedNotebookByAuth_args(object):
    """
    Attributes:
     - authenticationToken
    """


    def __init__(self, authenticationToken=None,):
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSharedNotebookByAuth_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSharedNotebookByAuth_args)
getSharedNotebookByAuth_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
)


class getSharedNotebookByAuth_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.type.ttypes.SharedNotebook()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSharedNotebookByAuth_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSharedNotebookByAuth_result)
getSharedNotebookByAuth_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.type.ttypes.SharedNotebook, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class emailNote_args(object):
    """
    Attributes:
     - authenticationToken
     - parameters
    """


    def __init__(self, authenticationToken=None, parameters=None,):
        self.authenticationToken = authenticationToken
        self.parameters = parameters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.parameters = NoteEmailParameters()
                    self.parameters.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('emailNote_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.STRUCT, 2)
            self.parameters.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(emailNote_args)
emailNote_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'parameters', [NoteEmailParameters, None], None, ),  # 2
)


class emailNote_result(object):
    """
    Attributes:
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, userException=None, notFoundException=None, systemException=None,):
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('emailNote_result')
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(emailNote_result)
emailNote_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class shareNote_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shareNote_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shareNote_args)
shareNote_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class shareNote_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shareNote_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shareNote_result)
shareNote_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class stopSharingNote_args(object):
    """
    Attributes:
     - authenticationToken
     - guid
    """


    def __init__(self, authenticationToken=None, guid=None,):
        self.authenticationToken = authenticationToken
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopSharingNote_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 2)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopSharingNote_args)
stopSharingNote_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'guid', 'UTF8', None, ),  # 2
)


class stopSharingNote_result(object):
    """
    Attributes:
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, userException=None, notFoundException=None, systemException=None,):
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopSharingNote_result')
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopSharingNote_result)
stopSharingNote_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class authenticateToSharedNote_args(object):
    """
    Attributes:
     - guid
     - noteKey
     - authenticationToken
    """


    def __init__(self, guid=None, noteKey=None, authenticationToken=None,):
        self.guid = guid
        self.noteKey = noteKey
        self.authenticationToken = authenticationToken

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.noteKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateToSharedNote_args')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.noteKey is not None:
            oprot.writeFieldBegin('noteKey', TType.STRING, 2)
            oprot.writeString(self.noteKey.encode('utf-8') if sys.version_info[0] == 2 else self.noteKey)
            oprot.writeFieldEnd()
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 3)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateToSharedNote_args)
authenticateToSharedNote_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'noteKey', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 3
)


class authenticateToSharedNote_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = evernote2.edam.userstore.ttypes.AuthenticationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateToSharedNote_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateToSharedNote_result)
authenticateToSharedNote_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [evernote2.edam.userstore.ttypes.AuthenticationResult, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class findRelated_args(object):
    """
    Attributes:
     - authenticationToken
     - query
     - resultSpec
    """


    def __init__(self, authenticationToken=None, query=None, resultSpec=None,):
        self.authenticationToken = authenticationToken
        self.query = query
        self.resultSpec = resultSpec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.query = RelatedQuery()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.resultSpec = RelatedResultSpec()
                    self.resultSpec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findRelated_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 2)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        if self.resultSpec is not None:
            oprot.writeFieldBegin('resultSpec', TType.STRUCT, 3)
            self.resultSpec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findRelated_args)
findRelated_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'query', [RelatedQuery, None], None, ),  # 2
    (3, TType.STRUCT, 'resultSpec', [RelatedResultSpec, None], None, ),  # 3
)


class findRelated_result(object):
    """
    Attributes:
     - success
     - userException
     - systemException
     - notFoundException
    """


    def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
        self.success = success
        self.userException = userException
        self.systemException = systemException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RelatedResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findRelated_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findRelated_result)
findRelated_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RelatedResult, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)


class updateNoteIfUsnMatches_args(object):
    """
    Attributes:
     - authenticationToken
     - note
    """


    def __init__(self, authenticationToken=None, note=None,):
        self.authenticationToken = authenticationToken
        self.note = note

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.note = evernote2.edam.type.ttypes.Note()
                    self.note.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateNoteIfUsnMatches_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.note is not None:
            oprot.writeFieldBegin('note', TType.STRUCT, 2)
            self.note.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateNoteIfUsnMatches_args)
updateNoteIfUsnMatches_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'note', [evernote2.edam.type.ttypes.Note, None], None, ),  # 2
)


class updateNoteIfUsnMatches_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = UpdateNoteIfUsnMatchesResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateNoteIfUsnMatches_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateNoteIfUsnMatches_result)
updateNoteIfUsnMatches_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [UpdateNoteIfUsnMatchesResult, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class manageNotebookShares_args(object):
    """
    Attributes:
     - authenticationToken
     - parameters
    """


    def __init__(self, authenticationToken=None, parameters=None,):
        self.authenticationToken = authenticationToken
        self.parameters = parameters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.parameters = ManageNotebookSharesParameters()
                    self.parameters.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('manageNotebookShares_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.STRUCT, 2)
            self.parameters.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(manageNotebookShares_args)
manageNotebookShares_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'parameters', [ManageNotebookSharesParameters, None], None, ),  # 2
)


class manageNotebookShares_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ManageNotebookSharesResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('manageNotebookShares_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(manageNotebookShares_result)
manageNotebookShares_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ManageNotebookSharesResult, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)


class getNotebookShares_args(object):
    """
    Attributes:
     - authenticationToken
     - notebookGuid
    """


    def __init__(self, authenticationToken=None, notebookGuid=None,):
        self.authenticationToken = authenticationToken
        self.notebookGuid = notebookGuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.authenticationToken = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.notebookGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNotebookShares_args')
        if self.authenticationToken is not None:
            oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
            oprot.writeString(self.authenticationToken.encode('utf-8') if sys.version_info[0] == 2 else self.authenticationToken)
            oprot.writeFieldEnd()
        if self.notebookGuid is not None:
            oprot.writeFieldBegin('notebookGuid', TType.STRING, 2)
            oprot.writeString(self.notebookGuid.encode('utf-8') if sys.version_info[0] == 2 else self.notebookGuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNotebookShares_args)
getNotebookShares_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'authenticationToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'notebookGuid', 'UTF8', None, ),  # 2
)


class getNotebookShares_result(object):
    """
    Attributes:
     - success
     - userException
     - notFoundException
     - systemException
    """


    def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
        self.success = success
        self.userException = userException
        self.notFoundException = notFoundException
        self.systemException = systemException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ShareRelationships()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.userException = evernote2.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote2.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.systemException = evernote2.edam.error.ttypes.EDAMSystemException()
                    self.systemException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNotebookShares_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 1)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        if self.systemException is not None:
            oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
            self.systemException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in list(self.__dict__.items())]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNotebookShares_result)
getNotebookShares_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ShareRelationships, None], None, ),  # 0
    (1, TType.STRUCT, 'userException', [evernote2.edam.error.ttypes.EDAMUserException, None], None, ),  # 1
    (2, TType.STRUCT, 'notFoundException', [evernote2.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'systemException', [evernote2.edam.error.ttypes.EDAMSystemException, None], None, ),  # 3
)
fix_spec(all_structs)
del all_structs

