#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import evernote.edam.userstore.ttypes
import evernote.edam.type.ttypes
import evernote.edam.error.ttypes
import evernote.edam.limits.ttypes

from thrift.transport import TTransport
all_structs = []


class ShareRelationshipPrivilegeLevel(object):
    """
    Privilege levels for accessing shared notebooks.

    READ_NOTEBOOK: Recipient is able to read the contents of the shared notebook
      but does not have access to information about other recipients of the
      notebook or the activity stream information.

    READ_NOTEBOOK_PLUS_ACTIVITY: Recipient has READ_NOTEBOOK rights and can also
      access information about other recipients and the activity stream.

    MODIFY_NOTEBOOK_PLUS_ACTIVITY: Recipient has rights to read and modify the contents
      of the shared notebook, including the right to move notes to the trash and to create
      notes in the notebook.  The recipient can also access information about other
      recipients and the activity stream.

    FULL_ACCESS: Recipient has full rights to the shared notebook and recipient lists,
      including privilege to revoke and create invitations and to change privilege
      levels on invitations for individuals. If the user is a member of the same group,
      (e.g. the same business) as the shared notebook, they will additionally be granted
      permissions to update the publishing status of the notebook.
    """
    READ_NOTEBOOK = 0
    READ_NOTEBOOK_PLUS_ACTIVITY = 10
    MODIFY_NOTEBOOK_PLUS_ACTIVITY = 20
    FULL_ACCESS = 30

    _VALUES_TO_NAMES = {
        0: "READ_NOTEBOOK",
        10: "READ_NOTEBOOK_PLUS_ACTIVITY",
        20: "MODIFY_NOTEBOOK_PLUS_ACTIVITY",
        30: "FULL_ACCESS",
    }

    _NAMES_TO_VALUES = {
        "READ_NOTEBOOK": 0,
        "READ_NOTEBOOK_PLUS_ACTIVITY": 10,
        "MODIFY_NOTEBOOK_PLUS_ACTIVITY": 20,
        "FULL_ACCESS": 30,
    }


class SyncState(object):
    """
    This structure encapsulates the information about the state of the
    user's account for the purpose of "state based" synchronization.
    <dl>
    <dt>currentTime</dt>
      <dd>
      The server's current date and time.
      </dd>
    <dt>fullSyncBefore</dt>
      <dd>
      The cutoff date and time for client caches to be
      updated via incremental synchronization.  Any clients that were last
      synched with the server before this date/time must do a full resync of all
      objects.  This cutoff point will change over time as archival data is
      deleted or special circumstances on the service require resynchronization.
      </dd>
    <dt>updateCount</dt>
      <dd>
      Indicates the total number of transactions that have
      been committed within the account.  This reflects (for example) the
      number of discrete additions or modifications that have been made to
      the data in this account (tags, notes, resources, etc.).
      This number is the "high water mark" for Update Sequence Numbers (USN)
      within the account.
      </dd>
    <dt>uploaded</dt>
      <dd>
      The total number of bytes that have been uploaded to
      this account in the current monthly period.  This can be compared against
      Accounting.uploadLimit (from the UserStore) to determine how close the user
      is to their monthly upload limit.
      This value may not be present if the SyncState has been retrieved by
      a caller that only has read access to the account.
      </dd>
    <dt>userLastUpdated</dt>
      <dd>
      The last time when a user's account level information was changed. This value
      is the latest time when a modification was made to any of the following:
      accounting information (billing, quota, premium status, etc.), user attributes
      and business user information (business name, business user attributes, etc.) if
      the user is in a business.
      Clients who need to maintain account information about a User should watch this
      field for updates rather than polling UserStore.getUser for updates. Here is the
      basic flow that clients should follow:
      <ol>
        <li>Call NoteStore.getSyncState to retrieve the SyncState object</li>
        <li>Compare SyncState.userLastUpdated to previously stored value:
            if (SyncState.userLastUpdated > previousValue)
              call UserStore.getUser to get the latest User object;
            else
              do nothing;</li>
        <li>Update previousValue = SyncState.userLastUpdated</li>
      </ol>
      </dd>
    <dt>userMaxMessageEventId</dt>
      <dd>
      The greatest MessageEventID for this user's account. Clients that do a full
      sync should store this value locally and compare their local copy to the
      value returned by getSyncState to determine if they need to sync with
      MessageStore. This value will be omitted if the user has never sent or
      received a message.
      </dd>
    </dl>

    Attributes:
     - currentTime
     - fullSyncBefore
     - updateCount
     - uploaded
     - userLastUpdated
     - userMaxMessageEventId
    """


    def __init__(self, currentTime=None, fullSyncBefore=None, updateCount=None, uploaded=None, userLastUpdated=None, userMaxMessageEventId=None,):
        self.currentTime = currentTime
        self.fullSyncBefore = fullSyncBefore
        self.updateCount = updateCount
        self.uploaded = uploaded
        self.userLastUpdated = userLastUpdated
        self.userMaxMessageEventId = userMaxMessageEventId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.currentTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.fullSyncBefore = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.updateCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.uploaded = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.userLastUpdated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.userMaxMessageEventId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SyncState')
        if self.currentTime is not None:
            oprot.writeFieldBegin('currentTime', TType.I64, 1)
            oprot.writeI64(self.currentTime)
            oprot.writeFieldEnd()
        if self.fullSyncBefore is not None:
            oprot.writeFieldBegin('fullSyncBefore', TType.I64, 2)
            oprot.writeI64(self.fullSyncBefore)
            oprot.writeFieldEnd()
        if self.updateCount is not None:
            oprot.writeFieldBegin('updateCount', TType.I32, 3)
            oprot.writeI32(self.updateCount)
            oprot.writeFieldEnd()
        if self.uploaded is not None:
            oprot.writeFieldBegin('uploaded', TType.I64, 4)
            oprot.writeI64(self.uploaded)
            oprot.writeFieldEnd()
        if self.userLastUpdated is not None:
            oprot.writeFieldBegin('userLastUpdated', TType.I64, 5)
            oprot.writeI64(self.userLastUpdated)
            oprot.writeFieldEnd()
        if self.userMaxMessageEventId is not None:
            oprot.writeFieldBegin('userMaxMessageEventId', TType.I64, 6)
            oprot.writeI64(self.userMaxMessageEventId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.currentTime is None:
            raise TProtocolException(message='Required field currentTime is unset!')
        if self.fullSyncBefore is None:
            raise TProtocolException(message='Required field fullSyncBefore is unset!')
        if self.updateCount is None:
            raise TProtocolException(message='Required field updateCount is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SyncChunk(object):
    """
     This structure is given out by the NoteStore when a client asks to
     receive the current state of an account.  The client asks for the server's
     state one chunk at a time in order to allow clients to retrieve the state
     of a large account without needing to transfer the entire account in
     a single message.

     The server always gives SyncChunks using an ascending series of Update
     Sequence Numbers (USNs).

    <dl>
     <dt>currentTime</dt>
       <dd>
       The server's current date and time.
       </dd>

     <dt>chunkHighUSN</dt>
       <dd>
       The highest USN for any of the data objects represented
       in this sync chunk.  If there are no objects in the chunk, this will not be
       set.
       </dd>

     <dt>updateCount</dt>
       <dd>
       The total number of updates that have been performed in
       the service for this account.  This is equal to the highest USN within the
       account at the point that this SyncChunk was generated.  If updateCount
       and chunkHighUSN are identical, that means that this is the last chunk
       in the account ... there is no more recent information.
       </dd>

     <dt>notes</dt>
       <dd>
       If present, this is a list of non-expunged notes that
       have a USN in this chunk.  This will include notes that are "deleted"
       but not expunged (i.e. in the trash).  The notes will include their list
       of tags and resources, but the note content, resource content, resource
       recognition data and resource alternate data will not be supplied.
       </dd>

     <dt>notebooks</dt>
       <dd>
       If present, this is a list of non-expunged notebooks that
       have a USN in this chunk.
       </dd>

     <dt>tags</dt>
       <dd>
       If present, this is a list of the non-expunged tags that have a
       USN in this chunk.
       </dd>

     <dt>searches</dt>
       <dd>
       If present, this is a list of non-expunged searches that
       have a USN in this chunk.
       </dd>

     <dt>resources</dt>
       <dd>
       If present, this is a list of the non-expunged resources
       that have a USN in this chunk.  This will include the metadata for each
       resource, but not its binary contents or recognition data, which must be
       retrieved separately.
       </dd>

     <dt>expungedNotes</dt>
       <dd>
       If present, the GUIDs of all of the notes that were
       permanently expunged in this chunk.
       </dd>

     <dt>expungedNotebooks</dt>
       <dd>
       If present, the GUIDs of all of the notebooks that
       were permanently expunged in this chunk.  When a notebook is expunged,
       this implies that all of its child notes (and their resources) were
       also expunged.
       </dd>

     <dt>expungedTags</dt>
       <dd>
       If present, the GUIDs of all of the tags that were
       permanently expunged in this chunk.
       </dd>

     <dt>expungedSearches</dt>
       <dd>
       If present, the GUIDs of all of the saved searches
       that were permanently expunged in this chunk.
       </dd>

     <dt>linkedNotebooks</dt>
       <dd>
       If present, this is a list of non-expunged LinkedNotebooks that
       have a USN in this chunk.
       </dd>

     <dt>expungedLinkedNotebooks</dt>
       <dd>
       If present, the GUIDs of all of the LinkedNotebooks
       that were permanently expunged in this chunk.
       </dd>

    Attributes:
     - currentTime
     - chunkHighUSN
     - updateCount
     - notes
     - notebooks
     - tags
     - searches
     - resources
     - expungedNotes
     - expungedNotebooks
     - expungedTags
     - expungedSearches
     - linkedNotebooks
     - expungedLinkedNotebooks
    """


    def __init__(self, currentTime=None, chunkHighUSN=None, updateCount=None, notes=None, notebooks=None, tags=None, searches=None, resources=None, expungedNotes=None, expungedNotebooks=None, expungedTags=None, expungedSearches=None, linkedNotebooks=None, expungedLinkedNotebooks=None,):
        self.currentTime = currentTime
        self.chunkHighUSN = chunkHighUSN
        self.updateCount = updateCount
        self.notes = notes
        self.notebooks = notebooks
        self.tags = tags
        self.searches = searches
        self.resources = resources
        self.expungedNotes = expungedNotes
        self.expungedNotebooks = expungedNotebooks
        self.expungedTags = expungedTags
        self.expungedSearches = expungedSearches
        self.linkedNotebooks = linkedNotebooks
        self.expungedLinkedNotebooks = expungedLinkedNotebooks

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.currentTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.chunkHighUSN = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.updateCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.notes = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = evernote.edam.type.ttypes.Note()
                        _elem5.read(iprot)
                        self.notes.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.notebooks = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = evernote.edam.type.ttypes.Notebook()
                        _elem11.read(iprot)
                        self.notebooks.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.tags = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = evernote.edam.type.ttypes.Tag()
                        _elem17.read(iprot)
                        self.tags.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.searches = []
                    (_etype21, _size18) = iprot.readListBegin()
                    for _i22 in range(_size18):
                        _elem23 = evernote.edam.type.ttypes.SavedSearch()
                        _elem23.read(iprot)
                        self.searches.append(_elem23)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.resources = []
                    (_etype27, _size24) = iprot.readListBegin()
                    for _i28 in range(_size24):
                        _elem29 = evernote.edam.type.ttypes.Resource()
                        _elem29.read(iprot)
                        self.resources.append(_elem29)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.expungedNotes = []
                    (_etype33, _size30) = iprot.readListBegin()
                    for _i34 in range(_size30):
                        _elem35 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.expungedNotes.append(_elem35)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.expungedNotebooks = []
                    (_etype39, _size36) = iprot.readListBegin()
                    for _i40 in range(_size36):
                        _elem41 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.expungedNotebooks.append(_elem41)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.expungedTags = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.expungedTags.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.expungedSearches = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.expungedSearches.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.linkedNotebooks = []
                    (_etype57, _size54) = iprot.readListBegin()
                    for _i58 in range(_size54):
                        _elem59 = evernote.edam.type.ttypes.LinkedNotebook()
                        _elem59.read(iprot)
                        self.linkedNotebooks.append(_elem59)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.expungedLinkedNotebooks = []
                    (_etype63, _size60) = iprot.readListBegin()
                    for _i64 in range(_size60):
                        _elem65 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.expungedLinkedNotebooks.append(_elem65)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SyncChunk')
        if self.currentTime is not None:
            oprot.writeFieldBegin('currentTime', TType.I64, 1)
            oprot.writeI64(self.currentTime)
            oprot.writeFieldEnd()
        if self.chunkHighUSN is not None:
            oprot.writeFieldBegin('chunkHighUSN', TType.I32, 2)
            oprot.writeI32(self.chunkHighUSN)
            oprot.writeFieldEnd()
        if self.updateCount is not None:
            oprot.writeFieldBegin('updateCount', TType.I32, 3)
            oprot.writeI32(self.updateCount)
            oprot.writeFieldEnd()
        if self.notes is not None:
            oprot.writeFieldBegin('notes', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.notes))
            for iter66 in self.notes:
                iter66.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.notebooks is not None:
            oprot.writeFieldBegin('notebooks', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.notebooks))
            for iter67 in self.notebooks:
                iter67.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.tags))
            for iter68 in self.tags:
                iter68.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.searches is not None:
            oprot.writeFieldBegin('searches', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.searches))
            for iter69 in self.searches:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.resources is not None:
            oprot.writeFieldBegin('resources', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.resources))
            for iter70 in self.resources:
                iter70.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.expungedNotes is not None:
            oprot.writeFieldBegin('expungedNotes', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.expungedNotes))
            for iter71 in self.expungedNotes:
                oprot.writeString(iter71.encode('utf-8') if sys.version_info[0] == 2 else iter71)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.expungedNotebooks is not None:
            oprot.writeFieldBegin('expungedNotebooks', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.expungedNotebooks))
            for iter72 in self.expungedNotebooks:
                oprot.writeString(iter72.encode('utf-8') if sys.version_info[0] == 2 else iter72)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.expungedTags is not None:
            oprot.writeFieldBegin('expungedTags', TType.LIST, 11)
            oprot.writeListBegin(TType.STRING, len(self.expungedTags))
            for iter73 in self.expungedTags:
                oprot.writeString(iter73.encode('utf-8') if sys.version_info[0] == 2 else iter73)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.expungedSearches is not None:
            oprot.writeFieldBegin('expungedSearches', TType.LIST, 12)
            oprot.writeListBegin(TType.STRING, len(self.expungedSearches))
            for iter74 in self.expungedSearches:
                oprot.writeString(iter74.encode('utf-8') if sys.version_info[0] == 2 else iter74)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.linkedNotebooks is not None:
            oprot.writeFieldBegin('linkedNotebooks', TType.LIST, 13)
            oprot.writeListBegin(TType.STRUCT, len(self.linkedNotebooks))
            for iter75 in self.linkedNotebooks:
                iter75.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.expungedLinkedNotebooks is not None:
            oprot.writeFieldBegin('expungedLinkedNotebooks', TType.LIST, 14)
            oprot.writeListBegin(TType.STRING, len(self.expungedLinkedNotebooks))
            for iter76 in self.expungedLinkedNotebooks:
                oprot.writeString(iter76.encode('utf-8') if sys.version_info[0] == 2 else iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.currentTime is None:
            raise TProtocolException(message='Required field currentTime is unset!')
        if self.updateCount is None:
            raise TProtocolException(message='Required field updateCount is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SyncChunkFilter(object):
    """
     This structure is used with the 'getFilteredSyncChunk' call to provide
     fine-grained control over the data that's returned when a client needs
     to synchronize with the service. Each flag in this structure specifies
     whether to include one class of data in the results of that call.

    <dl>
     <dt>includeNotes</dt>
       <dd>
       If true, then the server will include the SyncChunks.notes field
       </dd>

     <dt>includeNoteResources</dt>
       <dd>
       If true, then the server will include the 'resources' field on all of
       the Notes that are in SyncChunk.notes.
       If 'includeNotes' is false, then this will have no effect.
       </dd>

     <dt>includeNoteAttributes</dt>
       <dd>
       If true, then the server will include the 'attributes' field on all of
       the Notes that are in SyncChunks.notes.
       If 'includeNotes' is false, then this will have no effect.
       </dd>

     <dt>includeNotebooks</dt>
       <dd>
       If true, then the server will include the SyncChunks.notebooks field
       </dd>

     <dt>includeTags</dt>
       <dd>
       If true, then the server will include the SyncChunks.tags field
       </dd>

     <dt>includeSearches</dt>
       <dd>
       If true, then the server will include the SyncChunks.searches field
       </dd>

     <dt>includeResources</dt>
       <dd>
       If true, then the server will include the SyncChunks.resources field.
       Since the Resources are also provided with their Note
       (in the Notes.resources list), this is primarily useful for clients that
       want to watch for changes to individual Resources due to recognition data
       being added.
       </dd>

     <dt>includeLinkedNotebooks</dt>
       <dd>
       If true, then the server will include the SyncChunks.linkedNotebooks field.
       </dd>

     <dt>includeExpunged</dt>
       <dd>
       If true, then the server will include the 'expunged' data for any type
       of included data.  For example, if 'includeTags' and 'includeExpunged'
       are both true, then the SyncChunks.expungedTags field will be set with
       the GUIDs of tags that have been expunged from the server.
       </dd>

     <dt>includeNoteApplicationDataFullMap</dt>
       <dd>
       If true, then the values for the applicationData map will be filled
       in, assuming notes and note attributes are being returned.  Otherwise,
       only the keysOnly field will be filled in.
       </dd>

     <dt>includeResourceApplicationDataFullMap</dt>
       <dd>
       If true, then the fullMap values for the applicationData map will be
       filled in, assuming resources and resource attributes are being returned
       (includeResources is true).  Otherwise, only the keysOnly field will be
       filled in.
       </dd>

     <dt>includeNoteResourceApplicationDataFullMap</dt>
       <dd>
       If true, then the fullMap values for the applicationData map will be
       filled in for resources found inside of notes, assuming resources are
       being returned in notes (includeNoteResources is true).  Otherwise,
       only the keysOnly field will be filled in.
       </dd>

     <dt>omitSharedNotebooks<dt>
       <dd>
       Normally, if 'includeNotebooks' is true, then the SyncChunks will
       include Notebooks that may include a set of SharedNotebook
       invitations via Notebook.sharedNotebookIds and Notebook.sharedNotebooks.
       However, if omitSharedNotebooks is set to true, then the Notebooks
       will omit those two fields and leave them unset. This should be used
       by clients who want to know their own set of Notebooks (and the
       associated permissions via Notebook.recipientSettings), and who
       do not need to know the full set of other people who can also see
       that same notebook.
       </dd>

     <dt>requireNoteContentClass</dt>
       <dd>
       If set, then only send notes whose content class matches this value.
       The value can be a literal match or, if the last character is an
       asterisk, a prefix match.
       </dd>

     <dt>notebookGuids</dt>
       <dd>
       If set, then restrict the returned notebooks, notes, and
       resources to those associated with one of the notebooks whose
       GUID is provided in this list.  If not set, then no filtering on
       notebook GUID will be performed.  If you set this field, you may
       not also set includeExpunged else an EDAMUserException with an
       error code of DATA_CONFLICT will be thrown.  You only need to set
       this field if you want to restrict the returned entities more
       than what your authentication token allows you to access.  For
       example, there is no need to set this field for single notebook
       tokens such as for shared notebooks.  You can use this field to
       synchronize a newly discovered business notebook while
       incrementally synchronizing a business account, in which case you
       will only need to consider setting includeNotes,
       includeNotebooks, includeNoteAttributes, includeNoteResources,
       and maybe some of the "FullMap" fields.
       </dd>

     <dt>includeSharedNotes</dt>
       <dd>
       If true, then the service will include the sharedNotes field on all
       notes that are in SyncChunk.notes. If 'includeNotes' is false, then
       this will have no effect.
       </dd>
     </dl>

    Attributes:
     - includeNotes
     - includeNoteResources
     - includeNoteAttributes
     - includeNotebooks
     - includeTags
     - includeSearches
     - includeResources
     - includeLinkedNotebooks
     - includeExpunged
     - includeNoteApplicationDataFullMap
     - includeResourceApplicationDataFullMap
     - includeNoteResourceApplicationDataFullMap
     - includeSharedNotes
     - omitSharedNotebooks
     - requireNoteContentClass
     - notebookGuids
    """


    def __init__(self, includeNotes=None, includeNoteResources=None, includeNoteAttributes=None, includeNotebooks=None, includeTags=None, includeSearches=None, includeResources=None, includeLinkedNotebooks=None, includeExpunged=None, includeNoteApplicationDataFullMap=None, includeResourceApplicationDataFullMap=None, includeNoteResourceApplicationDataFullMap=None, includeSharedNotes=None, omitSharedNotebooks=None, requireNoteContentClass=None, notebookGuids=None,):
        self.includeNotes = includeNotes
        self.includeNoteResources = includeNoteResources
        self.includeNoteAttributes = includeNoteAttributes
        self.includeNotebooks = includeNotebooks
        self.includeTags = includeTags
        self.includeSearches = includeSearches
        self.includeResources = includeResources
        self.includeLinkedNotebooks = includeLinkedNotebooks
        self.includeExpunged = includeExpunged
        self.includeNoteApplicationDataFullMap = includeNoteApplicationDataFullMap
        self.includeResourceApplicationDataFullMap = includeResourceApplicationDataFullMap
        self.includeNoteResourceApplicationDataFullMap = includeNoteResourceApplicationDataFullMap
        self.includeSharedNotes = includeSharedNotes
        self.omitSharedNotebooks = omitSharedNotebooks
        self.requireNoteContentClass = requireNoteContentClass
        self.notebookGuids = notebookGuids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.includeNotes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.includeNoteResources = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.includeNoteAttributes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.includeNotebooks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.includeTags = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.includeSearches = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.includeResources = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.includeLinkedNotebooks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.includeExpunged = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.includeNoteApplicationDataFullMap = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.includeResourceApplicationDataFullMap = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.includeNoteResourceApplicationDataFullMap = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.BOOL:
                    self.includeSharedNotes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.omitSharedNotebooks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.requireNoteContentClass = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.SET:
                    self.notebookGuids = set()
                    (_etype80, _size77) = iprot.readSetBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.notebookGuids.add(_elem82)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SyncChunkFilter')
        if self.includeNotes is not None:
            oprot.writeFieldBegin('includeNotes', TType.BOOL, 1)
            oprot.writeBool(self.includeNotes)
            oprot.writeFieldEnd()
        if self.includeNoteResources is not None:
            oprot.writeFieldBegin('includeNoteResources', TType.BOOL, 2)
            oprot.writeBool(self.includeNoteResources)
            oprot.writeFieldEnd()
        if self.includeNoteAttributes is not None:
            oprot.writeFieldBegin('includeNoteAttributes', TType.BOOL, 3)
            oprot.writeBool(self.includeNoteAttributes)
            oprot.writeFieldEnd()
        if self.includeNotebooks is not None:
            oprot.writeFieldBegin('includeNotebooks', TType.BOOL, 4)
            oprot.writeBool(self.includeNotebooks)
            oprot.writeFieldEnd()
        if self.includeTags is not None:
            oprot.writeFieldBegin('includeTags', TType.BOOL, 5)
            oprot.writeBool(self.includeTags)
            oprot.writeFieldEnd()
        if self.includeSearches is not None:
            oprot.writeFieldBegin('includeSearches', TType.BOOL, 6)
            oprot.writeBool(self.includeSearches)
            oprot.writeFieldEnd()
        if self.includeResources is not None:
            oprot.writeFieldBegin('includeResources', TType.BOOL, 7)
            oprot.writeBool(self.includeResources)
            oprot.writeFieldEnd()
        if self.includeLinkedNotebooks is not None:
            oprot.writeFieldBegin('includeLinkedNotebooks', TType.BOOL, 8)
            oprot.writeBool(self.includeLinkedNotebooks)
            oprot.writeFieldEnd()
        if self.includeExpunged is not None:
            oprot.writeFieldBegin('includeExpunged', TType.BOOL, 9)
            oprot.writeBool(self.includeExpunged)
            oprot.writeFieldEnd()
        if self.includeNoteApplicationDataFullMap is not None:
            oprot.writeFieldBegin('includeNoteApplicationDataFullMap', TType.BOOL, 10)
            oprot.writeBool(self.includeNoteApplicationDataFullMap)
            oprot.writeFieldEnd()
        if self.requireNoteContentClass is not None:
            oprot.writeFieldBegin('requireNoteContentClass', TType.STRING, 11)
            oprot.writeString(self.requireNoteContentClass.encode('utf-8') if sys.version_info[0] == 2 else self.requireNoteContentClass)
            oprot.writeFieldEnd()
        if self.includeResourceApplicationDataFullMap is not None:
            oprot.writeFieldBegin('includeResourceApplicationDataFullMap', TType.BOOL, 12)
            oprot.writeBool(self.includeResourceApplicationDataFullMap)
            oprot.writeFieldEnd()
        if self.includeNoteResourceApplicationDataFullMap is not None:
            oprot.writeFieldBegin('includeNoteResourceApplicationDataFullMap', TType.BOOL, 13)
            oprot.writeBool(self.includeNoteResourceApplicationDataFullMap)
            oprot.writeFieldEnd()
        if self.notebookGuids is not None:
            oprot.writeFieldBegin('notebookGuids', TType.SET, 15)
            oprot.writeSetBegin(TType.STRING, len(self.notebookGuids))
            for iter83 in self.notebookGuids:
                oprot.writeString(iter83.encode('utf-8') if sys.version_info[0] == 2 else iter83)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.omitSharedNotebooks is not None:
            oprot.writeFieldBegin('omitSharedNotebooks', TType.BOOL, 16)
            oprot.writeBool(self.omitSharedNotebooks)
            oprot.writeFieldEnd()
        if self.includeSharedNotes is not None:
            oprot.writeFieldBegin('includeSharedNotes', TType.BOOL, 17)
            oprot.writeBool(self.includeSharedNotes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteFilter(object):
    """
     A list of criteria that are used to indicate which notes are desired from
     the account.  This is used in queries to the NoteStore to determine
     which notes should be retrieved.

    <dl>
     <dt>order</dt>
       <dd>
       The NoteSortOrder value indicating what criterion should be
       used to sort the results of the filter.
       </dd>

     <dt>ascending</dt>
       <dd>
       If true, the results will be ascending in the requested
       sort order.  If false, the results will be descending.
       </dd>

     <dt>words</dt>
       <dd>
       If present, a search query string that will filter the set of notes to be returned.
       Accepts the full search grammar documented in the Evernote API Overview.
       </dd>

     <dt>notebookGuid</dt>
       <dd>
       If present, the Guid of the notebook that must contain
       the notes.
       </dd>

     <dt>tagGuids</dt>
       <dd>
       If present, the list of tags (by GUID) that must be present
       on the notes.
       </dd>

     <dt>timeZone</dt>
       <dd>
       The zone ID for the user, which will be used to interpret
       any dates or times in the queries that do not include their desired zone
       information.
       For example, if a query requests notes created "yesterday", this
       will be evaluated from the provided time zone, if provided.
       The format must be encoded as a standard zone ID such as
       "America/Los_Angeles".
       </dd>

     <dt>inactive</dt>
       <dd>
       If true, then only notes that are not active (i.e. notes in
       the Trash) will be returned. Otherwise, only active notes will be returned.
       There is no way to find both active and inactive notes in a single query.
       </dd>

     <dt>emphasized</dt>
       <dd>
       If present, a search query string that may or may not influence the notes
       to be returned, both in terms of coverage as well as of order. Think of it
       as a wish list, not a requirement.
       Accepts the full search grammar documented in the Evernote API Overview.
       </dd>

     <dt>includeAllReadableNotebooks</dt>
       <dd>
       If true, then the search will include all business notebooks that are readable
       by the user. A business authentication token must be supplied for
       this option to take effect when calling search APIs.
       </dd>

     <dt>context</dt>
     <dd>Specifies the context to consider when determining result ranking.
         Clients must leave this value unset unless they wish to explicitly specify a known
         non-default context.
     </dd>

     </dl>

    Attributes:
     - order
     - ascending
     - words
     - notebookGuid
     - tagGuids
     - timeZone
     - inactive
     - emphasized
     - includeAllReadableNotebooks
     - context
    """


    def __init__(self, order=None, ascending=None, words=None, notebookGuid=None, tagGuids=None, timeZone=None, inactive=None, emphasized=None, includeAllReadableNotebooks=None, context=None,):
        self.order = order
        self.ascending = ascending
        self.words = words
        self.notebookGuid = notebookGuid
        self.tagGuids = tagGuids
        self.timeZone = timeZone
        self.inactive = inactive
        self.emphasized = emphasized
        self.includeAllReadableNotebooks = includeAllReadableNotebooks
        self.context = context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.ascending = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.words = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.notebookGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.tagGuids = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.tagGuids.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.timeZone = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.inactive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.emphasized = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.includeAllReadableNotebooks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.context = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteFilter')
        if self.order is not None:
            oprot.writeFieldBegin('order', TType.I32, 1)
            oprot.writeI32(self.order)
            oprot.writeFieldEnd()
        if self.ascending is not None:
            oprot.writeFieldBegin('ascending', TType.BOOL, 2)
            oprot.writeBool(self.ascending)
            oprot.writeFieldEnd()
        if self.words is not None:
            oprot.writeFieldBegin('words', TType.STRING, 3)
            oprot.writeString(self.words.encode('utf-8') if sys.version_info[0] == 2 else self.words)
            oprot.writeFieldEnd()
        if self.notebookGuid is not None:
            oprot.writeFieldBegin('notebookGuid', TType.STRING, 4)
            oprot.writeString(self.notebookGuid.encode('utf-8') if sys.version_info[0] == 2 else self.notebookGuid)
            oprot.writeFieldEnd()
        if self.tagGuids is not None:
            oprot.writeFieldBegin('tagGuids', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.tagGuids))
            for iter90 in self.tagGuids:
                oprot.writeString(iter90.encode('utf-8') if sys.version_info[0] == 2 else iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timeZone is not None:
            oprot.writeFieldBegin('timeZone', TType.STRING, 6)
            oprot.writeString(self.timeZone.encode('utf-8') if sys.version_info[0] == 2 else self.timeZone)
            oprot.writeFieldEnd()
        if self.inactive is not None:
            oprot.writeFieldBegin('inactive', TType.BOOL, 7)
            oprot.writeBool(self.inactive)
            oprot.writeFieldEnd()
        if self.emphasized is not None:
            oprot.writeFieldBegin('emphasized', TType.STRING, 8)
            oprot.writeString(self.emphasized.encode('utf-8') if sys.version_info[0] == 2 else self.emphasized)
            oprot.writeFieldEnd()
        if self.includeAllReadableNotebooks is not None:
            oprot.writeFieldBegin('includeAllReadableNotebooks', TType.BOOL, 9)
            oprot.writeBool(self.includeAllReadableNotebooks)
            oprot.writeFieldEnd()
        if self.context is not None:
            oprot.writeFieldBegin('context', TType.STRING, 10)
            oprot.writeString(self.context.encode('utf-8') if sys.version_info[0] == 2 else self.context)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteList(object):
    """
     A small structure for returning a list of notes out of a larger set.

    <dl>
     <dt>startIndex</dt>
       <dd>
       The starting index within the overall set of notes.  This
       is also the number of notes that are "before" this list in the set.
       </dd>

     <dt>totalNotes</dt>
       <dd>
       The number of notes in the larger set.  This can be used
       to calculate how many notes are "after" this note in the set.
       (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
       </dd>

     <dt>notes</dt>
       <dd>
       The list of notes from this range.  The Notes will include all
       metadata (attributes, resources, etc.), but will not include the ENML
       content of the note or the binary contents of any resources.
       </dd>

     <dt>stoppedWords</dt>
       <dd>
       If the NoteList was produced using a text based search
       query that included words that are not indexed or searched by the service,
       this will include a list of those ignored words.
       </dd>

     <dt>searchedWords</dt>
       <dd>
       If the NoteList was produced using a text based search
       query that included viable search words or quoted expressions, this will
       include a list of those words.  Any stopped words will not be included
       in this list.
       </dd>

     <dt>updateCount</dt>
       <dd>
       Indicates the total number of transactions that have
       been committed within the account.  This reflects (for example) the
       number of discrete additions or modifications that have been made to
       the data in this account (tags, notes, resources, etc.).
       This number is the "high water mark" for Update Sequence Numbers (USN)
       within the account.
       </dd>
     </dl>

    Attributes:
     - startIndex
     - totalNotes
     - notes
     - stoppedWords
     - searchedWords
     - updateCount
    """


    def __init__(self, startIndex=None, totalNotes=None, notes=None, stoppedWords=None, searchedWords=None, updateCount=None,):
        self.startIndex = startIndex
        self.totalNotes = totalNotes
        self.notes = notes
        self.stoppedWords = stoppedWords
        self.searchedWords = searchedWords
        self.updateCount = updateCount

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.startIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.totalNotes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.notes = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = evernote.edam.type.ttypes.Note()
                        _elem96.read(iprot)
                        self.notes.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.stoppedWords = []
                    (_etype100, _size97) = iprot.readListBegin()
                    for _i101 in range(_size97):
                        _elem102 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.stoppedWords.append(_elem102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.searchedWords = []
                    (_etype106, _size103) = iprot.readListBegin()
                    for _i107 in range(_size103):
                        _elem108 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.searchedWords.append(_elem108)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.updateCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteList')
        if self.startIndex is not None:
            oprot.writeFieldBegin('startIndex', TType.I32, 1)
            oprot.writeI32(self.startIndex)
            oprot.writeFieldEnd()
        if self.totalNotes is not None:
            oprot.writeFieldBegin('totalNotes', TType.I32, 2)
            oprot.writeI32(self.totalNotes)
            oprot.writeFieldEnd()
        if self.notes is not None:
            oprot.writeFieldBegin('notes', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.notes))
            for iter109 in self.notes:
                iter109.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.stoppedWords is not None:
            oprot.writeFieldBegin('stoppedWords', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.stoppedWords))
            for iter110 in self.stoppedWords:
                oprot.writeString(iter110.encode('utf-8') if sys.version_info[0] == 2 else iter110)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.searchedWords is not None:
            oprot.writeFieldBegin('searchedWords', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.searchedWords))
            for iter111 in self.searchedWords:
                oprot.writeString(iter111.encode('utf-8') if sys.version_info[0] == 2 else iter111)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.updateCount is not None:
            oprot.writeFieldBegin('updateCount', TType.I32, 6)
            oprot.writeI32(self.updateCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.startIndex is None:
            raise TProtocolException(message='Required field startIndex is unset!')
        if self.totalNotes is None:
            raise TProtocolException(message='Required field totalNotes is unset!')
        if self.notes is None:
            raise TProtocolException(message='Required field notes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteMetadata(object):
    """
    This structure is used in the set of results returned by the
    findNotesMetadata function.  It represents the high-level information about
    a single Note, without some of the larger deep structure.  This allows
    for the information about a list of Notes to be returned relatively quickly
    with less marshalling and data transfer to remote clients.
    Most fields in this structure are identical to the corresponding field in
    the Note structure, with the exception of:

    <dl>
    <dt>largestResourceMime</dt>
      <dd>If set, then this will contain the MIME type of the largest Resource
      (in bytes) within the Note.  This may be useful, for example, to choose
      an appropriate icon or thumbnail to represent the Note.
      </dd>

    <dt>largestResourceSize</dt>
     <dd>If set, this will contain the size of the largest Resource file, in
     bytes, within the Note.  This may be useful, for example, to decide whether
     to ask the server for a thumbnail to represent the Note.
     </dd>
    </dl>

    Attributes:
     - guid
     - title
     - contentLength
     - created
     - updated
     - deleted
     - updateSequenceNum
     - notebookGuid
     - tagGuids
     - attributes
     - largestResourceMime
     - largestResourceSize
    """


    def __init__(self, guid=None, title=None, contentLength=None, created=None, updated=None, deleted=None, updateSequenceNum=None, notebookGuid=None, tagGuids=None, attributes=None, largestResourceMime=None, largestResourceSize=None,):
        self.guid = guid
        self.title = title
        self.contentLength = contentLength
        self.created = created
        self.updated = updated
        self.deleted = deleted
        self.updateSequenceNum = updateSequenceNum
        self.notebookGuid = notebookGuid
        self.tagGuids = tagGuids
        self.attributes = attributes
        self.largestResourceMime = largestResourceMime
        self.largestResourceSize = largestResourceSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.title = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.contentLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.created = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.updated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.deleted = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.updateSequenceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.notebookGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.tagGuids = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.tagGuids.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.attributes = evernote.edam.type.ttypes.NoteAttributes()
                    self.attributes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRING:
                    self.largestResourceMime = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I32:
                    self.largestResourceSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteMetadata')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.title is not None:
            oprot.writeFieldBegin('title', TType.STRING, 2)
            oprot.writeString(self.title.encode('utf-8') if sys.version_info[0] == 2 else self.title)
            oprot.writeFieldEnd()
        if self.contentLength is not None:
            oprot.writeFieldBegin('contentLength', TType.I32, 5)
            oprot.writeI32(self.contentLength)
            oprot.writeFieldEnd()
        if self.created is not None:
            oprot.writeFieldBegin('created', TType.I64, 6)
            oprot.writeI64(self.created)
            oprot.writeFieldEnd()
        if self.updated is not None:
            oprot.writeFieldBegin('updated', TType.I64, 7)
            oprot.writeI64(self.updated)
            oprot.writeFieldEnd()
        if self.deleted is not None:
            oprot.writeFieldBegin('deleted', TType.I64, 8)
            oprot.writeI64(self.deleted)
            oprot.writeFieldEnd()
        if self.updateSequenceNum is not None:
            oprot.writeFieldBegin('updateSequenceNum', TType.I32, 10)
            oprot.writeI32(self.updateSequenceNum)
            oprot.writeFieldEnd()
        if self.notebookGuid is not None:
            oprot.writeFieldBegin('notebookGuid', TType.STRING, 11)
            oprot.writeString(self.notebookGuid.encode('utf-8') if sys.version_info[0] == 2 else self.notebookGuid)
            oprot.writeFieldEnd()
        if self.tagGuids is not None:
            oprot.writeFieldBegin('tagGuids', TType.LIST, 12)
            oprot.writeListBegin(TType.STRING, len(self.tagGuids))
            for iter118 in self.tagGuids:
                oprot.writeString(iter118.encode('utf-8') if sys.version_info[0] == 2 else iter118)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.STRUCT, 14)
            self.attributes.write(oprot)
            oprot.writeFieldEnd()
        if self.largestResourceMime is not None:
            oprot.writeFieldBegin('largestResourceMime', TType.STRING, 20)
            oprot.writeString(self.largestResourceMime.encode('utf-8') if sys.version_info[0] == 2 else self.largestResourceMime)
            oprot.writeFieldEnd()
        if self.largestResourceSize is not None:
            oprot.writeFieldBegin('largestResourceSize', TType.I32, 21)
            oprot.writeI32(self.largestResourceSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.guid is None:
            raise TProtocolException(message='Required field guid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NotesMetadataList(object):
    """
     This structure is returned from calls to the findNotesMetadata function to
     give the high-level metadata about a subset of Notes that are found to
     match a specified NoteFilter in a search.

    <dl>
     <dt>startIndex</dt>
       <dd>
       The starting index within the overall set of notes.  This
       is also the number of notes that are "before" this list in the set.
       </dd>

     <dt>totalNotes</dt>
       <dd>
       The number of notes in the larger set.  This can be used
       to calculate how many notes are "after" this note in the set.
       (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
       </dd>

     <dt>notes</dt>
       <dd>
       The list of metadata for Notes in this range.  The set of optional fields
       that are set in each metadata structure will depend on the
       NotesMetadataResultSpec provided by the caller when the search was
       performed.  Only the 'guid' field will be guaranteed to be set in each
       Note.
       </dd>

     <dt>stoppedWords</dt>
       <dd>
       If the NoteList was produced using a text based search
       query that included words that are not indexed or searched by the service,
       this will include a list of those ignored words.
       </dd>

     <dt>searchedWords</dt>
       <dd>
       If the NoteList was produced using a text based search
       query that included viable search words or quoted expressions, this will
       include a list of those words.  Any stopped words will not be included
       in this list.
       </dd>

     <dt>updateCount</dt>
       <dd>
       Indicates the total number of transactions that have
       been committed within the account.  This reflects (for example) the
       number of discrete additions or modifications that have been made to
       the data in this account (tags, notes, resources, etc.).
       This number is the "high water mark" for Update Sequence Numbers (USN)
       within the account.
       </dd>
     </dl>

    Attributes:
     - startIndex
     - totalNotes
     - notes
     - stoppedWords
     - searchedWords
     - updateCount
    """


    def __init__(self, startIndex=None, totalNotes=None, notes=None, stoppedWords=None, searchedWords=None, updateCount=None,):
        self.startIndex = startIndex
        self.totalNotes = totalNotes
        self.notes = notes
        self.stoppedWords = stoppedWords
        self.searchedWords = searchedWords
        self.updateCount = updateCount

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.startIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.totalNotes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.notes = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = NoteMetadata()
                        _elem124.read(iprot)
                        self.notes.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.stoppedWords = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.stoppedWords.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.searchedWords = []
                    (_etype134, _size131) = iprot.readListBegin()
                    for _i135 in range(_size131):
                        _elem136 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.searchedWords.append(_elem136)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.updateCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotesMetadataList')
        if self.startIndex is not None:
            oprot.writeFieldBegin('startIndex', TType.I32, 1)
            oprot.writeI32(self.startIndex)
            oprot.writeFieldEnd()
        if self.totalNotes is not None:
            oprot.writeFieldBegin('totalNotes', TType.I32, 2)
            oprot.writeI32(self.totalNotes)
            oprot.writeFieldEnd()
        if self.notes is not None:
            oprot.writeFieldBegin('notes', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.notes))
            for iter137 in self.notes:
                iter137.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.stoppedWords is not None:
            oprot.writeFieldBegin('stoppedWords', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.stoppedWords))
            for iter138 in self.stoppedWords:
                oprot.writeString(iter138.encode('utf-8') if sys.version_info[0] == 2 else iter138)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.searchedWords is not None:
            oprot.writeFieldBegin('searchedWords', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.searchedWords))
            for iter139 in self.searchedWords:
                oprot.writeString(iter139.encode('utf-8') if sys.version_info[0] == 2 else iter139)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.updateCount is not None:
            oprot.writeFieldBegin('updateCount', TType.I32, 6)
            oprot.writeI32(self.updateCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.startIndex is None:
            raise TProtocolException(message='Required field startIndex is unset!')
        if self.totalNotes is None:
            raise TProtocolException(message='Required field totalNotes is unset!')
        if self.notes is None:
            raise TProtocolException(message='Required field notes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NotesMetadataResultSpec(object):
    """
    This structure is provided to the findNotesMetadata function to specify
    the subset of fields that should be included in each NoteMetadata element
    that is returned in the NotesMetadataList.
    Each field on this structure is a boolean flag that indicates whether the
    corresponding field should be included in the NoteMetadata structure when
    it is returned.  For example, if the 'includeTitle' field is set on this
    structure when calling findNotesMetadata, then each NoteMetadata in the
    list should have its 'title' field set.
    If one of the fields in this spec is not set, then it will be treated as
    'false' by the server, so the default behavior is to include nothing in
    replies (but the mandatory GUID)

    Attributes:
     - includeTitle
     - includeContentLength
     - includeCreated
     - includeUpdated
     - includeDeleted
     - includeUpdateSequenceNum
     - includeNotebookGuid
     - includeTagGuids
     - includeAttributes
     - includeLargestResourceMime
     - includeLargestResourceSize
    """


    def __init__(self, includeTitle=None, includeContentLength=None, includeCreated=None, includeUpdated=None, includeDeleted=None, includeUpdateSequenceNum=None, includeNotebookGuid=None, includeTagGuids=None, includeAttributes=None, includeLargestResourceMime=None, includeLargestResourceSize=None,):
        self.includeTitle = includeTitle
        self.includeContentLength = includeContentLength
        self.includeCreated = includeCreated
        self.includeUpdated = includeUpdated
        self.includeDeleted = includeDeleted
        self.includeUpdateSequenceNum = includeUpdateSequenceNum
        self.includeNotebookGuid = includeNotebookGuid
        self.includeTagGuids = includeTagGuids
        self.includeAttributes = includeAttributes
        self.includeLargestResourceMime = includeLargestResourceMime
        self.includeLargestResourceSize = includeLargestResourceSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.BOOL:
                    self.includeTitle = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.includeContentLength = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.includeCreated = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.includeUpdated = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.includeDeleted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.includeUpdateSequenceNum = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.includeNotebookGuid = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.includeTagGuids = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.includeAttributes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.BOOL:
                    self.includeLargestResourceMime = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.BOOL:
                    self.includeLargestResourceSize = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotesMetadataResultSpec')
        if self.includeTitle is not None:
            oprot.writeFieldBegin('includeTitle', TType.BOOL, 2)
            oprot.writeBool(self.includeTitle)
            oprot.writeFieldEnd()
        if self.includeContentLength is not None:
            oprot.writeFieldBegin('includeContentLength', TType.BOOL, 5)
            oprot.writeBool(self.includeContentLength)
            oprot.writeFieldEnd()
        if self.includeCreated is not None:
            oprot.writeFieldBegin('includeCreated', TType.BOOL, 6)
            oprot.writeBool(self.includeCreated)
            oprot.writeFieldEnd()
        if self.includeUpdated is not None:
            oprot.writeFieldBegin('includeUpdated', TType.BOOL, 7)
            oprot.writeBool(self.includeUpdated)
            oprot.writeFieldEnd()
        if self.includeDeleted is not None:
            oprot.writeFieldBegin('includeDeleted', TType.BOOL, 8)
            oprot.writeBool(self.includeDeleted)
            oprot.writeFieldEnd()
        if self.includeUpdateSequenceNum is not None:
            oprot.writeFieldBegin('includeUpdateSequenceNum', TType.BOOL, 10)
            oprot.writeBool(self.includeUpdateSequenceNum)
            oprot.writeFieldEnd()
        if self.includeNotebookGuid is not None:
            oprot.writeFieldBegin('includeNotebookGuid', TType.BOOL, 11)
            oprot.writeBool(self.includeNotebookGuid)
            oprot.writeFieldEnd()
        if self.includeTagGuids is not None:
            oprot.writeFieldBegin('includeTagGuids', TType.BOOL, 12)
            oprot.writeBool(self.includeTagGuids)
            oprot.writeFieldEnd()
        if self.includeAttributes is not None:
            oprot.writeFieldBegin('includeAttributes', TType.BOOL, 14)
            oprot.writeBool(self.includeAttributes)
            oprot.writeFieldEnd()
        if self.includeLargestResourceMime is not None:
            oprot.writeFieldBegin('includeLargestResourceMime', TType.BOOL, 20)
            oprot.writeBool(self.includeLargestResourceMime)
            oprot.writeFieldEnd()
        if self.includeLargestResourceSize is not None:
            oprot.writeFieldBegin('includeLargestResourceSize', TType.BOOL, 21)
            oprot.writeBool(self.includeLargestResourceSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteCollectionCounts(object):
    """
     A data structure representing the number of notes for each notebook
     and tag with a non-zero set of applicable notes.

    <dl>
     <dt>notebookCounts</dt>
       <dd>
       A mapping from the Notebook GUID to the number of
       notes (from some selection) that are in the corresponding notebook.
       </dd>

     <dt>tagCounts</dt>
       <dd>
       A mapping from the Tag GUID to the number of notes (from some
       selection) that have the corresponding tag.
       </dd>

     <dt>trashCount</dt>
       <dd>
       If this is set, then this is the number of notes that are in the trash.
       If this is not set, then the number of notes in the trash hasn't been
       reported.  (I.e. if there are no notes in the trash, this will be set
       to 0.)
       </dd>
     </dl>

    Attributes:
     - notebookCounts
     - tagCounts
     - trashCount
    """


    def __init__(self, notebookCounts=None, tagCounts=None, trashCount=None,):
        self.notebookCounts = notebookCounts
        self.tagCounts = tagCounts
        self.trashCount = trashCount

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.notebookCounts = {}
                    (_ktype141, _vtype142, _size140) = iprot.readMapBegin()
                    for _i144 in range(_size140):
                        _key145 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val146 = iprot.readI32()
                        self.notebookCounts[_key145] = _val146
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.tagCounts = {}
                    (_ktype148, _vtype149, _size147) = iprot.readMapBegin()
                    for _i151 in range(_size147):
                        _key152 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val153 = iprot.readI32()
                        self.tagCounts[_key152] = _val153
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.trashCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteCollectionCounts')
        if self.notebookCounts is not None:
            oprot.writeFieldBegin('notebookCounts', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.notebookCounts))
            for kiter154, viter155 in self.notebookCounts.items():
                oprot.writeString(kiter154.encode('utf-8') if sys.version_info[0] == 2 else kiter154)
                oprot.writeI32(viter155)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tagCounts is not None:
            oprot.writeFieldBegin('tagCounts', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.tagCounts))
            for kiter156, viter157 in self.tagCounts.items():
                oprot.writeString(kiter156.encode('utf-8') if sys.version_info[0] == 2 else kiter156)
                oprot.writeI32(viter157)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.trashCount is not None:
            oprot.writeFieldBegin('trashCount', TType.I32, 3)
            oprot.writeI32(self.trashCount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteResultSpec(object):
    """
    This structure is provided to the getNoteWithResultSpec function to specify the subset of
    fields that should be included in the Note that is returned. This allows clients to request
    the minimum set of information that they require when retrieving a note, reducing the size
    of the response and improving the response time.

    If one of the fields in this spec is not set, then it will be treated as 'false' by the service,
    so that the default behavior is to include none of the fields below in the Note.

    <dl>
      <dt>includeContent</dt>
      <dd>If true, the Note.content field will be populated with the note's ENML contents.</dd>

      <dt>includeResourcesData</dt>
      <dd>If true, any Resource elements will include the binary contents of their 'data' field's
        body.</dd>

      <dt>includeResourcesRecognition</dt>
      <dd>If true, any Resource elements will include the binary contents of their 'recognition'
        field's body if recognition data is available.</dd>

      <dt>includeResourcesAlternateData</dt>
      <dd>If true, any Resource elements will include the binary contents of their 'alternateData'
        field's body, if an alternate form is available.</dd>

      <dt>includeSharedNotes</dt>
      <dd>If true, the Note.sharedNotes field will be populated with the note's shares.</dd>

      <dt>includeNoteAppDataValues</dt>
      <dd>If true, the Note.attributes.applicationData.fullMap field will be populated.</dd>

      <dt>includeResourceAppDataValues</dt>
      <dd>If true, the Note.resource.attributes.applicationData.fullMap field will be populated.</dd>

      <dt>includeAccountLimits</dt>
      <dd>If true, the Note.limits field will be populated with the note owner's account limits.</dd>
    </dl>

    Attributes:
     - includeContent
     - includeResourcesData
     - includeResourcesRecognition
     - includeResourcesAlternateData
     - includeSharedNotes
     - includeNoteAppDataValues
     - includeResourceAppDataValues
     - includeAccountLimits
    """


    def __init__(self, includeContent=None, includeResourcesData=None, includeResourcesRecognition=None, includeResourcesAlternateData=None, includeSharedNotes=None, includeNoteAppDataValues=None, includeResourceAppDataValues=None, includeAccountLimits=None,):
        self.includeContent = includeContent
        self.includeResourcesData = includeResourcesData
        self.includeResourcesRecognition = includeResourcesRecognition
        self.includeResourcesAlternateData = includeResourcesAlternateData
        self.includeSharedNotes = includeSharedNotes
        self.includeNoteAppDataValues = includeNoteAppDataValues
        self.includeResourceAppDataValues = includeResourceAppDataValues
        self.includeAccountLimits = includeAccountLimits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.includeContent = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.includeResourcesData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.includeResourcesRecognition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.includeResourcesAlternateData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.includeSharedNotes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.includeNoteAppDataValues = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.includeResourceAppDataValues = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.includeAccountLimits = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteResultSpec')
        if self.includeContent is not None:
            oprot.writeFieldBegin('includeContent', TType.BOOL, 1)
            oprot.writeBool(self.includeContent)
            oprot.writeFieldEnd()
        if self.includeResourcesData is not None:
            oprot.writeFieldBegin('includeResourcesData', TType.BOOL, 2)
            oprot.writeBool(self.includeResourcesData)
            oprot.writeFieldEnd()
        if self.includeResourcesRecognition is not None:
            oprot.writeFieldBegin('includeResourcesRecognition', TType.BOOL, 3)
            oprot.writeBool(self.includeResourcesRecognition)
            oprot.writeFieldEnd()
        if self.includeResourcesAlternateData is not None:
            oprot.writeFieldBegin('includeResourcesAlternateData', TType.BOOL, 4)
            oprot.writeBool(self.includeResourcesAlternateData)
            oprot.writeFieldEnd()
        if self.includeSharedNotes is not None:
            oprot.writeFieldBegin('includeSharedNotes', TType.BOOL, 5)
            oprot.writeBool(self.includeSharedNotes)
            oprot.writeFieldEnd()
        if self.includeNoteAppDataValues is not None:
            oprot.writeFieldBegin('includeNoteAppDataValues', TType.BOOL, 6)
            oprot.writeBool(self.includeNoteAppDataValues)
            oprot.writeFieldEnd()
        if self.includeResourceAppDataValues is not None:
            oprot.writeFieldBegin('includeResourceAppDataValues', TType.BOOL, 7)
            oprot.writeBool(self.includeResourceAppDataValues)
            oprot.writeFieldEnd()
        if self.includeAccountLimits is not None:
            oprot.writeFieldBegin('includeAccountLimits', TType.BOOL, 8)
            oprot.writeBool(self.includeAccountLimits)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteEmailParameters(object):
    """
    Parameters that must be given to the NoteStore emailNote call. These allow
    the caller to specify the note to send, the recipient addresses, etc.

    <dl>
     <dt>guid</dt>
       <dd>
         If set, this must be the GUID of a note within the user's account that
         should be retrieved from the service and sent as email.  If not set,
         the 'note' field must be provided instead.
       </dd>

     <dt>note</dt>
       <dd>
         If the 'guid' field is not set, this field must be provided, including
         the full contents of the note note (and all of its Resources) to send.
         This can be used for a Note that as not been created in the service,
         for example by a local client with local notes.
       </dd>

     <dt>toAddresses</dt>
       <dd>
         If provided, this should contain a list of the SMTP email addresses
         that should be included in the "To:" line of the email.
         Callers must specify at least one "to" or "cc" email address.
       </dd>

     <dt>ccAddresses</dt>
       <dd>
         If provided, this should contain a list of the SMTP email addresses
         that should be included in the "Cc:" line of the email.
         Callers must specify at least one "to" or "cc" email address.
       </dd>

     <dt>subject</dt>
       <dd>
         If provided, this should contain the subject line of the email that
         will be sent.  If not provided, the title of the note will be used
         as the subject of the email.
       </dd>

     <dt>message</dt>
       <dd>
         If provided, this is additional personal text that should be included
         into the email as a message from the owner to the recipient(s).
       </dd>
    </dl>

    Attributes:
     - guid
     - note
     - toAddresses
     - ccAddresses
     - subject
     - message
    """


    def __init__(self, guid=None, note=None, toAddresses=None, ccAddresses=None, subject=None, message=None,):
        self.guid = guid
        self.note = note
        self.toAddresses = toAddresses
        self.ccAddresses = ccAddresses
        self.subject = subject
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.note = evernote.edam.type.ttypes.Note()
                    self.note.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.toAddresses = []
                    (_etype161, _size158) = iprot.readListBegin()
                    for _i162 in range(_size158):
                        _elem163 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.toAddresses.append(_elem163)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.ccAddresses = []
                    (_etype167, _size164) = iprot.readListBegin()
                    for _i168 in range(_size164):
                        _elem169 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.ccAddresses.append(_elem169)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.subject = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteEmailParameters')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.note is not None:
            oprot.writeFieldBegin('note', TType.STRUCT, 2)
            self.note.write(oprot)
            oprot.writeFieldEnd()
        if self.toAddresses is not None:
            oprot.writeFieldBegin('toAddresses', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.toAddresses))
            for iter170 in self.toAddresses:
                oprot.writeString(iter170.encode('utf-8') if sys.version_info[0] == 2 else iter170)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccAddresses is not None:
            oprot.writeFieldBegin('ccAddresses', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.ccAddresses))
            for iter171 in self.ccAddresses:
                oprot.writeString(iter171.encode('utf-8') if sys.version_info[0] == 2 else iter171)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.subject is not None:
            oprot.writeFieldBegin('subject', TType.STRING, 5)
            oprot.writeString(self.subject.encode('utf-8') if sys.version_info[0] == 2 else self.subject)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 6)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteVersionId(object):
    """
    Identifying information about previous versions of a note that are backed up
    within Evernote's servers.  Used in the return value of the listNoteVersions
    call.

    <dl>
     <dt>updateSequenceNum</dt>
     <dd>
       The update sequence number for the Note when it last had this content.
       This serves to uniquely identify each version of the note, since USN
       values are unique within an account for each update.
     </dd>
     <dt>updated</dt>
     <dd>
       The 'updated' time that was set on the Note when it had this version
       of the content.  This is the user-modifiable modification time on the
       note, so it's not reliable for guaranteeing the order of various
       versions.  (E.g. if someone modifies the note, then changes this time
       manually into the past and then updates the note again.)
     </dd>
     <dt>saved</dt>
     <dd>
       A timestamp that holds the date and time when this version of the note
       was backed up by Evernote's servers.
     </dd>
     <dt>title</dt>
     <dd>
       The title of the note when this particular version was saved.  (The
       current title of the note may differ from this value.)
     </dd>
     <dt>lastEditorId</dt>
     <dd>
       The ID of the user who made the change to this version of the note. This will be
       unset if the note version was edited by the owner of the account.
     </dd>
    </dl>

    Attributes:
     - updateSequenceNum
     - updated
     - saved
     - title
     - lastEditorId
    """


    def __init__(self, updateSequenceNum=None, updated=None, saved=None, title=None, lastEditorId=None,):
        self.updateSequenceNum = updateSequenceNum
        self.updated = updated
        self.saved = saved
        self.title = title
        self.lastEditorId = lastEditorId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.updateSequenceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.updated = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.saved = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.title = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.lastEditorId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteVersionId')
        if self.updateSequenceNum is not None:
            oprot.writeFieldBegin('updateSequenceNum', TType.I32, 1)
            oprot.writeI32(self.updateSequenceNum)
            oprot.writeFieldEnd()
        if self.updated is not None:
            oprot.writeFieldBegin('updated', TType.I64, 2)
            oprot.writeI64(self.updated)
            oprot.writeFieldEnd()
        if self.saved is not None:
            oprot.writeFieldBegin('saved', TType.I64, 3)
            oprot.writeI64(self.saved)
            oprot.writeFieldEnd()
        if self.title is not None:
            oprot.writeFieldBegin('title', TType.STRING, 4)
            oprot.writeString(self.title.encode('utf-8') if sys.version_info[0] == 2 else self.title)
            oprot.writeFieldEnd()
        if self.lastEditorId is not None:
            oprot.writeFieldBegin('lastEditorId', TType.I32, 5)
            oprot.writeI32(self.lastEditorId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.updateSequenceNum is None:
            raise TProtocolException(message='Required field updateSequenceNum is unset!')
        if self.updated is None:
            raise TProtocolException(message='Required field updated is unset!')
        if self.saved is None:
            raise TProtocolException(message='Required field saved is unset!')
        if self.title is None:
            raise TProtocolException(message='Required field title is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RelatedQuery(object):
    """
    A description of the thing for which we are searching for related
    entities.

    You must specify either <em>noteGuid</em> or <em>plainText</em>, but
    not both. <em>filter</em> and <em>referenceUri</em> are optional.

    <dl>
    <dt>noteGuid</dt>
    <dd>The GUID of an existing note in your account for which related
        entities will be found.</dd>

    <dt>plainText</dt>
    <dd>A string of plain text for which to find related entities.
        You should provide a text block with a number of characters between
        EDAM_RELATED_PLAINTEXT_LEN_MIN and EDAM_RELATED_PLAINTEXT_LEN_MAX.
        </dd>

    <dt>filter</dt>
    <dd>The list of criteria that will constrain the notes being considered
        related.
        Please note that some of the parameters may be ignored, such as
        <em>order</em> and <em>ascending</em>.
    </dd>

    <dt>referenceUri</dt>
    <dd>A URI string specifying a reference entity, around which "relatedness"
        should be based. This can be an URL pointing to a web page, for example.
    </dd>

    <dt>context</dt>
    <dd>Specifies the context to consider when determining related results.
        Clients must leave this value unset unless they wish to explicitly specify a known
        non-default context.
    </dd>

    <dt>cacheKey</dt>
    <dd>If set and non-empty, this is an indicator for the server whether it is actually
        necessary to perform a new findRelated call at all. Cache Keys are opaque strings
        which are returned by the server as part of "RelatedResult" in response
        to a "NoteStore.findRelated" query. Cache Keys are inherently query specific.

        If set to an empty string, this indicates that the server should generate a cache
        key in the response as part of "RelatedResult".

        If not set, the server will not attempt to generate a cache key at all.
    </dd>
    </dl>

    Attributes:
     - noteGuid
     - plainText
     - filter
     - referenceUri
     - context
     - cacheKey
    """


    def __init__(self, noteGuid=None, plainText=None, filter=None, referenceUri=None, context=None, cacheKey=None,):
        self.noteGuid = noteGuid
        self.plainText = plainText
        self.filter = filter
        self.referenceUri = referenceUri
        self.context = context
        self.cacheKey = cacheKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.noteGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.plainText = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.filter = NoteFilter()
                    self.filter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.referenceUri = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.context = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.cacheKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RelatedQuery')
        if self.noteGuid is not None:
            oprot.writeFieldBegin('noteGuid', TType.STRING, 1)
            oprot.writeString(self.noteGuid.encode('utf-8') if sys.version_info[0] == 2 else self.noteGuid)
            oprot.writeFieldEnd()
        if self.plainText is not None:
            oprot.writeFieldBegin('plainText', TType.STRING, 2)
            oprot.writeString(self.plainText.encode('utf-8') if sys.version_info[0] == 2 else self.plainText)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRUCT, 3)
            self.filter.write(oprot)
            oprot.writeFieldEnd()
        if self.referenceUri is not None:
            oprot.writeFieldBegin('referenceUri', TType.STRING, 4)
            oprot.writeString(self.referenceUri.encode('utf-8') if sys.version_info[0] == 2 else self.referenceUri)
            oprot.writeFieldEnd()
        if self.context is not None:
            oprot.writeFieldBegin('context', TType.STRING, 5)
            oprot.writeString(self.context.encode('utf-8') if sys.version_info[0] == 2 else self.context)
            oprot.writeFieldEnd()
        if self.cacheKey is not None:
            oprot.writeFieldBegin('cacheKey', TType.STRING, 6)
            oprot.writeString(self.cacheKey.encode('utf-8') if sys.version_info[0] == 2 else self.cacheKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RelatedResult(object):
    """
    The result of calling findRelated().  The contents of the notes,
    notebooks, and tags fields will be in decreasing order of expected
    relevance.  It is possible that fewer results than requested will be
    returned even if there are enough distinct entities in the account
    in cases where the relevance is estimated to be low.

    <dl>
    <dt>notes</dt>
    <dd>If notes have been requested to be included, this will be the
        list of notes.</dd>

    <dt>notebooks</dt>
    <dd>If notebooks have been requested to be included, this will be the
        list of notebooks.</dd>

    <dt>tags</dt>
    <dd>If tags have been requested to be included, this will be the list
        of tags.</dd>

    <dt>containingNotebooks</dt>
    <dd>If <code>includeContainingNotebooks</code> is set to <code>true</code>
        in the RelatedResultSpec, return the list of notebooks to
        to which the returned related notes belong. The notebooks in this
        list will occur once per notebook GUID and are represented as
        NotebookDescriptor objects.</dd>

    <dt>experts</dt>
    <dd>If experts have been requested to be included, this will return
     a list of users within your business who have knowledge about the specified query.
    </dd>

    <dt>relatedContent</dt>
    <dd>If related content has been requested to be included, this will be the list of
     related content snippets.
    </dd>

    <dt>cacheKey</dt>
    <dd>If set and non-empty, this cache key may be used in subsequent
        "NoteStore.findRelated" calls (via "RelatedQuery") to re-use previous
        responses that were cached on the client-side, instead of actually performing
        another search.

        If set to an empty string, this indicates that the server could not determine
        a specific key for this response, but the client should nevertheless remove
        any previously cached result for this request.

        If unset/null, it is up to the client whether to re-use cached results or to
        use the server's response.

        If set to the exact non-empty cache key that was specified in
        "RelatedQuery.cacheKey", this indicates that the server decided that cached results
        could be reused.

        Depending on the cache key specified in the query, the "RelatedResult" may only be
        partially filled. For each set field, the client should replace the corresponding
        part in the previously cached result with the new partial result.

        For example, for a specific query that has both "RelatedResultSpec.maxNotes" and
        "RelatedResultSpec.maxRelatedContent" set to positive values, the server may decide
        that the previously requested and cached <em>Related Content</em> are unchanged,
        but new results for <em>Related Notes</em> are available. The
        response will have a new cache key and have "RelatedResult.notes" set, but have
        "RelatedResult.relatedContent" unset (not just empty, but really unset).

        In this situation, the client should replace any cached notes with the newly
        returned "RelatedResult.notes", but it can re-use the previously cached entries for
        "RelatedResult.relatedContent". List fields that are set, but empty indicate that
        no results could be found; the cache should be updated correspondingly.
    </dd>

    <dt>cacheExpires</dt>
    <dd> If set, clients should reuse this response for any situations where the same input
         parameters are applicable for up to this many seconds after receiving this result.

         After this time has passed, the client may request a new result from the service,
         but it should supply the stored cacheKey to the service when checking for an
         update.
    </dd>

    </dl>

    Attributes:
     - notes
     - notebooks
     - tags
     - containingNotebooks
     - experts
     - relatedContent
     - cacheKey
     - cacheExpires
    """


    def __init__(self, notes=None, notebooks=None, tags=None, containingNotebooks=None, experts=None, relatedContent=None, cacheKey=None, cacheExpires=None,):
        self.notes = notes
        self.notebooks = notebooks
        self.tags = tags
        self.containingNotebooks = containingNotebooks
        self.experts = experts
        self.relatedContent = relatedContent
        self.cacheKey = cacheKey
        self.cacheExpires = cacheExpires

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.notes = []
                    (_etype175, _size172) = iprot.readListBegin()
                    for _i176 in range(_size172):
                        _elem177 = evernote.edam.type.ttypes.Note()
                        _elem177.read(iprot)
                        self.notes.append(_elem177)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.notebooks = []
                    (_etype181, _size178) = iprot.readListBegin()
                    for _i182 in range(_size178):
                        _elem183 = evernote.edam.type.ttypes.Notebook()
                        _elem183.read(iprot)
                        self.notebooks.append(_elem183)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tags = []
                    (_etype187, _size184) = iprot.readListBegin()
                    for _i188 in range(_size184):
                        _elem189 = evernote.edam.type.ttypes.Tag()
                        _elem189.read(iprot)
                        self.tags.append(_elem189)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.containingNotebooks = []
                    (_etype193, _size190) = iprot.readListBegin()
                    for _i194 in range(_size190):
                        _elem195 = evernote.edam.type.ttypes.NotebookDescriptor()
                        _elem195.read(iprot)
                        self.containingNotebooks.append(_elem195)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.experts = []
                    (_etype199, _size196) = iprot.readListBegin()
                    for _i200 in range(_size196):
                        _elem201 = evernote.edam.type.ttypes.UserProfile()
                        _elem201.read(iprot)
                        self.experts.append(_elem201)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.relatedContent = []
                    (_etype205, _size202) = iprot.readListBegin()
                    for _i206 in range(_size202):
                        _elem207 = evernote.edam.type.ttypes.RelatedContent()
                        _elem207.read(iprot)
                        self.relatedContent.append(_elem207)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.cacheKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.cacheExpires = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RelatedResult')
        if self.notes is not None:
            oprot.writeFieldBegin('notes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.notes))
            for iter208 in self.notes:
                iter208.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.notebooks is not None:
            oprot.writeFieldBegin('notebooks', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.notebooks))
            for iter209 in self.notebooks:
                iter209.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.tags))
            for iter210 in self.tags:
                iter210.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.containingNotebooks is not None:
            oprot.writeFieldBegin('containingNotebooks', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.containingNotebooks))
            for iter211 in self.containingNotebooks:
                iter211.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.experts is not None:
            oprot.writeFieldBegin('experts', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.experts))
            for iter212 in self.experts:
                iter212.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.relatedContent is not None:
            oprot.writeFieldBegin('relatedContent', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.relatedContent))
            for iter213 in self.relatedContent:
                iter213.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cacheKey is not None:
            oprot.writeFieldBegin('cacheKey', TType.STRING, 8)
            oprot.writeString(self.cacheKey.encode('utf-8') if sys.version_info[0] == 2 else self.cacheKey)
            oprot.writeFieldEnd()
        if self.cacheExpires is not None:
            oprot.writeFieldBegin('cacheExpires', TType.I32, 9)
            oprot.writeI32(self.cacheExpires)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RelatedResultSpec(object):
    """
    A description of the thing for which the service will find related
    entities, via findRelated(), together with a description of what
    type of entities and how many you are seeking in the
    RelatedResult.

    <dl>
    <dt>maxNotes</dt>
    <dd>Return notes that are related to the query, but no more than
        this many.  Any value greater than EDAM_RELATED_MAX_NOTES
        will be silently capped.  If you do not set this field, then
        no notes will be returned.</dd>

    <dt>maxNotebooks</dt>
    <dd>Return notebooks that are related to the query, but no more than
        this many.  Any value greater than EDAM_RELATED_MAX_NOTEBOOKS
        will be silently capped.  If you do not set this field, then
        no notebooks will be returned.</dd>

    <dt>maxTags</dt>
    <dd>Return tags that are related to the query, but no more than
        this many.  Any value greater than EDAM_RELATED_MAX_TAGS
        will be silently capped.  If you do not set this field, then
        no tags will be returned.</dd>
    </dl>

    <dt>writableNotebooksOnly</dt>
    <dd>Require that all returned related notebooks are writable.
        The user will be able to create notes in all returned notebooks.
        However, individual notes returned may still belong to notebooks
        in which the user lacks the ability to create notes.</dd>
    </dl>

    <dt>includeContainingNotebooks</dt>
    <dd>If set to <code>true</code>, return the containingNotebooks field
        in the RelatedResult, which will contain the list of notebooks to
        to which the returned related notes belong.</dd>
    </dl>

    <dt>maxExperts</dt>
    <dd>This can only be used when making a findRelated call against a business.
     Find users within your business who have knowledge about the specified query.
     No more than this many users will be returned. Any value greater than
     EDAM_RELATED_MAX_EXPERTS will be silently capped.
    </dd>

    <dt>maxRelatedContent</dt>
    <dd>Return snippets of related content that is related to the query, but no more than
     this many. Any value greater than EDAM_RELATED_MAX_RELATED_CONTENT will be silently
     capped. If you do not set this field, then no related content will be returned.</dd>
    </dl>

    <dt>relatedContentTypes</dt>
    <dd>Specifies the types of Related Content that should be returned.</dd>
    </dl>

    Attributes:
     - maxNotes
     - maxNotebooks
     - maxTags
     - writableNotebooksOnly
     - includeContainingNotebooks
     - maxExperts
     - maxRelatedContent
     - relatedContentTypes
    """


    def __init__(self, maxNotes=None, maxNotebooks=None, maxTags=None, writableNotebooksOnly=None, includeContainingNotebooks=None, maxExperts=None, maxRelatedContent=None, relatedContentTypes=None,):
        self.maxNotes = maxNotes
        self.maxNotebooks = maxNotebooks
        self.maxTags = maxTags
        self.writableNotebooksOnly = writableNotebooksOnly
        self.includeContainingNotebooks = includeContainingNotebooks
        self.maxExperts = maxExperts
        self.maxRelatedContent = maxRelatedContent
        self.relatedContentTypes = relatedContentTypes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.maxNotes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.maxNotebooks = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.maxTags = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.writableNotebooksOnly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.includeContainingNotebooks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.maxExperts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.maxRelatedContent = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.SET:
                    self.relatedContentTypes = set()
                    (_etype217, _size214) = iprot.readSetBegin()
                    for _i218 in range(_size214):
                        _elem219 = iprot.readI32()
                        self.relatedContentTypes.add(_elem219)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RelatedResultSpec')
        if self.maxNotes is not None:
            oprot.writeFieldBegin('maxNotes', TType.I32, 1)
            oprot.writeI32(self.maxNotes)
            oprot.writeFieldEnd()
        if self.maxNotebooks is not None:
            oprot.writeFieldBegin('maxNotebooks', TType.I32, 2)
            oprot.writeI32(self.maxNotebooks)
            oprot.writeFieldEnd()
        if self.maxTags is not None:
            oprot.writeFieldBegin('maxTags', TType.I32, 3)
            oprot.writeI32(self.maxTags)
            oprot.writeFieldEnd()
        if self.writableNotebooksOnly is not None:
            oprot.writeFieldBegin('writableNotebooksOnly', TType.BOOL, 4)
            oprot.writeBool(self.writableNotebooksOnly)
            oprot.writeFieldEnd()
        if self.includeContainingNotebooks is not None:
            oprot.writeFieldBegin('includeContainingNotebooks', TType.BOOL, 5)
            oprot.writeBool(self.includeContainingNotebooks)
            oprot.writeFieldEnd()
        if self.maxExperts is not None:
            oprot.writeFieldBegin('maxExperts', TType.I32, 7)
            oprot.writeI32(self.maxExperts)
            oprot.writeFieldEnd()
        if self.maxRelatedContent is not None:
            oprot.writeFieldBegin('maxRelatedContent', TType.I32, 8)
            oprot.writeI32(self.maxRelatedContent)
            oprot.writeFieldEnd()
        if self.relatedContentTypes is not None:
            oprot.writeFieldBegin('relatedContentTypes', TType.SET, 9)
            oprot.writeSetBegin(TType.I32, len(self.relatedContentTypes))
            for iter220 in self.relatedContentTypes:
                oprot.writeI32(iter220)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UpdateNoteIfUsnMatchesResult(object):
    """
    The result of a call to updateNoteIfUsnMatches, which optionally updates a note
    based on the current value of the note's update sequence number on the service.

    <dl>
    <dt>note</dt>
    <dd>Either the current state of the note if <tt>updated</tt> is false or the
    result of updating the note as would be done via the <tt>updateNote</tt> method.
    If the note was not updated, you will receive a Note that does not include note
    content, resources data, resources recognition data, or resources alternate data.
    You can check for updates to these large objects by checking the Data.bodyHash
    values and downloading accordingly.</dd>

    <dt>updated</dt>
    <dd>Whether or not the note was updated by the operation.</dd>
    </dl>

    Attributes:
     - note
     - updated
    """


    def __init__(self, note=None, updated=None,):
        self.note = note
        self.updated = updated

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.note = evernote.edam.type.ttypes.Note()
                    self.note.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.updated = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateNoteIfUsnMatchesResult')
        if self.note is not None:
            oprot.writeFieldBegin('note', TType.STRUCT, 1)
            self.note.write(oprot)
            oprot.writeFieldEnd()
        if self.updated is not None:
            oprot.writeFieldBegin('updated', TType.BOOL, 2)
            oprot.writeBool(self.updated)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShareRelationshipRestrictions(object):
    """
    Attributes:
     - noSetReadOnly
     - noSetReadPlusActivity
     - noSetModify
     - noSetFullAccess
    """


    def __init__(self, noSetReadOnly=None, noSetReadPlusActivity=None, noSetModify=None, noSetFullAccess=None,):
        self.noSetReadOnly = noSetReadOnly
        self.noSetReadPlusActivity = noSetReadPlusActivity
        self.noSetModify = noSetModify
        self.noSetFullAccess = noSetFullAccess

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.noSetReadOnly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.noSetReadPlusActivity = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.noSetModify = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.noSetFullAccess = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShareRelationshipRestrictions')
        if self.noSetReadOnly is not None:
            oprot.writeFieldBegin('noSetReadOnly', TType.BOOL, 1)
            oprot.writeBool(self.noSetReadOnly)
            oprot.writeFieldEnd()
        if self.noSetReadPlusActivity is not None:
            oprot.writeFieldBegin('noSetReadPlusActivity', TType.BOOL, 2)
            oprot.writeBool(self.noSetReadPlusActivity)
            oprot.writeFieldEnd()
        if self.noSetModify is not None:
            oprot.writeFieldBegin('noSetModify', TType.BOOL, 3)
            oprot.writeBool(self.noSetModify)
            oprot.writeFieldEnd()
        if self.noSetFullAccess is not None:
            oprot.writeFieldBegin('noSetFullAccess', TType.BOOL, 4)
            oprot.writeBool(self.noSetFullAccess)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvitationShareRelationship(object):
    """
    Describes an invitation to a person to use their Evernote
    credentials to become a member of a notebook.

    <dl>
    <dt>displayName</dt>
    <dd>The string that clients should show to users to represent this
    invitation.</dd>

    <dt>recipientUserIdentity</dt>
    <dd>Identifies the recipient of the invitation. The user identity
    type can be either EMAIL or IDENTITYID, depending on whether the
    invitation was created using the classic notebook sharing APIs or
    the new identity-based notebook sharing APIs.
    </dd>

    <dt>privilege</dt>
    <dd>The privilege level at which the member will be joined, if it
    turns out that the member is not already joined at a higher level.
    Note that the <tt>identity</tt> field may not uniquely identify an
    Evernote User ID, and so we won't know until the invitation is
    redeemed whether or not the recipient already has privilege.</dd>

    <dt>sharerUserId</dt>
    <dd>The user id of the user who most recently shared this notebook
    to this identity. This field is used by the service to convey information
    to the user, so clients should treat it as read-only.</dd>
    </dl>

    Attributes:
     - displayName
     - recipientUserIdentity
     - privilege
     - sharerUserId
    """


    def __init__(self, displayName=None, recipientUserIdentity=None, privilege=None, sharerUserId=None,):
        self.displayName = displayName
        self.recipientUserIdentity = recipientUserIdentity
        self.privilege = privilege
        self.sharerUserId = sharerUserId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.displayName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.recipientUserIdentity = evernote.edam.type.ttypes.UserIdentity()
                    self.recipientUserIdentity.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.privilege = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.sharerUserId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvitationShareRelationship')
        if self.displayName is not None:
            oprot.writeFieldBegin('displayName', TType.STRING, 1)
            oprot.writeString(self.displayName.encode('utf-8') if sys.version_info[0] == 2 else self.displayName)
            oprot.writeFieldEnd()
        if self.recipientUserIdentity is not None:
            oprot.writeFieldBegin('recipientUserIdentity', TType.STRUCT, 2)
            self.recipientUserIdentity.write(oprot)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.I32, 3)
            oprot.writeI32(self.privilege)
            oprot.writeFieldEnd()
        if self.sharerUserId is not None:
            oprot.writeFieldBegin('sharerUserId', TType.I32, 5)
            oprot.writeI32(self.sharerUserId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MemberShareRelationship(object):
    """
    Describes the association between a Notebook and an Evernote User who is
    a member of that notebook.

    <dl>
    <dt>displayName</dt>
    <dd>The string that clients should show to users to represent this
    member.</dd>

    <dt>recipientUserId</dt>
    <dd>The Evernote User ID of the recipient of this notebook share.
    </dd>

    <dt>bestPrivilege</dt>
    <dd>The privilege at which the member can access the notebook,
    which is the best privilege granted either individually or to a
    group to which a member belongs, such as a business.  This field is
    used by the service to convey information to the user, so clients
    should treat it as read-only.</dd>

    <dt>individualPrivilege</dt>
    <dd>The individually granted privilege for the member, which does
    not take GROUP privileges into account.  This value may be unset if
    only a group-assigned privilege has been granted to the member.
    This value can be managed by others with sufficient rights using
    the manageNotebookShares method.  The valid values that clients
    should present to users for selection are given via the the
    'restrictions' field.</dd>

    <dt>restrictions</dt>
    <dd>The restrictions on which privileges may be individually
    assigned to the recipient of this share relationship.</dd>

    <dt>sharerUserId</dt>
    <dd>The user id of the user who most recently shared the notebook
    to this user. This field is currently unset for a MemberShareRelationship
    created by joining a notebook that has been published to the business
    (MemberShareRelationships where the individual privilege is unset).
    This field is used by the service to convey information to the user, so
    clients should treat it as read-only.
    </dd>
    </dl>

    Attributes:
     - displayName
     - recipientUserId
     - bestPrivilege
     - individualPrivilege
     - restrictions
     - sharerUserId
    """


    def __init__(self, displayName=None, recipientUserId=None, bestPrivilege=None, individualPrivilege=None, restrictions=None, sharerUserId=None,):
        self.displayName = displayName
        self.recipientUserId = recipientUserId
        self.bestPrivilege = bestPrivilege
        self.individualPrivilege = individualPrivilege
        self.restrictions = restrictions
        self.sharerUserId = sharerUserId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.displayName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.recipientUserId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.bestPrivilege = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.individualPrivilege = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.restrictions = ShareRelationshipRestrictions()
                    self.restrictions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.sharerUserId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MemberShareRelationship')
        if self.displayName is not None:
            oprot.writeFieldBegin('displayName', TType.STRING, 1)
            oprot.writeString(self.displayName.encode('utf-8') if sys.version_info[0] == 2 else self.displayName)
            oprot.writeFieldEnd()
        if self.recipientUserId is not None:
            oprot.writeFieldBegin('recipientUserId', TType.I32, 2)
            oprot.writeI32(self.recipientUserId)
            oprot.writeFieldEnd()
        if self.bestPrivilege is not None:
            oprot.writeFieldBegin('bestPrivilege', TType.I32, 3)
            oprot.writeI32(self.bestPrivilege)
            oprot.writeFieldEnd()
        if self.individualPrivilege is not None:
            oprot.writeFieldBegin('individualPrivilege', TType.I32, 4)
            oprot.writeI32(self.individualPrivilege)
            oprot.writeFieldEnd()
        if self.restrictions is not None:
            oprot.writeFieldBegin('restrictions', TType.STRUCT, 5)
            self.restrictions.write(oprot)
            oprot.writeFieldEnd()
        if self.sharerUserId is not None:
            oprot.writeFieldBegin('sharerUserId', TType.I32, 6)
            oprot.writeI32(self.sharerUserId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShareRelationships(object):
    """
    Captures a collection of share relationships for a notebook, for
    example, as returned by the getNotebookShares method.  The share
    relationships fall into two broad categories: members, and
    invitations that can be used to become members.

    <dl>
    <dt>invitations</dt>
    <dd>A list of open invitations that can be redeemed into
    memberships to the notebook.</dd>

    <dt>memberships</dt>
    <dd>A list of memberships of the notebook.  A member is identified
    by their Evernote UserID and has rights to access the
    notebook.</dd>

    <dt>invitationRestrictions</dt>
    <dd>The restrictions on what privileges may be granted to invitees
    to this notebook. These restrictions may be specific to the calling
    user or to the notebook itself. They represent the
    union of all possible invite cases, so it is possible that once the
    recipient of the invitation has been identified by the service, such
    as by a business auto-join, the actual assigned privilege may change.
    </dd>
    </dl>

    Attributes:
     - invitations
     - memberships
     - invitationRestrictions
    """


    def __init__(self, invitations=None, memberships=None, invitationRestrictions=None,):
        self.invitations = invitations
        self.memberships = memberships
        self.invitationRestrictions = invitationRestrictions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.invitations = []
                    (_etype224, _size221) = iprot.readListBegin()
                    for _i225 in range(_size221):
                        _elem226 = InvitationShareRelationship()
                        _elem226.read(iprot)
                        self.invitations.append(_elem226)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.memberships = []
                    (_etype230, _size227) = iprot.readListBegin()
                    for _i231 in range(_size227):
                        _elem232 = MemberShareRelationship()
                        _elem232.read(iprot)
                        self.memberships.append(_elem232)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.invitationRestrictions = ShareRelationshipRestrictions()
                    self.invitationRestrictions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShareRelationships')
        if self.invitations is not None:
            oprot.writeFieldBegin('invitations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.invitations))
            for iter233 in self.invitations:
                iter233.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.memberships is not None:
            oprot.writeFieldBegin('memberships', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.memberships))
            for iter234 in self.memberships:
                iter234.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.invitationRestrictions is not None:
            oprot.writeFieldBegin('invitationRestrictions', TType.STRUCT, 3)
            self.invitationRestrictions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ManageNotebookSharesParameters(object):
    """
    A structure that captures parameters used by clients to manage the
    shares for a given notebook via the manageNotebookShares method.

    <dl>
    <dt>notebookGuid</dt>
    <dd>The GUID of the notebook whose shares are being managed.</dd>

    <dt>inviteMessage</dt>
    <dd>If the service sends a message to invitees, this parameter will
    be used to form the actual message that is sent.</dd>

    <dt>membershipsToUpdate</dt>
    <dd>The list of existing memberships to update.  This field is not
    intended to be the full set of memberships for the notebook and
    should only include those already-existing memberships that you
    actually want to change.  If you want to remove shares, see the
    unshares fields.  If you want to create a membership,
    i.e. auto-join a business user, you can do this via the
    invitationsToCreateOrUpdate field using an Evernote UserID of a
    fellow business member (the created invitation is automatically
    joined by the service, so the client is creating an
    invitation, not a membership).</dd>

    <dt>invitationsToCreateOrUpdate</dt>
    <dd>The list of invitations to update, as matched by the identity
    field of the InvitationShareRelationship instances, or to create if
    an existing invitation does not exist.  This field is not intended
    to be the full set of invitations on the notebook and should only
    include those invitations that you wish to create or update.  Note
    that your invitation could convert into a membership via a
    service-supported auto-join operation.  This happens, for example,
    when you use an invitation with an Evernote UserID type for a
    recipient who is a member of the business to which the notebook
    belongs.  Note that to discover the user IDs for business members,
    the sharer must also be part of the business.</dd>

    <dt>unshares</dt>
    <dd>The list of share relationships to expunge from the service.
    If the user identity is for an Evernote UserID, then memberships will
    be removed. If it's an e-mail, then e-mail based shared notebook
    invitations will be removed. If it's for an Identity ID, then
    any invitations that match the identity (by identity ID or user ID or
    e-mail for legacy invitations) will be removed.</dd>
    </dl>

    Attributes:
     - notebookGuid
     - inviteMessage
     - membershipsToUpdate
     - invitationsToCreateOrUpdate
     - unshares
    """


    def __init__(self, notebookGuid=None, inviteMessage=None, membershipsToUpdate=None, invitationsToCreateOrUpdate=None, unshares=None,):
        self.notebookGuid = notebookGuid
        self.inviteMessage = inviteMessage
        self.membershipsToUpdate = membershipsToUpdate
        self.invitationsToCreateOrUpdate = invitationsToCreateOrUpdate
        self.unshares = unshares

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.notebookGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.inviteMessage = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.membershipsToUpdate = []
                    (_etype238, _size235) = iprot.readListBegin()
                    for _i239 in range(_size235):
                        _elem240 = MemberShareRelationship()
                        _elem240.read(iprot)
                        self.membershipsToUpdate.append(_elem240)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.invitationsToCreateOrUpdate = []
                    (_etype244, _size241) = iprot.readListBegin()
                    for _i245 in range(_size241):
                        _elem246 = InvitationShareRelationship()
                        _elem246.read(iprot)
                        self.invitationsToCreateOrUpdate.append(_elem246)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.unshares = []
                    (_etype250, _size247) = iprot.readListBegin()
                    for _i251 in range(_size247):
                        _elem252 = evernote.edam.type.ttypes.UserIdentity()
                        _elem252.read(iprot)
                        self.unshares.append(_elem252)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ManageNotebookSharesParameters')
        if self.notebookGuid is not None:
            oprot.writeFieldBegin('notebookGuid', TType.STRING, 1)
            oprot.writeString(self.notebookGuid.encode('utf-8') if sys.version_info[0] == 2 else self.notebookGuid)
            oprot.writeFieldEnd()
        if self.inviteMessage is not None:
            oprot.writeFieldBegin('inviteMessage', TType.STRING, 2)
            oprot.writeString(self.inviteMessage.encode('utf-8') if sys.version_info[0] == 2 else self.inviteMessage)
            oprot.writeFieldEnd()
        if self.membershipsToUpdate is not None:
            oprot.writeFieldBegin('membershipsToUpdate', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.membershipsToUpdate))
            for iter253 in self.membershipsToUpdate:
                iter253.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.invitationsToCreateOrUpdate is not None:
            oprot.writeFieldBegin('invitationsToCreateOrUpdate', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.invitationsToCreateOrUpdate))
            for iter254 in self.invitationsToCreateOrUpdate:
                iter254.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.unshares is not None:
            oprot.writeFieldBegin('unshares', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.unshares))
            for iter255 in self.unshares:
                iter255.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ManageNotebookSharesError(object):
    """
    A structure to capture certain errors that occurred during a call
    to manageNotebookShares.  That method can be run best-effort,
    meaning that some change requests can be applied while others fail.
    Note that some errors such as system errors will still fail the
    entire transaction regardless of running best effort.  When some
    change requests do not succeed, the error conditions are captured
    in instances of this class, captured by the identity of the share
    relationship and one of the exception fields.

    <dl>
    <dt>userIdentity</dt>
    <dd>The identity of the share relationship whose update encountered
    an error.</dd>

    <dt>userException</dt>
    <dd>If the error is represented as an EDAMUserException that would
    have otherwise been thrown without best-effort execution.  Only one
    exception field will be set.</dd>

    <dt>notFoundException</dt>
    <dd>If the error is represented as an EDAMNotFoundException that would
    have otherwise been thrown without best-effort execution.  Only one
    exception field will be set.</dd>
    </dl>

    Attributes:
     - userIdentity
     - userException
     - notFoundException
    """


    def __init__(self, userIdentity=None, userException=None, notFoundException=None,):
        self.userIdentity = userIdentity
        self.userException = userException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userIdentity = evernote.edam.type.ttypes.UserIdentity()
                    self.userIdentity.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ManageNotebookSharesError')
        if self.userIdentity is not None:
            oprot.writeFieldBegin('userIdentity', TType.STRUCT, 1)
            self.userIdentity.write(oprot)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 2)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ManageNotebookSharesResult(object):
    """
    The return value of a call to the manageNotebookShares method.

    <dl>
    <dt>errors</dt>
    <dd>If the method completed without throwing exceptions, some errors
    might still have occurred, and in that case, this field will contain
    the list of those errors the occurred.
    </dd>
    </dl>

    Attributes:
     - errors
    """


    def __init__(self, errors=None,):
        self.errors = errors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.errors = []
                    (_etype259, _size256) = iprot.readListBegin()
                    for _i260 in range(_size256):
                        _elem261 = ManageNotebookSharesError()
                        _elem261.read(iprot)
                        self.errors.append(_elem261)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ManageNotebookSharesResult')
        if self.errors is not None:
            oprot.writeFieldBegin('errors', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.errors))
            for iter262 in self.errors:
                iter262.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SharedNoteTemplate(object):
    """
    A structure used to share a note with one or more recipients at a given privilege.

    <dl>
      <dt>noteGuid</dt>
      <dd>The GUID of the note.</dd>

      <dt>recipientThreadId</dt>
      <dd>The recipients of the note share specified as a messaging thread ID. If you
          have an existing messaging thread to share the note with, specify its ID
          here instead of recipientContacts in order to properly support defunct
          identities. The sharer must be a participant of the thread. Either this
          field or recipientContacts must be set.</dd>

      <dt>recipientContacts</dt>
      <dd>The recipients of the note share specified as a list of contacts. This should
          only be set if the sharing takes place before the thread is created. Use
          recipientThreadId instead when sharing with an existing thread. Either this
          field or recipientThreadId must be set.</dd>

      <dt>privilege</dt>
      <dd>The privilege level to be granted.</dd>
    </dl>

    Attributes:
     - noteGuid
     - recipientThreadId
     - recipientContacts
     - privilege
    """


    def __init__(self, noteGuid=None, recipientThreadId=None, recipientContacts=None, privilege=None,):
        self.noteGuid = noteGuid
        self.recipientThreadId = recipientThreadId
        self.recipientContacts = recipientContacts
        self.privilege = privilege

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.noteGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.recipientThreadId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.recipientContacts = []
                    (_etype266, _size263) = iprot.readListBegin()
                    for _i267 in range(_size263):
                        _elem268 = evernote.edam.type.ttypes.Contact()
                        _elem268.read(iprot)
                        self.recipientContacts.append(_elem268)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.privilege = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SharedNoteTemplate')
        if self.noteGuid is not None:
            oprot.writeFieldBegin('noteGuid', TType.STRING, 1)
            oprot.writeString(self.noteGuid.encode('utf-8') if sys.version_info[0] == 2 else self.noteGuid)
            oprot.writeFieldEnd()
        if self.recipientContacts is not None:
            oprot.writeFieldBegin('recipientContacts', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.recipientContacts))
            for iter269 in self.recipientContacts:
                iter269.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.I32, 3)
            oprot.writeI32(self.privilege)
            oprot.writeFieldEnd()
        if self.recipientThreadId is not None:
            oprot.writeFieldBegin('recipientThreadId', TType.I64, 4)
            oprot.writeI64(self.recipientThreadId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NotebookShareTemplate(object):
    """
    A structure used to share a notebook with one or more recipients at a given privilege.

    <dl>
      <dt>notebookGuid</dt>
      <dd>The GUID of the notebook.</dd>

      <dt>recipientThreadId</dt>
      <dd>The recipients of the notebook share specified as a messaging thread ID. If you
          have an existing messaging thread to share the note with, specify its ID
          here instead of recipientContacts in order to properly support defunct
          identities. The sharer must be a participant of the thread. Either this field
          or recipientContacts must be set.</dd>

      <dt>recipientContacts</dt>
      <dd>The recipients of the notebook share specified as a list of contacts. This should
          only be set if the sharing takes place before the thread is created. Use
          recipientThreadId instead when sharing with an existing thread. Either this
          field or recipientThreadId must be set.</dd>

      <dt>privilege</dt>
      <dd>The privilege level to be granted.</dd>
    </dl>

    Attributes:
     - notebookGuid
     - recipientThreadId
     - recipientContacts
     - privilege
    """


    def __init__(self, notebookGuid=None, recipientThreadId=None, recipientContacts=None, privilege=None,):
        self.notebookGuid = notebookGuid
        self.recipientThreadId = recipientThreadId
        self.recipientContacts = recipientContacts
        self.privilege = privilege

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.notebookGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.recipientThreadId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.recipientContacts = []
                    (_etype273, _size270) = iprot.readListBegin()
                    for _i274 in range(_size270):
                        _elem275 = evernote.edam.type.ttypes.Contact()
                        _elem275.read(iprot)
                        self.recipientContacts.append(_elem275)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.privilege = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotebookShareTemplate')
        if self.notebookGuid is not None:
            oprot.writeFieldBegin('notebookGuid', TType.STRING, 1)
            oprot.writeString(self.notebookGuid.encode('utf-8') if sys.version_info[0] == 2 else self.notebookGuid)
            oprot.writeFieldEnd()
        if self.recipientContacts is not None:
            oprot.writeFieldBegin('recipientContacts', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.recipientContacts))
            for iter276 in self.recipientContacts:
                iter276.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.I32, 3)
            oprot.writeI32(self.privilege)
            oprot.writeFieldEnd()
        if self.recipientThreadId is not None:
            oprot.writeFieldBegin('recipientThreadId', TType.I64, 4)
            oprot.writeI64(self.recipientThreadId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateOrUpdateNotebookSharesResult(object):
    """
    A structure containing the results of a call to createOrUpdateNotebookShares.

    <dl>
      <dt>updateSequenceNum</dt>
      <dd>The USN of the notebook after the call.</dd>

      <dt>matchingShares</dt>
      <dd>A list of SharedNotebook records that match the desired recipients. These
          records may have been either created or updated by the call to
          createOrUpdateNotebookShares, or they may have been at the desired privilege
          privilege level prior to the call.</dd>
    </dl>

    Attributes:
     - updateSequenceNum
     - matchingShares
    """


    def __init__(self, updateSequenceNum=None, matchingShares=None,):
        self.updateSequenceNum = updateSequenceNum
        self.matchingShares = matchingShares

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.updateSequenceNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.matchingShares = []
                    (_etype280, _size277) = iprot.readListBegin()
                    for _i281 in range(_size277):
                        _elem282 = evernote.edam.type.ttypes.SharedNotebook()
                        _elem282.read(iprot)
                        self.matchingShares.append(_elem282)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateOrUpdateNotebookSharesResult')
        if self.updateSequenceNum is not None:
            oprot.writeFieldBegin('updateSequenceNum', TType.I32, 1)
            oprot.writeI32(self.updateSequenceNum)
            oprot.writeFieldEnd()
        if self.matchingShares is not None:
            oprot.writeFieldBegin('matchingShares', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.matchingShares))
            for iter283 in self.matchingShares:
                iter283.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteShareRelationshipRestrictions(object):
    """
    This structure is used by the service to communicate to clients, via
    getNoteShareRelationships, which privilege levels are assignable to the
    target of a note share relationship.

    <dl>
    <dt>noSetReadNote</dt>
    <dd>This value is true if the user is not allowed to set the privilege
    level to SharedNotePrivilegeLevel.READ_NOTE.</dd>

    <dt>noSetModifyNote</dt>
    <dd>This value is true if the user is not allowed to set the privilege
    level to SharedNotePrivilegeLevel.MODIFY_NOTE.</dd>

    <dt>noSetFullAccess</dt>
    <dd>This value is true if the user is not allowed to set the
    privilege level to SharedNotePrivilegeLevel.FULL_ACCESS.</dd>
    </dl>

    Attributes:
     - noSetReadNote
     - noSetModifyNote
     - noSetFullAccess
    """


    def __init__(self, noSetReadNote=None, noSetModifyNote=None, noSetFullAccess=None,):
        self.noSetReadNote = noSetReadNote
        self.noSetModifyNote = noSetModifyNote
        self.noSetFullAccess = noSetFullAccess

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.noSetReadNote = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.noSetModifyNote = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.noSetFullAccess = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteShareRelationshipRestrictions')
        if self.noSetReadNote is not None:
            oprot.writeFieldBegin('noSetReadNote', TType.BOOL, 1)
            oprot.writeBool(self.noSetReadNote)
            oprot.writeFieldEnd()
        if self.noSetModifyNote is not None:
            oprot.writeFieldBegin('noSetModifyNote', TType.BOOL, 2)
            oprot.writeBool(self.noSetModifyNote)
            oprot.writeFieldEnd()
        if self.noSetFullAccess is not None:
            oprot.writeFieldBegin('noSetFullAccess', TType.BOOL, 3)
            oprot.writeBool(self.noSetFullAccess)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteMemberShareRelationship(object):
    """
    Describes the association between a Note and an Evernote User who is
    a member of that note.

    <dl>
    <dt>displayName</dt>
    <dd>The string that clients should show to users to represent this
    member.</dd>

    <dt>recipientUserId</dt>
    <dd>The Evernote UserID of the user who is a member to the note.</dd>

    <dt>privilege</dt>
    <dd>The privilege at which the member can access the note,
    which is the best privilege granted to the user across all of their
    individual shares for this note. This field is used by the service
    to convey information to the user, so clients should treat it as
    read-only.</dd>

    <dt>restrictions</dt>
    <dd>The restrictions on which privileges may be individually
    assigned to the recipient of this share relationship. This field
    is used by the service to convey information to the user, so
    clients should treat it as read-only.</dd>

    <dt>sharerUserId</dt>
    <dd>The user id of the user who most recently shared the note with
    this user. This field is used by the service to convey information
    to the user, so clients should treat it as read-only.</dd>
    </dl>

    Attributes:
     - displayName
     - recipientUserId
     - privilege
     - restrictions
     - sharerUserId
    """


    def __init__(self, displayName=None, recipientUserId=None, privilege=None, restrictions=None, sharerUserId=None,):
        self.displayName = displayName
        self.recipientUserId = recipientUserId
        self.privilege = privilege
        self.restrictions = restrictions
        self.sharerUserId = sharerUserId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.displayName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.recipientUserId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.privilege = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.restrictions = NoteShareRelationshipRestrictions()
                    self.restrictions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.sharerUserId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteMemberShareRelationship')
        if self.displayName is not None:
            oprot.writeFieldBegin('displayName', TType.STRING, 1)
            oprot.writeString(self.displayName.encode('utf-8') if sys.version_info[0] == 2 else self.displayName)
            oprot.writeFieldEnd()
        if self.recipientUserId is not None:
            oprot.writeFieldBegin('recipientUserId', TType.I32, 2)
            oprot.writeI32(self.recipientUserId)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.I32, 3)
            oprot.writeI32(self.privilege)
            oprot.writeFieldEnd()
        if self.restrictions is not None:
            oprot.writeFieldBegin('restrictions', TType.STRUCT, 4)
            self.restrictions.write(oprot)
            oprot.writeFieldEnd()
        if self.sharerUserId is not None:
            oprot.writeFieldBegin('sharerUserId', TType.I32, 5)
            oprot.writeI32(self.sharerUserId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteInvitationShareRelationship(object):
    """
    Describes an invitation to a person to use their Evernote credentials
    to gain access to a note belonging to another user.

    <dl>
    <dt>displayName</dt>
    <dd>The string that clients should show to users to represent this
    invitation.</dd>

    <dt>recipientIdentityId</dt>
    <dd>Identifies the identity of the invitation recipient. Once the
    identity has been claimed by an Evernote user and they have accessed
    the note at least once, the invitation will be used up and will no
    longer be returned by the service to clients. Instead, that recipient
    will be included in the list of NoteMemberShareRelationships.</dd>

    <dt>privilege</dt>
    <dd>The privilege level that the recipient will be granted when they
    accept this invitation. If the user already has a higher privilege to
    access this note then this will not affect the recipient's privileges.</dd>

    <dt>sharerUserId</dt>
    <dd>The user id of the user who most recently shared this note to this
    recipient. This field is used by the service to convey information
    to the user, so clients should treat it as read-only.</dd>

    Attributes:
     - displayName
     - recipientIdentityId
     - privilege
     - sharerUserId
    """


    def __init__(self, displayName=None, recipientIdentityId=None, privilege=None, sharerUserId=None,):
        self.displayName = displayName
        self.recipientIdentityId = recipientIdentityId
        self.privilege = privilege
        self.sharerUserId = sharerUserId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.displayName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.recipientIdentityId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.privilege = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.sharerUserId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteInvitationShareRelationship')
        if self.displayName is not None:
            oprot.writeFieldBegin('displayName', TType.STRING, 1)
            oprot.writeString(self.displayName.encode('utf-8') if sys.version_info[0] == 2 else self.displayName)
            oprot.writeFieldEnd()
        if self.recipientIdentityId is not None:
            oprot.writeFieldBegin('recipientIdentityId', TType.I64, 2)
            oprot.writeI64(self.recipientIdentityId)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.I32, 3)
            oprot.writeI32(self.privilege)
            oprot.writeFieldEnd()
        if self.sharerUserId is not None:
            oprot.writeFieldBegin('sharerUserId', TType.I32, 5)
            oprot.writeI32(self.sharerUserId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NoteShareRelationships(object):
    """
    Captures a collection of share relationships for a single note,
    for example, as returned by the getNoteShares method. The share
    relationships fall into two broad categories: members, and
    invitations that can be used to become members.

    <dl>
    <dt>invitations</dt>
    <dd>A list of open invitations that can be redeemed into
    memberships to the note.</dd>

    <dt>memberships</dt>
    <dd>A list of memberships of the noteb. A member is identified
    by their Evernote UserID and has rights to access the
    note.</dd>

    <dt>restrictions</dt>
    <dd>The restrictions on which privileges may be assigned to the recipient
    of an open invitation. These restrictions only apply to invitations;
    restrictions on memberships are specified on the NoteMemberShareRelationship.
    This field is used by the service to convey information to the user, so
    clients should treat it as read-only.</dd>

    </dl>

    Attributes:
     - invitations
     - memberships
     - invitationRestrictions
    """


    def __init__(self, invitations=None, memberships=None, invitationRestrictions=None,):
        self.invitations = invitations
        self.memberships = memberships
        self.invitationRestrictions = invitationRestrictions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.invitations = []
                    (_etype287, _size284) = iprot.readListBegin()
                    for _i288 in range(_size284):
                        _elem289 = NoteInvitationShareRelationship()
                        _elem289.read(iprot)
                        self.invitations.append(_elem289)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.memberships = []
                    (_etype293, _size290) = iprot.readListBegin()
                    for _i294 in range(_size290):
                        _elem295 = NoteMemberShareRelationship()
                        _elem295.read(iprot)
                        self.memberships.append(_elem295)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.invitationRestrictions = NoteShareRelationshipRestrictions()
                    self.invitationRestrictions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NoteShareRelationships')
        if self.invitations is not None:
            oprot.writeFieldBegin('invitations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.invitations))
            for iter296 in self.invitations:
                iter296.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.memberships is not None:
            oprot.writeFieldBegin('memberships', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.memberships))
            for iter297 in self.memberships:
                iter297.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.invitationRestrictions is not None:
            oprot.writeFieldBegin('invitationRestrictions', TType.STRUCT, 3)
            self.invitationRestrictions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ManageNoteSharesParameters(object):
    """
    Captures parameters used by clients to manage the shares for a given
    note via the manageNoteShares function. This is used only to manage
    the existing memberships and invitations for a note. To invite a new
    recipient, use NoteStore.createOrUpdateSharedNotes.

    The only field of an existing membership or invitation that can be
    updated by this function is the share privilege.

    <dl>
      <dt>noteGuid</dt>
      <dd>The GUID of the note whose shares are being managed.</dd>

      <dt>membershipsToUpdate</dt>
      <dd>A list of existing memberships to update. This field is not
        meant to be the full set of memberships for the note. Clients
        should only include those existing memberships that they wish
        to modify. To remove an existing membership, see the unshares
        field.</dd>

      <dt>invitationsToUpdate</dt>
      <dd>The list of outstanding invitations to update, as matched by the
        identity field of the NoteInvitationShareRelatioship instances.
        This field is not meant to be the full set of invitations for the
        note. Clients should only include those existing invitations that
        they wish to modify.</dd>

      <dt>membershipsToUnshare</dt>
      <dd>A list of existing memberships to expunge from the service.</dd>

      <dt>invitationsToUnshare</dt>
      <dd>A list of outstanding invitations to expunge from the service.</dd>
    </dl>

    Attributes:
     - noteGuid
     - membershipsToUpdate
     - invitationsToUpdate
     - membershipsToUnshare
     - invitationsToUnshare
    """


    def __init__(self, noteGuid=None, membershipsToUpdate=None, invitationsToUpdate=None, membershipsToUnshare=None, invitationsToUnshare=None,):
        self.noteGuid = noteGuid
        self.membershipsToUpdate = membershipsToUpdate
        self.invitationsToUpdate = invitationsToUpdate
        self.membershipsToUnshare = membershipsToUnshare
        self.invitationsToUnshare = invitationsToUnshare

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.noteGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.membershipsToUpdate = []
                    (_etype301, _size298) = iprot.readListBegin()
                    for _i302 in range(_size298):
                        _elem303 = NoteMemberShareRelationship()
                        _elem303.read(iprot)
                        self.membershipsToUpdate.append(_elem303)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.invitationsToUpdate = []
                    (_etype307, _size304) = iprot.readListBegin()
                    for _i308 in range(_size304):
                        _elem309 = NoteInvitationShareRelationship()
                        _elem309.read(iprot)
                        self.invitationsToUpdate.append(_elem309)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.membershipsToUnshare = []
                    (_etype313, _size310) = iprot.readListBegin()
                    for _i314 in range(_size310):
                        _elem315 = iprot.readI32()
                        self.membershipsToUnshare.append(_elem315)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.invitationsToUnshare = []
                    (_etype319, _size316) = iprot.readListBegin()
                    for _i320 in range(_size316):
                        _elem321 = iprot.readI64()
                        self.invitationsToUnshare.append(_elem321)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ManageNoteSharesParameters')
        if self.noteGuid is not None:
            oprot.writeFieldBegin('noteGuid', TType.STRING, 1)
            oprot.writeString(self.noteGuid.encode('utf-8') if sys.version_info[0] == 2 else self.noteGuid)
            oprot.writeFieldEnd()
        if self.membershipsToUpdate is not None:
            oprot.writeFieldBegin('membershipsToUpdate', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.membershipsToUpdate))
            for iter322 in self.membershipsToUpdate:
                iter322.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.invitationsToUpdate is not None:
            oprot.writeFieldBegin('invitationsToUpdate', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.invitationsToUpdate))
            for iter323 in self.invitationsToUpdate:
                iter323.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.membershipsToUnshare is not None:
            oprot.writeFieldBegin('membershipsToUnshare', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.membershipsToUnshare))
            for iter324 in self.membershipsToUnshare:
                oprot.writeI32(iter324)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.invitationsToUnshare is not None:
            oprot.writeFieldBegin('invitationsToUnshare', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.invitationsToUnshare))
            for iter325 in self.invitationsToUnshare:
                oprot.writeI64(iter325)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ManageNoteSharesError(object):
    """
    Captures errors that occur during a call to manageNoteShares. That
    function can be run best-effort, meaning that some change requests can
    be applied while others fail. Note that some errors such as system
    exceptions may still cause the entire call to fail.

    Only one of the two ID fields will be set on a given error.

    Only one of the two exception fields will be set on a given error.

    <dl>
      <dt>identityID</dt>
      <dd>The identity ID of an outstanding invitation that was not updated
        due to the error.</dd>

      <dt>userID</dt>
      <dd>The user ID of an existing membership that was not updated due
        to the error.</dd>

      <dt>userException</dt>
      <dd>If the error is represented as an EDAMUserException that would
        have otherwise been thrown without best-effort execution.</dd>

      <dt>notFoundException</dt>
      <dd>If the error is represented as an EDAMNotFoundException that
        would have otherwise been thrown without best-effort execution.
        The identifier field of the exception will be either "Identity.id"
        or "User.id", indicating that no existing share could be found for
        the specified recipient.</dd>
    </dl>

    Attributes:
     - identityID
     - userID
     - userException
     - notFoundException
    """


    def __init__(self, identityID=None, userID=None, userException=None, notFoundException=None,):
        self.identityID = identityID
        self.userID = userID
        self.userException = userException
        self.notFoundException = notFoundException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.identityID = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.userID = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.userException = evernote.edam.error.ttypes.EDAMUserException()
                    self.userException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
                    self.notFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ManageNoteSharesError')
        if self.identityID is not None:
            oprot.writeFieldBegin('identityID', TType.I64, 1)
            oprot.writeI64(self.identityID)
            oprot.writeFieldEnd()
        if self.userID is not None:
            oprot.writeFieldBegin('userID', TType.I32, 2)
            oprot.writeI32(self.userID)
            oprot.writeFieldEnd()
        if self.userException is not None:
            oprot.writeFieldBegin('userException', TType.STRUCT, 3)
            self.userException.write(oprot)
            oprot.writeFieldEnd()
        if self.notFoundException is not None:
            oprot.writeFieldBegin('notFoundException', TType.STRUCT, 4)
            self.notFoundException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ManageNoteSharesResult(object):
    """
    The return value of a call to the manageNoteShares function.

    <dl>
      <dt>errors</dt>
      <dd>If the call succeeded without throwing an exception, some errors
        might still have occurred. In that case, this field will contain the
        list of errors.</dd>
    </dl>

    Attributes:
     - errors
    """


    def __init__(self, errors=None,):
        self.errors = errors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.errors = []
                    (_etype329, _size326) = iprot.readListBegin()
                    for _i330 in range(_size326):
                        _elem331 = ManageNoteSharesError()
                        _elem331.read(iprot)
                        self.errors.append(_elem331)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ManageNoteSharesResult')
        if self.errors is not None:
            oprot.writeFieldBegin('errors', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.errors))
            for iter332 in self.errors:
                iter332.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SyncState)
SyncState.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'currentTime', None, None, ),  # 1
    (2, TType.I64, 'fullSyncBefore', None, None, ),  # 2
    (3, TType.I32, 'updateCount', None, None, ),  # 3
    (4, TType.I64, 'uploaded', None, None, ),  # 4
    (5, TType.I64, 'userLastUpdated', None, None, ),  # 5
    (6, TType.I64, 'userMaxMessageEventId', None, None, ),  # 6
)
all_structs.append(SyncChunk)
SyncChunk.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'currentTime', None, None, ),  # 1
    (2, TType.I32, 'chunkHighUSN', None, None, ),  # 2
    (3, TType.I32, 'updateCount', None, None, ),  # 3
    (4, TType.LIST, 'notes', (TType.STRUCT, [evernote.edam.type.ttypes.Note, None], False), None, ),  # 4
    (5, TType.LIST, 'notebooks', (TType.STRUCT, [evernote.edam.type.ttypes.Notebook, None], False), None, ),  # 5
    (6, TType.LIST, 'tags', (TType.STRUCT, [evernote.edam.type.ttypes.Tag, None], False), None, ),  # 6
    (7, TType.LIST, 'searches', (TType.STRUCT, [evernote.edam.type.ttypes.SavedSearch, None], False), None, ),  # 7
    (8, TType.LIST, 'resources', (TType.STRUCT, [evernote.edam.type.ttypes.Resource, None], False), None, ),  # 8
    (9, TType.LIST, 'expungedNotes', (TType.STRING, 'UTF8', False), None, ),  # 9
    (10, TType.LIST, 'expungedNotebooks', (TType.STRING, 'UTF8', False), None, ),  # 10
    (11, TType.LIST, 'expungedTags', (TType.STRING, 'UTF8', False), None, ),  # 11
    (12, TType.LIST, 'expungedSearches', (TType.STRING, 'UTF8', False), None, ),  # 12
    (13, TType.LIST, 'linkedNotebooks', (TType.STRUCT, [evernote.edam.type.ttypes.LinkedNotebook, None], False), None, ),  # 13
    (14, TType.LIST, 'expungedLinkedNotebooks', (TType.STRING, 'UTF8', False), None, ),  # 14
)
all_structs.append(SyncChunkFilter)
SyncChunkFilter.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'includeNotes', None, None, ),  # 1
    (2, TType.BOOL, 'includeNoteResources', None, None, ),  # 2
    (3, TType.BOOL, 'includeNoteAttributes', None, None, ),  # 3
    (4, TType.BOOL, 'includeNotebooks', None, None, ),  # 4
    (5, TType.BOOL, 'includeTags', None, None, ),  # 5
    (6, TType.BOOL, 'includeSearches', None, None, ),  # 6
    (7, TType.BOOL, 'includeResources', None, None, ),  # 7
    (8, TType.BOOL, 'includeLinkedNotebooks', None, None, ),  # 8
    (9, TType.BOOL, 'includeExpunged', None, None, ),  # 9
    (10, TType.BOOL, 'includeNoteApplicationDataFullMap', None, None, ),  # 10
    (11, TType.STRING, 'requireNoteContentClass', 'UTF8', None, ),  # 11
    (12, TType.BOOL, 'includeResourceApplicationDataFullMap', None, None, ),  # 12
    (13, TType.BOOL, 'includeNoteResourceApplicationDataFullMap', None, None, ),  # 13
    None,  # 14
    (15, TType.SET, 'notebookGuids', (TType.STRING, 'UTF8', False), None, ),  # 15
    (16, TType.BOOL, 'omitSharedNotebooks', None, None, ),  # 16
    (17, TType.BOOL, 'includeSharedNotes', None, None, ),  # 17
)
all_structs.append(NoteFilter)
NoteFilter.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'order', None, None, ),  # 1
    (2, TType.BOOL, 'ascending', None, None, ),  # 2
    (3, TType.STRING, 'words', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'notebookGuid', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'tagGuids', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.STRING, 'timeZone', 'UTF8', None, ),  # 6
    (7, TType.BOOL, 'inactive', None, None, ),  # 7
    (8, TType.STRING, 'emphasized', 'UTF8', None, ),  # 8
    (9, TType.BOOL, 'includeAllReadableNotebooks', None, None, ),  # 9
    (10, TType.STRING, 'context', 'UTF8', None, ),  # 10
)
all_structs.append(NoteList)
NoteList.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'startIndex', None, None, ),  # 1
    (2, TType.I32, 'totalNotes', None, None, ),  # 2
    (3, TType.LIST, 'notes', (TType.STRUCT, [evernote.edam.type.ttypes.Note, None], False), None, ),  # 3
    (4, TType.LIST, 'stoppedWords', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'searchedWords', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.I32, 'updateCount', None, None, ),  # 6
)
all_structs.append(NoteMetadata)
NoteMetadata.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'title', 'UTF8', None, ),  # 2
    None,  # 3
    None,  # 4
    (5, TType.I32, 'contentLength', None, None, ),  # 5
    (6, TType.I64, 'created', None, None, ),  # 6
    (7, TType.I64, 'updated', None, None, ),  # 7
    (8, TType.I64, 'deleted', None, None, ),  # 8
    None,  # 9
    (10, TType.I32, 'updateSequenceNum', None, None, ),  # 10
    (11, TType.STRING, 'notebookGuid', 'UTF8', None, ),  # 11
    (12, TType.LIST, 'tagGuids', (TType.STRING, 'UTF8', False), None, ),  # 12
    None,  # 13
    (14, TType.STRUCT, 'attributes', [evernote.edam.type.ttypes.NoteAttributes, None], None, ),  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.STRING, 'largestResourceMime', 'UTF8', None, ),  # 20
    (21, TType.I32, 'largestResourceSize', None, None, ),  # 21
)
all_structs.append(NotesMetadataList)
NotesMetadataList.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'startIndex', None, None, ),  # 1
    (2, TType.I32, 'totalNotes', None, None, ),  # 2
    (3, TType.LIST, 'notes', (TType.STRUCT, [NoteMetadata, None], False), None, ),  # 3
    (4, TType.LIST, 'stoppedWords', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'searchedWords', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.I32, 'updateCount', None, None, ),  # 6
)
all_structs.append(NotesMetadataResultSpec)
NotesMetadataResultSpec.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.BOOL, 'includeTitle', None, None, ),  # 2
    None,  # 3
    None,  # 4
    (5, TType.BOOL, 'includeContentLength', None, None, ),  # 5
    (6, TType.BOOL, 'includeCreated', None, None, ),  # 6
    (7, TType.BOOL, 'includeUpdated', None, None, ),  # 7
    (8, TType.BOOL, 'includeDeleted', None, None, ),  # 8
    None,  # 9
    (10, TType.BOOL, 'includeUpdateSequenceNum', None, None, ),  # 10
    (11, TType.BOOL, 'includeNotebookGuid', None, None, ),  # 11
    (12, TType.BOOL, 'includeTagGuids', None, None, ),  # 12
    None,  # 13
    (14, TType.BOOL, 'includeAttributes', None, None, ),  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.BOOL, 'includeLargestResourceMime', None, None, ),  # 20
    (21, TType.BOOL, 'includeLargestResourceSize', None, None, ),  # 21
)
all_structs.append(NoteCollectionCounts)
NoteCollectionCounts.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'notebookCounts', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 1
    (2, TType.MAP, 'tagCounts', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 2
    (3, TType.I32, 'trashCount', None, None, ),  # 3
)
all_structs.append(NoteResultSpec)
NoteResultSpec.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'includeContent', None, None, ),  # 1
    (2, TType.BOOL, 'includeResourcesData', None, None, ),  # 2
    (3, TType.BOOL, 'includeResourcesRecognition', None, None, ),  # 3
    (4, TType.BOOL, 'includeResourcesAlternateData', None, None, ),  # 4
    (5, TType.BOOL, 'includeSharedNotes', None, None, ),  # 5
    (6, TType.BOOL, 'includeNoteAppDataValues', None, None, ),  # 6
    (7, TType.BOOL, 'includeResourceAppDataValues', None, None, ),  # 7
    (8, TType.BOOL, 'includeAccountLimits', None, None, ),  # 8
)
all_structs.append(NoteEmailParameters)
NoteEmailParameters.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'note', [evernote.edam.type.ttypes.Note, None], None, ),  # 2
    (3, TType.LIST, 'toAddresses', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'ccAddresses', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRING, 'subject', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'message', 'UTF8', None, ),  # 6
)
all_structs.append(NoteVersionId)
NoteVersionId.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'updateSequenceNum', None, None, ),  # 1
    (2, TType.I64, 'updated', None, None, ),  # 2
    (3, TType.I64, 'saved', None, None, ),  # 3
    (4, TType.STRING, 'title', 'UTF8', None, ),  # 4
    (5, TType.I32, 'lastEditorId', None, None, ),  # 5
)
all_structs.append(RelatedQuery)
RelatedQuery.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'noteGuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'plainText', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'filter', [NoteFilter, None], None, ),  # 3
    (4, TType.STRING, 'referenceUri', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'context', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'cacheKey', 'UTF8', None, ),  # 6
)
all_structs.append(RelatedResult)
RelatedResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'notes', (TType.STRUCT, [evernote.edam.type.ttypes.Note, None], False), None, ),  # 1
    (2, TType.LIST, 'notebooks', (TType.STRUCT, [evernote.edam.type.ttypes.Notebook, None], False), None, ),  # 2
    (3, TType.LIST, 'tags', (TType.STRUCT, [evernote.edam.type.ttypes.Tag, None], False), None, ),  # 3
    (4, TType.LIST, 'containingNotebooks', (TType.STRUCT, [evernote.edam.type.ttypes.NotebookDescriptor, None], False), None, ),  # 4
    None,  # 5
    (6, TType.LIST, 'experts', (TType.STRUCT, [evernote.edam.type.ttypes.UserProfile, None], False), None, ),  # 6
    (7, TType.LIST, 'relatedContent', (TType.STRUCT, [evernote.edam.type.ttypes.RelatedContent, None], False), None, ),  # 7
    (8, TType.STRING, 'cacheKey', 'UTF8', None, ),  # 8
    (9, TType.I32, 'cacheExpires', None, None, ),  # 9
)
all_structs.append(RelatedResultSpec)
RelatedResultSpec.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'maxNotes', None, None, ),  # 1
    (2, TType.I32, 'maxNotebooks', None, None, ),  # 2
    (3, TType.I32, 'maxTags', None, None, ),  # 3
    (4, TType.BOOL, 'writableNotebooksOnly', None, None, ),  # 4
    (5, TType.BOOL, 'includeContainingNotebooks', None, None, ),  # 5
    None,  # 6
    (7, TType.I32, 'maxExperts', None, None, ),  # 7
    (8, TType.I32, 'maxRelatedContent', None, None, ),  # 8
    (9, TType.SET, 'relatedContentTypes', (TType.I32, None, False), None, ),  # 9
)
all_structs.append(UpdateNoteIfUsnMatchesResult)
UpdateNoteIfUsnMatchesResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'note', [evernote.edam.type.ttypes.Note, None], None, ),  # 1
    (2, TType.BOOL, 'updated', None, None, ),  # 2
)
all_structs.append(ShareRelationshipRestrictions)
ShareRelationshipRestrictions.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'noSetReadOnly', None, None, ),  # 1
    (2, TType.BOOL, 'noSetReadPlusActivity', None, None, ),  # 2
    (3, TType.BOOL, 'noSetModify', None, None, ),  # 3
    (4, TType.BOOL, 'noSetFullAccess', None, None, ),  # 4
)
all_structs.append(InvitationShareRelationship)
InvitationShareRelationship.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'displayName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'recipientUserIdentity', [evernote.edam.type.ttypes.UserIdentity, None], None, ),  # 2
    (3, TType.I32, 'privilege', None, None, ),  # 3
    None,  # 4
    (5, TType.I32, 'sharerUserId', None, None, ),  # 5
)
all_structs.append(MemberShareRelationship)
MemberShareRelationship.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'displayName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'recipientUserId', None, None, ),  # 2
    (3, TType.I32, 'bestPrivilege', None, None, ),  # 3
    (4, TType.I32, 'individualPrivilege', None, None, ),  # 4
    (5, TType.STRUCT, 'restrictions', [ShareRelationshipRestrictions, None], None, ),  # 5
    (6, TType.I32, 'sharerUserId', None, None, ),  # 6
)
all_structs.append(ShareRelationships)
ShareRelationships.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'invitations', (TType.STRUCT, [InvitationShareRelationship, None], False), None, ),  # 1
    (2, TType.LIST, 'memberships', (TType.STRUCT, [MemberShareRelationship, None], False), None, ),  # 2
    (3, TType.STRUCT, 'invitationRestrictions', [ShareRelationshipRestrictions, None], None, ),  # 3
)
all_structs.append(ManageNotebookSharesParameters)
ManageNotebookSharesParameters.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'notebookGuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'inviteMessage', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'membershipsToUpdate', (TType.STRUCT, [MemberShareRelationship, None], False), None, ),  # 3
    (4, TType.LIST, 'invitationsToCreateOrUpdate', (TType.STRUCT, [InvitationShareRelationship, None], False), None, ),  # 4
    (5, TType.LIST, 'unshares', (TType.STRUCT, [evernote.edam.type.ttypes.UserIdentity, None], False), None, ),  # 5
)
all_structs.append(ManageNotebookSharesError)
ManageNotebookSharesError.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'userIdentity', [evernote.edam.type.ttypes.UserIdentity, None], None, ),  # 1
    (2, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFoundException', [evernote.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 3
)
all_structs.append(ManageNotebookSharesResult)
ManageNotebookSharesResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'errors', (TType.STRUCT, [ManageNotebookSharesError, None], False), None, ),  # 1
)
all_structs.append(SharedNoteTemplate)
SharedNoteTemplate.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'noteGuid', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'recipientContacts', (TType.STRUCT, [evernote.edam.type.ttypes.Contact, None], False), None, ),  # 2
    (3, TType.I32, 'privilege', None, None, ),  # 3
    (4, TType.I64, 'recipientThreadId', None, None, ),  # 4
)
all_structs.append(NotebookShareTemplate)
NotebookShareTemplate.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'notebookGuid', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'recipientContacts', (TType.STRUCT, [evernote.edam.type.ttypes.Contact, None], False), None, ),  # 2
    (3, TType.I32, 'privilege', None, None, ),  # 3
    (4, TType.I64, 'recipientThreadId', None, None, ),  # 4
)
all_structs.append(CreateOrUpdateNotebookSharesResult)
CreateOrUpdateNotebookSharesResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'updateSequenceNum', None, None, ),  # 1
    (2, TType.LIST, 'matchingShares', (TType.STRUCT, [evernote.edam.type.ttypes.SharedNotebook, None], False), None, ),  # 2
)
all_structs.append(NoteShareRelationshipRestrictions)
NoteShareRelationshipRestrictions.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'noSetReadNote', None, None, ),  # 1
    (2, TType.BOOL, 'noSetModifyNote', None, None, ),  # 2
    (3, TType.BOOL, 'noSetFullAccess', None, None, ),  # 3
)
all_structs.append(NoteMemberShareRelationship)
NoteMemberShareRelationship.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'displayName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'recipientUserId', None, None, ),  # 2
    (3, TType.I32, 'privilege', None, None, ),  # 3
    (4, TType.STRUCT, 'restrictions', [NoteShareRelationshipRestrictions, None], None, ),  # 4
    (5, TType.I32, 'sharerUserId', None, None, ),  # 5
)
all_structs.append(NoteInvitationShareRelationship)
NoteInvitationShareRelationship.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'displayName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'recipientIdentityId', None, None, ),  # 2
    (3, TType.I32, 'privilege', None, None, ),  # 3
    None,  # 4
    (5, TType.I32, 'sharerUserId', None, None, ),  # 5
)
all_structs.append(NoteShareRelationships)
NoteShareRelationships.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'invitations', (TType.STRUCT, [NoteInvitationShareRelationship, None], False), None, ),  # 1
    (2, TType.LIST, 'memberships', (TType.STRUCT, [NoteMemberShareRelationship, None], False), None, ),  # 2
    (3, TType.STRUCT, 'invitationRestrictions', [NoteShareRelationshipRestrictions, None], None, ),  # 3
)
all_structs.append(ManageNoteSharesParameters)
ManageNoteSharesParameters.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'noteGuid', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'membershipsToUpdate', (TType.STRUCT, [NoteMemberShareRelationship, None], False), None, ),  # 2
    (3, TType.LIST, 'invitationsToUpdate', (TType.STRUCT, [NoteInvitationShareRelationship, None], False), None, ),  # 3
    (4, TType.LIST, 'membershipsToUnshare', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'invitationsToUnshare', (TType.I64, None, False), None, ),  # 5
)
all_structs.append(ManageNoteSharesError)
ManageNoteSharesError.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'identityID', None, None, ),  # 1
    (2, TType.I32, 'userID', None, None, ),  # 2
    (3, TType.STRUCT, 'userException', [evernote.edam.error.ttypes.EDAMUserException, None], None, ),  # 3
    (4, TType.STRUCT, 'notFoundException', [evernote.edam.error.ttypes.EDAMNotFoundException, None], None, ),  # 4
)
all_structs.append(ManageNoteSharesResult)
ManageNoteSharesResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'errors', (TType.STRUCT, [ManageNoteSharesError, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs
